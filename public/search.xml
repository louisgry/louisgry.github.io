<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【XMind】 基础知识体系</title>
      <link href="2020/07/12/%E5%9F%BA%E7%A1%80/xmind/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>2020/07/12/%E5%9F%BA%E7%A1%80/xmind/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="背景篇"><a href="#背景篇" class="headerlink" title="背景篇"></a>背景篇</h2><p><img src="/images/basic/xmind/1.jpg" alt=""></p><h2 id="组成篇"><a href="#组成篇" class="headerlink" title="组成篇"></a>组成篇</h2><p><img src="/images/basic/xmind/2.jpg" alt=""></p><h2 id="计算篇"><a href="#计算篇" class="headerlink" title="计算篇"></a>计算篇</h2><p><img src="/images/basic/xmind/3.jpg" alt=""></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/basic/xmind/4.jpg" alt=""></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><img src="/images/basic/xmind/5.jpg" alt=""><br><img src="/images/basic/xmind/6.jpg" alt=""></p><h2 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h2><p><img src="/images/basic/xmind/7.jpg" alt=""></p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p><img src="/images/basic/xmind/8.jpg" alt=""></p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p><img src="/images/basic/xmind/9.jpg" alt=""><br><img src="/images/basic/xmind/10.jpg" alt=""></p><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p><img src="/images/basic/xmind/11.jpg" alt=""></p><h2 id="提升篇"><a href="#提升篇" class="headerlink" title="提升篇"></a>提升篇</h2><p><img src="/images/basic/xmind/12.jpg" alt=""></p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/images/basic/xmind/13.jpg" alt=""><br><img src="/images/basic/xmind/14.jpg" alt=""></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="/images/basic/xmind/15.jpg" alt=""></p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p><img src="/images/basic/xmind/16.jpg" alt=""></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="/images/basic/xmind/17.jpg" alt=""><br><img src="/images/basic/xmind/18.jpg" alt=""><br><img src="/images/basic/xmind/19.jpg" alt=""></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><img src="/images/basic/xmind/20.jpg" alt=""><br><img src="/images/basic/xmind/21.jpg" alt=""><br><img src="/images/basic/xmind/22.jpg" alt=""></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><img src="/images/basic/xmind/23.jpg" alt=""><br><img src="/images/basic/xmind/24.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> XMind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3入门与进阶-imooc</title>
      <link href="2020/04/10/Python/Python%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>2020/04/10/Python/Python%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="#1：Python入门导学">1：Python入门导学</a><br><a href="#2：Python环境安装">2：Python环境安装</a><br><a href="#3：理解写代码与Python基本类型">3：理解写代码与Python基本类型</a><br><a href="#4：python中表示“组”的概念和定义">4：python中表示“组”的概念和定义</a><br><a href="#5：变量与运算符">5：变量与运算符</a><br><a href="#6：分支、循环、条件">6：分支、循环、条件</a><br><a href="#7：包、模块、函数与变量作用域">7：包、模块、函数与变量作用域</a><br><a href="#8：Python函数">8：Python函数</a><br><a href="#9：高级部分-面向对象">9：高级部分-面向对象</a><br><a href="#10：正则表达式与JSON">10：正则表达式与JSON</a><br><a href="#11：Python的高级语法与用法">11：Python的高级语法与用法</a><br><a href="#12：函数式编程">12：函数式编程</a><br><a href="#13：实战-爬虫">13：实战-爬虫</a><br><a href="#14：Pythonic与Python杂记">14：Pythonic与Python杂记</a></p><a id="more"></a><h3 id="1：Python入门导学"><a href="#1：Python入门导学" class="headerlink" title="1：Python入门导学"></a>1：Python入门导学</h3><p>效率</p><ul><li>1.1：导学<ul><li>Python诞生于上世纪90年代</li><li>广泛使用公司：豆瓣、知乎</li><li><blockquote><p>了解语法是编程的先决条件，精通语法是编程的必要条件</p></blockquote></li><li>详细讲解常见错误、Pythonic、提炼实际编程中遇到的问题</li><li>最基础的Python语法编写一个爬虫（了解爬虫原理）</li><li>Life is short, I use Python（简洁）</li><li>一生只能选一种语言，我会选Python</li><li>Pythonic：例如交换变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y &#x3D; y, x</span><br></pre></td></tr></table></figure></li><li>Python能做什么：AI、大数据、测试、Web</li><li>Python之禅：<code>import this</code></li></ul></li><li>1-2：Python的特点<ul><li>跨平台、强大的第三方库、面向对象</li></ul></li><li>1-3：我为什么喜欢Python<ul><li>Python既有动态脚本的特性（动态变量），又有面向对象的特性（js支持不好）</li></ul></li><li>1-4：Python的缺点（慢）<ul><li>编译型语言（C、C++）</li><li>解释型语言（Javascript、Python）</li><li>个例，Java和C#（编译不会成机器语言而是中间语言）</li><li>效率的两种理解：运行效率和开发效率</li></ul></li><li>1-5：一个经典的误区<ul><li>编程=Web编程？</li></ul></li><li>1-6：Python能做些什么<ul><li>自动化运维（实际工作是怎么样的？？）</li><li>胶水语言（怎么把C++、Java整合到一起？？）</li><li>几乎是万能的：当你遇到问题，就编写Python代码解决问题</li></ul></li><li>1-7：课程内容与特点<ul><li>基础语法与Pythonic</li><li>Python高性能与优化</li><li>数据结构</li></ul></li><li>1-8：Python的前景<ul><li>排行榜第四</li></ul></li></ul><h3 id="2：Python环境安装"><a href="#2：Python环境安装" class="headerlink" title="2：Python环境安装"></a>2：Python环境安装</h3><ul><li>2-4：Python多版本问题<ul><li>查看版本：<code>python -V</code></li><li>linux查找目录：<code>which python3</code></li></ul></li><li>2-8：IDLE与第一段Python代码<ul><li><a href="https://docs.python.org/3/library/idle.html" target="_blank" rel="noopener">IDLE</a>：IDLE is Python’s Integrated Development and Learning Environment. </li></ul></li></ul><h3 id="3：理解写代码与Python基本类型"><a href="#3：理解写代码与Python基本类型" class="headerlink" title="3：理解写代码与Python基本类型"></a>3：理解写代码与Python基本类型</h3><ul><li>3-1：代码，写代码<ul><li>代码：现实世界事物在计算机世界中的映射</li><li>写代码：将现实世界中的事物用计算机语言来描述</li></ul></li><li>3-2：整型与浮点型<ul><li>Number数据类型<ul><li>包括：整数（int），浮点数（float）</li><li>注意：Python里没有单精度、双精度的区分，Python的float就是双精度的</li></ul></li><li>整数除整数，特例情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(2&#x2F;2)  # &#x3D;&#x3D;&gt; &lt;class &#39;float&#39;&gt;</span><br><span class="line">type(2&#x2F;&#x2F;2) # &#x3D;&#x3D;&gt; &lt;class &#39;int&#39;&gt;</span><br><span class="line">1&#x2F;&#x2F;2 # &#x3D;&#x3D;&gt; 0</span><br></pre></td></tr></table></figure></li></ul></li><li>3-3：进制<ul><li>Python2：有 long（长整型）</li></ul></li><li>3-4：各进制的表示与转换<ul><li>二进制：在前面加<code>0b</code>（默认输出十进制）</li><li>八进制：在前面加<code>0o</code></li><li>十六进制：在前面加<code>0x</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0b10 # &#x3D;&#x3D;&gt; 2</span><br><span class="line">10 # &#x3D;&#x3D;&gt; 10</span><br><span class="line">0o10 # &#x3D;&#x3D;&gt; 8</span><br><span class="line">0x10 # &#x3D;&#x3D;&gt; 16</span><br></pre></td></tr></table></figure></li><li><code>bin()</code>：各进制转二进制</li><li><code>int()</code>：各进制转十进制</li><li><code>oct()</code>：各进制转八进制</li><li><code>hex()</code>：各进制转十六进制</li></ul></li><li>3-5：布尔类型与复数<ul><li>Number类型：int、float、bool、complex（复数）<ul><li>复数：在数字后面加‘j’（36j）</li></ul></li><li>bool：<code>True、False均大写</code></li><li>False：数值为0、None和空时为False<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int(True) # &#x3D;&#x3D;&gt; 1</span><br><span class="line">int(False) # &#x3D;&#x3D;&gt; 0</span><br><span class="line">bool(-1.1) # &#x3D;&#x3D;&gt; True</span><br><span class="line">bool(0) # &#x3D;&#x3D;&gt; False</span><br><span class="line">bool(None) # &#x3D;&#x3D;&gt; False</span><br><span class="line">bool(&#39;&#39;) # &#x3D;&#x3D;&gt; False</span><br></pre></td></tr></table></figure></li></ul></li><li>3-6：字符串<ul><li>str字符串：单引号和双引号是一样的</li></ul></li><li>3-7：多行字符串<ul><li>三引号<code>&#39;&#39;&#39;</code>（包括是三个单引号、双引号）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;&#39; </span><br><span class="line">Hello world</span><br><span class="line">hello world</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure></li></ul></li><li>3-8：转义字符<ul><li>加<code>\</code>（<code>\n</code>换行<code>、\t</code>制表符、<code>\r</code>回车）</li></ul></li><li>3-9：原始字符串<ul><li>输出原始字符串：加<code>r</code></li><li><code>print(r&#39;c:\northwind\north&#39;)</code></li></ul></li><li>3-10~12：字符串运算<ul><li><code>+</code>：合并字符串、<code>*</code>：重复字符串</li><li>索引和切片：截取字符串（不包括最后一个，左闭右开）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;helloworld&#39;*3)&#96; # &#x3D;&#x3D;&gt; &#39;helloworldhelloworldhelloworld&#39;</span><br><span class="line">&quot;helloworld&quot;[-1] # &#x3D;&#x3D;&gt; &#39;d&#39;</span><br><span class="line">&quot;helloworld&quot;[0:5] # &#x3D;&#x3D;&gt; &#39;hello&#39;</span><br></pre></td></tr></table></figure></li><li>从头或从尾截取（:所在位置）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;python c c++ c# java javascript python&quot;[:6] # &#x3D;&#x3D;&gt; &#39;python&#39;</span><br><span class="line">&quot;python c c++ c# java javascript python&quot;[-6:] # &#x3D;&#x3D;&gt; &#39;python&#39;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4：Python中表示“组”的概念和定义"><a href="#4：Python中表示“组”的概念和定义" class="headerlink" title="4：Python中表示“组”的概念和定义"></a>4：Python中表示“组”的概念和定义</h3><ul><li>4-1：列表（list）的定义<ul><li>list：列表内部元素可以为任意类型，也可以为列表（列表里嵌套列表，二维数组）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;hello&quot;, &quot;world&quot;, 1, 9, True, False]</span><br><span class="line">[[1,2,3], [4,5,6]]</span><br></pre></td></tr></table></figure></li></ul></li><li>4-2：列表的基本操作<ul><li>加法（没有减法）：合并list</li><li>乘法（不是乘列表）：重复元素</li><li>索引和切片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#39;hello&#39;] + [&#39;world&#39;] # &#x3D;&#x3D;&gt; [&#39;hello&#39;, &#39;world&#39;]</span><br><span class="line">[1] + [2] # &#x3D;&#x3D;&gt; [1,2]</span><br><span class="line">[1,2,3]*3 # &#x3D;&#x3D;&gt; [1,2,3,1,2,3,1,2,3]</span><br><span class="line">[&#39;hello&#39;, &#39;world&#39;][0] # &#x3D;&#x3D;&gt; &#39;hello&#39;</span><br></pre></td></tr></table></figure></li></ul></li><li>4-3：元组（tuple）<ul><li>元组内部也可以是多类型，与列表的区别：不可更改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,2,True,&#39;a&#39;)</span><br></pre></td></tr></table></figure></li><li>元组的操作：加法、乘法、索引和切片</li><li>单个元组表示：要用<code>(1,)</code>，<code>()</code>表示括号运算(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type((1)) # &#x3D;&#x3D;&gt;  &lt;class &#39;int&#39;&gt;</span><br><span class="line">type((&#39;1&#39;)) # &#x3D;&#x3D;&gt;  &lt;class &#39;str&#39;&gt;</span><br><span class="line">type((1,)) # &#x3D;&#x3D;&gt;  &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">type([1,]) # &#x3D;&#x3D;&gt; &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>4-4：序列总结<ul><li>序列：str，list，tuple（序列里面的元素都有序号）</li><li>序列共有操作：加法、乘法、索引、切片</li><li>判断元素是否在序列中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 in [1,2,3,4,5] # &#x3D;&#x3D;&gt; True</span><br><span class="line">3 not in [1,2,3,4,5] # &#x3D;&#x3D;&gt; False</span><br></pre></td></tr></table></figure></li><li>长度、最值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len(&#39;hello world&#39;) # &#x3D;&#x3D;&gt; 11</span><br><span class="line">max([1,2,3,4,5]) # &#x3D;&#x3D;&gt; 5</span><br><span class="line">min(&#39;hello world&#39;) # &#x3D;&#x3D;&gt; 输出空格</span><br><span class="line">max(&#39;hello world&#39;) # &#x3D;&#x3D;&gt; w</span><br></pre></td></tr></table></figure></li><li>获取ascii码（ord）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord(w) # &#x3D;&#x3D;&gt; 119</span><br></pre></td></tr></table></figure></li></ul></li><li>4-5：set集合<ul><li>set最大的特点：无序</li><li>第二个特点：不重复<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(&#123;1,2,3&#125;) # 定义集合 &#123; &#125;</span><br><span class="line">&#123;1,1,2,2,3,3&#125; # &#x3D;&#x3D;&gt; &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></li><li>set获取不了元素、无法进行切片，无加法乘法</li><li>其他操作：长度len，最值，是否在集合中in</li><li>特殊操作：-（求差集），&amp;（求交集），|（求并集）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3,4,5&#125; - &#123;4,5&#125; # &#x3D;&#x3D;&gt; &#123;1,2,3&#125;</span><br><span class="line">&#123;1,2,3,4,5&#125; &amp; &#123;4,5,6,7&#125; # &#x3D;&#x3D;&gt; &#123;4,5&#125;</span><br><span class="line">&#123;1,2,3,4,5&#125; | &#123;3,4,5,6&#125; # &#x3D;&#x3D;&gt; &#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure></li><li>空集合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(&#123;&#125;) # &#x3D;&#x3D;&gt; class &#39;dict&#39;</span><br><span class="line">type(set()) # &#x3D;&#x3D;&gt; class &#39;set&#39;</span><br></pre></td></tr></table></figure></li></ul></li><li>4-5：dict字典<ul><li>字典：key（不重复），value（可重复）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;Q&#39;:1, &#39;W&#39;: 2&#125;</span><br><span class="line">&#123;&#39;Q&#39;:1, &#39;W&#39;: 2&#125;[&#39;Q&#39;]</span><br></pre></td></tr></table></figure></li><li>key不重复（不可变）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1: &#39;hello&#39;, &#39;1&#39;:&#39;world&#39;&#125; # &#x3D;&#x3D;&gt; 1、&#39;1&#39; key不同</span><br></pre></td></tr></table></figure></li></ul></li><li>4-6：总结基本数据类型<ul><li>数字（Number）<ul><li>整型 int</li><li>浮点型 float</li><li>布尔型 bool</li><li>复数 complex</li></ul></li><li>组<ul><li>序列：字符串 str，列表 list，元组 tuple</li><li>集合 set</li><li>字典 dict</li></ul></li></ul></li></ul><h3 id="5：变量与运算符"><a href="#5：变量与运算符" class="headerlink" title="5：变量与运算符"></a>5：变量与运算符</h3><ul><li>5-1：变量<ul><li>动态变量</li></ul></li><li>5-2：变量命名规范<ul><li>模块变量函数名：首字母不能是数字、小写、单词间用_分割</li><li>类名：首字母大写</li><li>私有变量：双下划线开头</li></ul></li><li>5-3：值类型与引用类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type &#x3D; 1</span><br><span class="line">type(1) # &#x3D;&#x3D;&gt; &#39;int&#39; object is not callable （不可调用的）</span><br><span class="line">del type # 释放变量内存</span><br></pre></td></tr></table></figure><ul><li>值类型（不可改变int，str，tuple）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; a</span><br><span class="line">a &#x3D; 3</span><br><span class="line">print(b)&#96; # &#x3D;&#x3D;&gt; 1</span><br></pre></td></tr></table></figure></li><li>引用类型（可变list，set，dict）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; a</span><br><span class="line">a[0] &#x3D; &#39;1&#39;</span><br><span class="line">print(b)&#96; # &#x3D;&#x3D;&gt; [&#39;1&#39;,2,3]</span><br></pre></td></tr></table></figure></li><li>思考解释：str是不可变，那字符串相加不是改变了？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; &#39;hello&#39;</span><br><span class="line">id(b)</span><br><span class="line">b &#x3D; b + &#39;python&#39;</span><br><span class="line">id(b) # &#x3D;&#x3D;&gt; id改变了，说明引入了新的字符串来相加</span><br></pre></td></tr></table></figure></li></ul></li><li>5-4：列表的可变与元组的不可变<ul><li>可改变的元组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; (1,2,[3,4])</span><br><span class="line">a[2]&#x3D;5 # &#x3D;&#x3D;&gt; TypeError</span><br><span class="line">a[2][0] &#x3D; 5 # &#x3D;&#x3D;&gt; (1,2,[5,4])</span><br></pre></td></tr></table></figure></li></ul></li><li>5-6：赋值运算符<ul><li>Python没有<code>++</code>, <code>--</code>操作</li></ul></li><li>5-8：不只是数字才能做比较运算<ul><li>思考题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x3D;1</span><br><span class="line">b+&#x3D;b&gt;&#x3D;1 # &#x3D;&#x3D;&gt;2 (1+True&#x3D;2)</span><br></pre></td></tr></table></figure></li></ul></li><li>5-9：逻辑运算符<ul><li>当作bool的非bool类型运算（考虑短路原则）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;a&#39; and &#39;b&#39;;  &#39;a&#39; or &#39;b&#39; # &#x3D;&#x3D;&gt; &#39;b&#39;, &#39;a&#39;</span><br><span class="line">[] and [1];  [1] and [] # &#x3D;&#x3D;&gt; [1],[1]</span><br><span class="line">0 or 1;  1 or 0; 1 or 2 # &#x3D;&#x3D;&gt; 1,1,1</span><br></pre></td></tr></table></figure></li></ul></li><li>5-10：成员运算符<ul><li>in和not in</li><li>字典dict：只针对key<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 in &#123;&#39;a&#39;:1&#125; # &#x3D;&#x3D;&gt; False, </span><br><span class="line">&#39;a&#39; in &#123;&#39;a&#39;:1&#125; # &#x3D;&#x3D;&gt; True</span><br></pre></td></tr></table></figure></li></ul></li><li>5-11：身份运算符<ul><li>is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;1, b&#x3D;2, a is b # &#x3D;&#x3D;&gt; False</span><br></pre></td></tr></table></figure></li><li>is与==的区别：is判断id<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;1</span><br><span class="line">b&#x3D;1.0</span><br><span class="line">a&#x3D;&#x3D;b # &#x3D;&#x3D;&gt; True</span><br><span class="line">a is b # &#x3D;&#x3D;&gt; False( id 不相等）</span><br></pre></td></tr></table></figure></li><li>is not</li></ul></li><li>5-12：如何判断变量的值、身份与类型<ul><li>对象的三大特征：</li><li>值 ==，身份 is，类型 type（isinstance更好：可以判断变量子类的类型）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(&#39;hello&#39;, str) # &#x3D;&#x3D;&gt; True</span><br><span class="line">isinstance(&#39;hello&#39;, (int,float,str)) # &#x3D;&#x3D;&gt; 是否是int，float，str中的一种类型</span><br></pre></td></tr></table></figure></li></ul></li><li>5-13：位运算符（把数字当作二进制数进行运算）<ul><li><code>&amp;</code>：按位与</li><li><code>|</code>：按位或</li><li><code>^</code>：按位异或（相异为真）</li><li><code>~</code>：按位取反</li><li><code>&lt;&lt;</code>：左移动</li><li><code>&gt;&gt;</code>：右移动</li></ul></li></ul><h3 id="6：分支、循环、条件"><a href="#6：分支、循环、条件" class="headerlink" title="6：分支、循环、条件"></a>6：分支、循环、条件</h3><ul><li>6-1：什么是表达式<ul><li>表达式（Expression）是运算符（operator）和操作数（operand）所构成的序列</li></ul></li><li>6-2~3：表达式优先级<ul><li>not 先于 and 先于 or</li></ul></li><li>6-4~5：VSCode开发环境与Python插件安装<ul><li><a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">应用商店</a></li><li>右键文件“在命令行打开”定位到文件目录 </li><li>自动保存：文件 - 自动保存</li><li>命令行：<code>ctrl+~</code></li><li>查找文件：<code>ctrl+p</code></li><li>快捷键修改：<code>shift + enter</code></li></ul></li><li>6-6~7： 流程控制语句之条件控制<ul><li>pymysql 规范代码<code>__init__.py</code></li><li>两个特点：<ul><li>末尾不需要加；</li><li>不需要加{}，以缩进表示代码块</li></ul></li><li>多行注释<code>&#39;&#39;&#39;</code></li><li>条件判断：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_password &#x3D; input()</span><br><span class="line">if user_password &#x3D;&#x3D; &#39;123456&#39;:</span><br><span class="line">    print(&#39;Login successfully!&#39;)</span><br></pre></td></tr></table></figure></li></ul></li><li>6-8：常量与Pylint规范<ul><li>Python常量：<code>全大写</code></li><li>Python变量：在函数、类中</li><li><code>:</code> 前面不要有空格</li><li><code>程序末尾需换行</code></li></ul></li><li>6-9：snippet、嵌套<ul><li>snippet：一般不用，手写if else的过程中思考</li><li><code>pass</code>：空语句占位，搭程序框架、API接口交互</li><li>python没有<code>goto</code>关键字</li><li>思想：不要嵌套多层，使用<code>函数</code>封装</li></ul></li><li>6-10：elif的优点<ul><li>python没有<code>switch</code>，用<code>elif</code>替代</li><li>python官网<a href="https://docs.python.org/3/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python" target="_blank" rel="noopener">Design and History</a></li></ul></li><li>6-11：改变定势思维<ul><li>a和b为数字，但不同时为False<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a or b</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7：包、模块、函数与变量作用域"><a href="#7：包、模块、函数与变量作用域" class="headerlink" title="7：包、模块、函数与变量作用域"></a>7：包、模块、函数与变量作用域</h3><ul><li>7-1：while循环及使用场景<ul><li>while…else<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while count&lt;10:</span><br><span class="line">    print(count)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;EOF&#39;)</span><br></pre></td></tr></table></figure></li></ul></li><li>7-2：for与for-else循环<ul><li>for循环：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in x_list:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure></li><li>for-else：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for x in range(5):</span><br><span class="line">    print(x)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;for-else&#39;)</span><br></pre></td></tr></table></figure></li></ul></li><li>7-3：for与range<ul><li>range：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in range(0,10,2):</span><br><span class="line">    print(x)  # &#x3D;&#x3D;&gt; 0,2,4,6,8</span><br></pre></td></tr></table></figure></li><li>逆序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in range(10,0,-2): </span><br><span class="line">    print(x)  # &#x3D;&#x3D;&gt; 10,8,6,4,2</span><br></pre></td></tr></table></figure></li></ul></li><li>7-4：新篇章<ul><li>for循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0,len(li),2):</span><br><span class="line">    print(li[i])</span><br></pre></td></tr></table></figure></li><li>用切片代替循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(li[0: len(li): 2])</span><br></pre></td></tr></table></figure></li></ul></li><li>7-5~6：Python工程的组织结构：包、模块、类<ul><li>组织结构：包（文件夹）、模块（文件）、类</li><li>命名空间</li><li>包与普通文件夹的区别：是否含有<code>__init__.py</code></li><li><code>__init__.py</code>的模块名就是他的包名，不是<code>seven.__init__</code></li></ul></li><li>7-7：import导入模块<ul><li>导入“包.模块”名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import t.c1</span><br><span class="line">import t.c7 as c</span><br></pre></td></tr></table></figure></li><li><code>__pycache__</code>里的<code>.pyc</code>文件是Python的字节码文件</li></ul></li><li>7-8：from import导入变量<ul><li>from import<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from t.c7 import a</span><br></pre></td></tr></table></figure></li><li>直接导入模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from t import c7</span><br><span class="line">print(c7.a)</span><br></pre></td></tr></table></figure></li><li>不推荐：<code>from t import *</code></li><li>如果要<code>import *</code>，可以在类中可定义‘*’的变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__all__ &#x3D; [&#39;a&#39;,&#39;c&#39;]  # b不让导入</span><br><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">c &#x3D; 3</span><br></pre></td></tr></table></figure></li></ul></li><li>7-9：<code>__init__.py</code> 的用法<ul><li>vscode设置隐藏pycache文件夹：<ul><li>用户设置 - ‘files.exclude’ - ‘<strong>pycache</strong>‘</li></ul></li><li>换行的两种方法：<ul><li><code>\</code>（不推荐）</li><li><code>()</code>（推荐）</li></ul></li><li>导入多个模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from c9 import a, b, c</span><br></pre></td></tr></table></figure></li><li><code>__init__.py</code> 导入时会自动运行<ul><li>在c11.py中<code>import t</code>，<code>print(&#39;this is __init__.py&#39;</code> 会被自动执行</li><li>限制导入哪个包：在<code>__init__.py</code>中限制<code>__all__ = [&#39;c7&#39;]</code></li></ul></li><li>批量导入（多个模块需要）：在<code>__init__.py</code>中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">import pandas</span><br></pre></td></tr></table></figure></li><li>vscode清屏命令：<code>cls</code></li></ul></li><li>7-10：包与模块的几个常见错误<ul><li>包和模块不会被重复导入</li><li>不能循环导入：<code>p1 import p2, p2 import p1</code></li></ul></li><li>7-11：模块内置变量<ul><li>在模块中，使用dir()函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir())  # 返回当前模块的所有变量</span><br></pre></td></tr></table></figure></li><li><code>__name__</code>：t.c9</li><li><code>__package__</code>：t</li><li><code>__doc__</code>：docstring（’’’）</li><li><code>__file__</code>：路径</li></ul></li><li>7-12：入口文件和普通模块内置变量的区别<ul><li>Error（must be str, not NoneType）修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(__doc__ or &#39;none doc string&#39;)</span><br></pre></td></tr></table></figure></li><li>入口文件的差异：<ul><li><code>print(__name__)</code>是<code>__main__</code></li></ul></li><li><code>__package__</code>没有值：因为入口文件的包是顶级</li></ul></li><li>7-13：<code>__name__</code>的经典应用<ul><li>dir查看某个模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">dir(sys)</span><br></pre></td></tr></table></figure></li><li>既可作模块也可作可执行文件：当import时，不会执行if里的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;: ... # make a script both importable and executable</span><br></pre></td></tr></table></figure></li><li>可执行文件以模块方式运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m seven.c13  # 直接使用c13会报错</span><br></pre></td></tr></table></figure></li></ul></li><li>7-14：相对导入和绝对导入（一）<ul><li>关于顶级包的理解（不是绝对的，取决于入口文件的位置）<ul><li>目录结构为：demo下有package1、package2、main.py，则<code>import package1.m</code></li><li>目录结构为：demo下有package1、package2、main.py在package2中，则<code>import demo.package1.m</code></li></ul></li><li>入口文件一般为 <code>main.py</code>（入口文件不能用相对导入）</li><li>绝对导入：从顶级包开始导入</li><li>相对导入：<code>.</code>表示同级，<code>..</code>表示上一级</li></ul></li><li>7-15：相对导入和绝对导入（二）<ul><li>更改顶级包位置：将可执行文件以模块方式运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">python -m demo.main</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8：Python函数"><a href="#8：Python函数" class="headerlink" title="8：Python函数"></a>8：Python函数</h3><ul><li>8-1：认识函数<ul><li>round函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(a, 2) # 四舍五入保留两位小数</span><br><span class="line">round(4.5)  # &#x3D;&#x3D;&gt; 4，五保留</span><br></pre></td></tr></table></figure></li><li>vscode新建另一个命令行：旁边的加号进入python命令行</li><li><code>help(round)</code> # 查看函数信息，Enter翻页</li><li>特点：功能性，隐藏细节（使用时候简单），避免编写重复的代码</li></ul></li><li>8-2：函数的定义及运行特点<ul><li>递归错误RecursionError: maximum recursion depth exceeded</li><li><code>import sys ... sys.setrecursionlimit(100000)</code></li><li>函数调用顺序及return None</li><li><code>a = add(1,2)</code> <code>b = print_code(&#39;python&#39;)</code> <code>print(a,b)</code> # ==&gt; python …3 None</li></ul></li><li>8-3：如何让函数返回多个结果<ul><li>return之后的代码不会执行</li><li>返回多值：<code>return a, b</code></li><li>用索引查找返回结果是很不好的，建议使用序列解包：</li><li><code>ans1, ans2 = fun(a, b)</code></li></ul></li><li>8-4：序列解包与链式赋值<ul><li>序列解包：</li><li><code>d = 1, 2, 3</code> # class ‘tuple’  <code>a, b, c = d</code></li><li>链式赋值：</li><li><code>a=b=c=1</code></li></ul></li><li>8-5：必须参数与关键字参数<ul><li>形参、实参</li><li>关键字参数（代码的可读性）：</li><li><code>ans = add(b=1, a=2)</code> # 不需要按顺序赋值</li></ul></li><li>8-6：默认参数<ul><li>坑：不能将必须参数放在默认参数之后</li><li>Error: def add(a, b=1, c)</li></ul></li><li>8-7：可变参数<ul><li>可变参数（加*）</li><li><code>def demo(*param): ... print(param) ... print(type(param)) ... demo(1,2,3,4)</code> # (1,2,3,4) class ‘tuple’</li><li>特性：实参加*，不会叠加成二维tuple，如下</li><li><code>a = (1,2,3,4) ... demo(*a)</code> <code>demo(*[1,2,3])</code></li></ul></li><li>8-8：关键字可变参数<ul><li>for 遍历可变参数</li><li><code>for i in param: ... sum += i</code></li><li>关键字可变参数（支持任意个数关键字）</li><li><code>def tem(**param): ... print(param)</code></li><li><code>tem(bj=32, xm=30,sh=31)</code></li><li>打印key和value</li><li><code>for key, value in param.items(): ... print(key, &#39;:&#39;, value)</code></li><li>特性：<code>a={&#39;xm&#39;: 30, &#39;sh&#39;: 31}</code> <code>tem(**a)</code></li></ul></li><li>8-9：变量作用域<ul><li>函数里面调用函数</li><li><code>def fun1(): ... c = 2 ... def fun2(): c=3 print(c) ... fun2()</code> <code>fun1()</code> # 3</li></ul></li><li>8-10：作用域链<ul><li>上面那个代码：作用域的链式特性</li><li>纠正：for里面不算作用域！ </li></ul></li><li>8-11：global关键字<ul><li>内部变量变成全局变量：<code>global a</code></li></ul></li><li>8-12：划算还是不划算<ul><li>Python最适合用来解决问题（不要局限于web编程）</li><li>练习：游戏的经济系统（五行石合成问题）<ul><li>探究自己合成划算，还是从别人那购买划算</li><li>合成过程消耗金、钻石、体力（为了得到6级五行石）</li><li>1级：金+钻石；3级：+1级；4级：+一定概率；6级：4级<h3 id="9：高级部分-面向对象"><a href="#9：高级部分-面向对象" class="headerlink" title="9：高级部分-面向对象"></a>9：高级部分-面向对象</h3></li></ul></li></ul></li><li>9-1：类的定义<ul><li>类 != 就是面向对象</li><li>面向对象核心：类（数据成员&amp;方法）、对象</li><li>类（class，<strong>首字母大写</strong>，不要用_连接，基本作用：封装）</li><li><code>class Student(): ... name = &#39;&#39; ... def print_file(self): ...print(&#39;name:&#39; + self.name)</code> # 必须加<strong>self</strong></li><li>实例化：<code>student = Student()</code> # 不需要new关键字</li><li><code>student.print_file()</code>  # 调用类中的方法（不是函数，有self关键字，调用在类外）</li></ul></li><li>9-3：类与对象<ul><li>类：是现实世界或思维世界中的实体在计算机中的反映</li><li>它将数据以及这些数据的操作封装在一起</li><li>设计：特征 + 行为 </li></ul></li><li>9-4：构造函数<ul><li><code>__init__()</code> # 构造函数，自动调用</li><li><code>type(student.__init__())</code> # NoneType，显式调用，<strong>不能return值</strong></li><li>初始化对象属性：</li><li><code>def __init__(self, name,  age): ... self.name = name ... self.age = age</code></li></ul></li><li>9-6：类变量与实例变量<ul><li>类变量（类）：<code>name=&#39;&#39; ... age=0</code> # 使用self保存类变量</li><li>实例变量（对象）：<code>student = Student(&#39;louis&#39;, 23)</code></li><li>赋值：<code>self.name = name</code></li><li>self不是关键字，可以改其他名称如this</li><li>实例变量<code>print(student.name)</code> 类变量<code>print(Student.name)</code></li></ul></li><li>9-7：类与对象的变量查找顺序<ul><li>学习方法：实例讲解</li><li>为什么<code>name=name ... age=age</code>会为初始值</li><li><code>print(student.__dict__)</code> # <strong>dict</strong>保存变量，此时为空</li><li>寻找机制：先查找实例变量，再查找类变量，最后查找父类中的变量</li></ul></li><li>9-8：self与实例方法<ul><li>实例方法：第一个参数是self</li><li>调用不需要self，在<strong>init</strong>中调用</li><li><code>print(name)</code> #  打印出实例变量</li><li>self：当前调用某一个方法的对象</li></ul></li><li>9-9：在实例方法中访问实例变量与类变量<ul><li>类：<ul><li>变量（类变量、实例变量）</li><li>方法（实例方法、类方法、静态方法）</li><li>构造方法</li></ul></li><li>实例方法中访问类变量：self.变量</li><li><code>print(Student.sum)</code> <code>print(self.__class__.sum)</code></li><li>实例方法中：<code>print(self.name) ... print(name)</code> # 值一样，但是二者不相等，第二个是形参</li></ul></li><li>9-10：类方法<ul><li>类方法：专门操作类变量，不操作实例变量时（访问不了实例变量）</li><li>定义：<code>@classmethod</code> # 类方法标记，装饰器</li><li><code>def plus_sum(cls):</code> # 首字母cls</li><li><code>cls.sum += 1 ... print(cls.sum)</code><ul><li><code>Student.plus_sum()</code></li></ul></li><li>建议不要：用对象调用<code>student.plus_sum()</code></li></ul></li><li>9-11：静态方法<ul><li>定义：<code>@staticmethod</code> # 装饰器标记</li><li><code>def add(x,y):  .... print(&#39;static method&#39;)</code></li><li>可以同时被类和对象调用</li><li>与面向对象关联很弱，不建议使用</li><li><strong>Python的类方法与C#的静态方法类似</strong></li></ul></li><li>9-12：成员可见性<ul><li>私有：变量函数前加__</li><li>构造函数（特有函数，前后都有__ 就不是私有了）</li><li>但是私有变量还是能访问：<code>student.__score = -1</code> #  但不是类变量</li></ul></li><li>9-13：没有什么是不能访问<ul><li><code>student.__score = -1</code> <code>print(Student.__dict__)</code> #_Student__score, __score</li><li>间接读取私有变量：<code>student._Student__score</code> # 设置私有即更改类名</li></ul></li><li>9-14：继承<ul><li><code>class People(): ... def __init__(self, name, age): ... self.name=name ... self.age=age ... def get_name(self): ... print(self.name)</code></li><li><code>from c6 import People ... class Student(People): ...pass</code></li><li><code>student = Student(&#39;louis&#39;, 23) ...print(student.name)</code></li><li>构造函数的继承</li><li><code>Student(People): ... def __init__(self, school, name, age): ... self.school=school ... People.__init__(self, name,  age)</code> # 子类显式调用父类构造函数（<strong>要传入self</strong>）</li></ul></li><li>9-15：子类方法调用父类方法<ul><li>People.<strong>init</strong>(self, name, age) 类调用实例方法（普通方法调用）</li><li>知识点：Student.do_homework() # Error：需要传入self = student，’louis’</li><li>开闭原则：不能因为父类变了更改代码</li><li>使用<code>super</code>关键字调用（super代表父类）</li><li><code>super(Student, self).__init(name, age)</code> 替换上面的People.<strong>init</strong></li><li>子类方法与父类方法同名，使用子类方法</li><li>调用父类方法：<code>super(Student, self).do_homework()</code></li></ul></li></ul><h3 id="10：正则表达式与JSON"><a href="#10：正则表达式与JSON" class="headerlink" title="10：正则表达式与JSON"></a>10：正则表达式与JSON</h3><ul><li>10-1：初始正则表达式<ul><li>正则表达式：是一个特殊的字符序列，一个字符串是否与我们所设定的这样的字符序列相匹配</li><li>用于快速检索文本、实现一些替换文本操作</li><li>检测字符串<code>a = &#39;C C++ Java Python Javascript&#39;</code>是否包含‘Python’</li><li><code>&#39;Python&#39; in a</code>或<code>a.index(&#39;Python&#39;) &gt; -1</code></li><li>使用正则表达式：</li><li><code>import re ... r=re.findall(&#39;Python&#39;, a)</code>  # ==&gt; [‘Python’]</li><li>正则表达式的灵魂：规则</li></ul></li><li>10-2：元字符与普通字符<ul><li>提取字符串中所有的数字：</li><li><code>r = re.findall(&#39;\d&#39;, a)</code></li><li>提取字符串中的非数字：</li><li><code>r = re.findall(&#39;\D&#39;, a)</code></li><li>元字符：\d，普通字符：Python</li></ul></li><li>10-3：字符集<ul><li>字符集：<code>s = &#39;abc, acc, adc, aec, afc&#39;</code></li><li>查找字符串中间一个是c或f的字符：</li><li><code>r = re.findall(&#39;a[cf]c&#39;, s)</code> # acc, afc</li><li><code>r = re.findall(&#39;[cf]&#39;, s)</code> # c,c,c,c,c</li><li><code>[]</code>：中括号表示’或’关系</li><li>匹配不是c和f的字符：<code>a[^cf]c</code></li><li>匹配c到f的字符：<code>a[c-f]c</code></li></ul></li><li>10-4：概括字符集<ul><li>找数字的另一种方法：<code>[0-9]</code>，非数字：<code>[^0-9]</code></li><li>匹配数字和字母：<code>\w</code> = <code>[A-Za-z0-9_]</code></li><li>非数字和字母：<code>\W</code> # 包括空格和回车</li><li>匹配空白字符：<code>\s</code> # 回车，制表符，空格</li><li>匹配换行符\n以外的字符：<code>.</code></li></ul></li><li>10-5：数量词<ul><li><code>a = &#39;python 111 java php&#39;</code></li><li>匹配字母字符串：<code>[a-z]{3,6}</code> # 区间3至6：python java php【逗号后无空格】</li><li>思考：为什么匹配到3个的时候不会直接返回</li></ul></li><li>10-6：贪婪与非贪婪<ul><li>贪婪：尽可能匹配更多</li><li>Python倾向于贪婪匹配</li><li>非贪婪模式：<code>[a-z]{3,6}?</code> # 加<code>?</code>问号：pyt，hon，jav，php</li></ul></li><li>10-7：匹配0,1,无限多次<ul><li><code>*</code>：匹配0次或无限多次</li><li><code>a = &#39;python0python1pythonn2&#39;</code></li><li><code>r = re.findall(&#39;python*&#39;, a)</code> # 星号，[‘python’, ‘python’, ‘pythonn’]</li><li><code>+</code>：匹配1次或无限多次</li><li><code>r = re.findall(&#39;python+&#39;, a)</code> # 加号，[‘python’, ‘python’, ‘pythonn’]</li><li><code>?</code>：匹配0次或1次（去重）</li><li><code>r = re.findall(&#39;python?&#39;, a)</code> # 问号，[‘python’, ‘python’, ‘python’]</li><li><code>python{1,2}</code>贪婪模式pythonn，非贪婪模式python</li></ul></li><li>10-8：边界匹配符<ul><li>前<code>^</code>后<code>$</code>：边界匹配符</li><li>QQ号长度需满足4到8位：</li><li>大于8位仍满足：r = re.findall(‘\d{4,8}’, qq)</li><li>正确：<code>^\d{4,8}$</code> # 边界匹配</li></ul></li><li>10-9：组<ul><li><code>{}</code>：组（表示且关系，[]表示或）</li><li><code>a = &#39;PythonPythonPythonPython&#39;</code></li><li>判断字符串是否包含100个Python单词：</li><li><code>r = re.findall(&#39;(Python){100}&#39;, a)</code></li></ul></li><li>10-10：匹配模式参数<ul><li><code>re.I</code>：忽略大小写</li><li><code>r = re.findall(&#39;c&#39;, a, re.I)</code></li><li><code>re.S</code>：使得<code>.</code>能够匹配换行符\n</li><li>同时支持大小写和.号：<code>re.findall(&#39;c#.{1}&#39;, a, re.I | re.S)</code></li></ul></li><li>10-11：re.sub正则替换<ul><li><code>re.sub</code>：查找后的替换</li><li><code>r = re.sub(&#39;C#&#39;, &#39;go&#39;, a)</code> # 将C#替换成go</li><li>无限制替换，第四个参数赋值为0：<code>re.sub(&#39;C#&#39;, &#39;go&#39;, a, 0)</code></li><li>python内置：<code>a = a.replace(&#39;C#&#39;, &#39;go&#39;)</code></li><li>强大的功能：第二个参数可是函数</li><li><code>def convert(value): ... print(value)</code> # 返回match对象，span(6,8)：C#前面有6个，其占7,8位</li><li><code>r = re.sub(&#39;C#&#39;, convert, a, 1)</code></li></ul></li><li>10-12：把函数作为参数传递<ul><li>大于6变9，小于6变0：</li><li><code>def convert(value): ... matched = value.group() ... if int(matched) &gt;= 6: ... return &#39;9&#39; ... else: ... return &#39;0&#39;</code></li><li><code>r = re.sub(&#39;\d&#39;, convert, a)</code></li><li>软件设计：convert交付给其他工程师编写</li></ul></li><li>10-13：search与match函数<ul><li><code>re.match(&#39;\d&#39;,a)</code> # ==&gt; None</li><li>match从首字母开始</li><li><code>re.search(&#39;\d&#39;,a)</code> # ==&gt; span(1,2)</li><li>search搜索直到满足，然后返回结果</li></ul></li><li>10-14：group分组<ul><li><code>s = &#39;life is short, I use python&#39;</code></li><li>提取life和python之间的字符串：</li><li><code>r = re.search(&#39;life.*python&#39;, s)</code> <code>print(r.group())</code># 返回包含首尾</li><li>爬虫获取标签中间的内容：group</li><li><code>r = re.search(&#39;life(.*)python&#39;, s)</code> <code>print(group(1))</code> # ==&gt; is short, I use</li><li>使用findall：<code>r = re.findall(&#39;life(.*)python&#39;, s)</code> <code>print(r)</code></li><li>多个分组：<code>s = &#39;life is short, I use python, I love python&#39;</code></li><li><code>r = re.search(&#39;life(.*)python(.*)python&#39;, s)</code> <code>print(r.group(0,1,2))</code> <code>print(r.groups())</code></li></ul></li><li>10-16：理解JSON<ul><li>JSON（Javascript Object Notation）：是一种轻量级的数据交换格式（对比XML）</li><li>强调：JSON是<strong>数据格式</strong>，字符串是JSON的表现形式</li><li>JSON字符串：符合JSON格式的字符串</li><li>JSON优势：易于阅读、易于解析、网络传输效率高、跨语言交换数据</li></ul></li><li>10-17：反序列化<ul><li>JSON字符串（双引号）：<code>json_str = &#39;{&quot;name&quot;:&quot;louis&quot;, &quot;age&quot;:18}&#39;</code></li><li>JSON数组（中括号）：<code>json_arr = &#39;[{&quot;name&quot;:&quot;louis&quot;, &quot;age&quot;:18},{&quot;name&quot;:&quot;louis&quot;, &quot;age&quot;:18}]&#39;</code></li><li>反序列化：字符串到某一数据类型</li><li><code>student = json.loads(json_str)</code></li></ul></li><li>10-18：序列化<ul><li><code>students = [ {&#39;name&#39;:&#39;louis&#39;, &#39;age&#39;:23 }, { }]</code></li><li><code>json_str = json.dumps(students)</code></li><li>NoSQL数据库适合存储对象</li></ul></li><li>10-19：JSON、JSON对象、JSON字符串<ul><li>跳出语言限制（JSON不只是Javascript方面的，可以看成平级）</li><li>JSON对象：python中没有，Javascript中有</li><li>理解：JSON中间数据类型，有自己的数据类型</li></ul></li></ul><h3 id="11：Python的高级语法与用法"><a href="#11：Python的高级语法与用法" class="headerlink" title="11：Python的高级语法与用法"></a>11：Python的高级语法与用法</h3><ul><li><p>11-1：枚举其实是一个类</p><ul><li><code>from enum import Enum</code></li><li><code>class VIP(Enum): ... YELLOW= 1 ... GREEN= 2</code> # 枚举：全大写</li><li><code>print(VIP.YELLOW)</code> # ==&gt; VIP.YELLOW</li></ul></li><li><p>11-2：枚举和普通类的区别</p><ul><li>字典和普通类：可变、没有防止相同值的功能</li></ul></li><li><p>11-3：枚举类型、枚举名称、枚举值</p><ul><li>获取枚举值：<code>VIP.GREEN.value</code></li><li>枚举名称：<code>VIP.GREEN.name</code> </li><li>枚举类型：<code>VIP.GREEN</code> <code>VIP[&#39;GREEN&#39;]</code></li><li><code>for v in VIP: ... print(v)</code> # VIP.YELLOW VIP.GREEN</li></ul></li><li><p>11-4：枚举的比较运算</p><ul><li>可做等值比较，不能做大小比较</li><li>身份比较 is</li></ul></li><li><p>11-5：枚举注意事项</p><ul><li>枚举的值一般不相等</li><li>遍历出别名：<code>for v in VIP.__members__: ... print(v)</code></li></ul></li><li><p>11-6：枚举转换</p><ul><li>数据库中0,1,2,3的值转枚举类型</li><li><code>VIP(0)</code> <code>VIP(1)</code> <code>VIP(2)</code> </li></ul></li><li><p>11-7：枚举小结</p><ul><li><code>from enum import IntEnum</code></li><li><code>class VIP(IntEnum)</code> # 限制枚举为整型</li><li><code>from enum import unique</code></li><li><code>@unique</code> # 限制值必须不同</li><li>枚举类型不能实例化（23种设计模式：单例</li></ul></li><li><p>11-8：进阶内容</p><ul><li>基础：业务逻辑开发者，不考虑太多封装性</li><li>进阶：包、类库开发者</li></ul></li><li><p>11-9：一切皆对象</p><ul><li>Python中函数也是对象    </li></ul></li><li><p>11-10：什么是闭包</p><ul><li>不能在外部调用curve()函数</li><li><code>f = curve_pre()</code></li><li><code>a = 10</code> <code>f(2)</code> # ==&gt; 100 不受外部变量影响</li><li>闭包 =  函数 + 环境变量（保存在f.<strong>closure</strong>）</li><li>取出环境变量：<code>f.__closure__[0].cell_contents</code></li></ul></li><li><p>11-12：闭包的经典误区</p><ul><li><p><code>def f1(): ... a=10 ... def f2(): ...... a = 20 ... print(a) ... print(a) # 与f2同级 ... f2() ... print(a) ... f1()</code> # ==&gt; 10 20 10</p></li><li><p>判断是不是闭包：<code>print(f.__closure__)</code></p></li><li><p>不是闭包： </p><ul><li>是闭包：</li></ul></li></ul></li></ul><ul><li><p>11-13：出个题，用闭包解决</p><ul><li>题目：旅行者； x走一步加1；返回总共走了多少步</li><li>关键：每次走需要保存上一步的值</li></ul></li><li><p>11-14：先用非闭包解决</p><ul><li><p>error：出现在等号左边时就是局部变量了</p></li><li><p>更改：增加<code>global</code></p></li></ul><ul><li>11-15：再用闭包解决<ul><li><code>nonlocal</code> 非本地局部变量</li><li>非闭包问题：全局变量容易被修改</li><li>factory：工厂语言</li><li></li></ul></li><li>11-16：小谈函数式编程<ul><li>保存变量，除了闭包，可以使用OOP中的类变量<h3 id="12：函数式编程"><a href="#12：函数式编程" class="headerlink" title="12：函数式编程"></a>12：函数式编程</h3></li></ul></li></ul></li><li><p>12-1：lambda表达式</p><ul><li>匿名函数（表达式）：<code>f = lambda x,y: x+y</code></li><li><code>f(1,2)</code> # ==&gt; 3</li></ul></li><li><p>12-2：三元表达式</p><ul><li>取x，y较大值：</li><li><code>r = x if x &gt; y else y</code></li></ul></li><li><p>12-3：map</p><ul><li><code>def fun(x): ... return x*x</code></li><li><code>r = map(fun, li)</code> # 第一个参数为函数</li></ul></li><li><p>12-4：map与lambda</p><ul><li>上面代码修改：</li><li><code>r = map(lambda x: x*x, li)</code></li><li>多个参数：（map提示：<code>*iter</code><strong>可变参数</strong>）</li><li><code>r = map(lambda x,y: x*x+y, li_x, li_y)</code></li></ul></li><li><p>12-5：reduce</p><ul><li><code>from functools import reduce</code></li><li><code>r = reduce(lambda x,y: x + y, li_x)</code> # 没有传入y</li><li>与map区别：reduce连续计算，连续调用lambda（即一次传入两个计算，前两个计算结果作为x继续传入）</li><li>问题：旅行者修改，经纬度(x, y)</li><li>可以使用reduce计算（连续计算）</li><li>直观观察：<code>li = [&#39;1&#39;,...&#39;5&#39;]``r = reduce(lambda x,y: x + y, li_x, &#39;aaa&#39;)</code></li><li>google大数据计算框架map/reduce借鉴函数式编程思想</li></ul></li><li><p>12-6：filter</p><ul><li>剔除list中的0值：</li><li><code>r = filter(lambda x: True if x==1 else False, li)</code> <code>print(list(r))</code></li><li>特点：返回值需要表示真/假，0/1也行</li><li>等同于<code>r = filter(lambda x: x, li)</code></li><li>过滤小写保留大写：</li><li><code>r = filter()</code></li></ul></li><li><p>12-7：命令式编程vs函数式编程</p><ul><li>习惯于命令式编程，结合函数式编程（lisp语言）</li><li>python本质上并不是函数式编程</li></ul></li><li><p>12-8：装饰器（一）</p><ul><li>地位：装饰器框架中用到最多</li><li>类似：C#的特性，Java的注解</li><li>举例：打印时间的函数</li><li><code>import time</code></li><li><code>def f1(): ... print(time.time())</code> # unix 时间戳</li><li>问题：如果有100个函数需要打印时间</li><li>开闭原则：对修改是封闭的，对扩展是开放的</li><li>修改1（缺点：定义的函数没有与原函数想关联）</li></ul></li><li><p>12-9： 装饰器（二）</p><ul><li>使用装饰器修改：</li></ul></li><li><p>12-10： 装饰器（三）</p><ul><li><p><code>@</code>：语法糖</p></li><li><p>作用：没有改变原来调用方法（定义复杂，调用不能复杂）</p><ul><li>装饰器体现<code>AOP编程思想</code></li></ul></li></ul></li><li><p>12-11：装饰器（四）</p><ul><li>通用方法，加入可变参数</li></ul><ul><li>12-12：装饰器（五）<ul><li>如果调用的函数有关键字可变参数<code>**kw**</code></li><li>小技巧：支持各种参数的列表<code>(*args, **kw)</code></li><li>修改：</li></ul></li></ul></li><li><p>12-13：装饰器（六）</p><ul><li>flask的装饰器：</li><li><code>@api.route(&#39;/get&#39;, methods=[&#39;GET&#39;])</code></li><li><code>@api.route(&#39;/psw&#39;, methods=[&#39;GET&#39;])</code> </li></ul></li></ul><h3 id="13：实战-爬虫"><a href="#13：实战-爬虫" class="headerlink" title="13：实战-爬虫"></a>13：实战-爬虫</h3><ul><li><p>13-1：分析抓取目的确定抓取页面</p><ul><li>目的：爬取熊猫TV主播人气排行</li><li>数据：主播 + 观看人数</li></ul></li><li><p>13-2：整理爬虫常规思路</p><ul><li>查看html：所需要的标签中的数据</li><li>爬虫：搜索引擎、今日头条</li><li>获取数据：正则表达式处理html标签</li><li>代码注释：</li><li>前期准备：</li><li>1、明确目的</li><li>2、找到数据对应的网页</li><li>3、分析网页的结构找到数据所在的标签位置</li><li>爬取数据：</li><li>4、模拟HTTP请求，向服务器发送该请求，获取到服务器返回的html</li><li>5、使用正则表达式提取所需数据（主播名称 + 观看人数）</li></ul></li><li><p>13-3：VSCode中调试代码    </p><ul><li><p><code>from urllib import request</code> </p></li><li><p><code>class Spider()</code> <code>spider = Spider()</code> <code>spider.go()</code> </p></li><li><p>不推荐使用print查看变量</p></li><li><p>推荐：断点调试</p></li><li><p>思想：你可以什么都不会，但你必须得会断点调试（70%的问题都可以通过断点调试解决）</p></li><li><p>VSCode断点调试：</p></li><li><p>1、加断点（小红点）</p></li><li><p>2、<code>F5</code>键：调试运行</p></li><li><p>3、<code>F10</code>键：单步运行</p></li><li><p>4、<code>F5</code>键：继续，即跳到下一个断点</p></li><li><p>5、<code>F11</code>键：进入函数</p></li></ul></li><li><p>13-4：HTML结构分析基本原则</p><ul><li><p><code>htmls = str()</code> # 解决获取到的html是数字的问题</p></li><li><p><code>def __analysis()</code></p></li><li><p>寻找标识符（标签）</p></li><li><p>两个原则：</p></li><li><p>1、尽量选取具有唯一标识的标签</p></li><li><p>2、尽量提取接近所需数据的标签</p></li></ul></li><li><p>13-5：数据提取层级及原则三</p><ul><li>第三个原则：</li><li>3、尽量选取可以闭合的标签</li><li>选择<code>&lt;div class=&#39;video-info&#39;&gt;&lt;/div&gt;</code>标签：包含video-nickname和video-number</li></ul></li></ul><ul><li>13-6：正则分析HTML<ul><li><code>root_pattern = &#39;&lt;div class=&quot;video-info&quot;&gt;([\s\S])*?&lt;/div&gt;&#39;</code></li><li><code>import re</code></li><li><code>root_html = re.findall()</code></li></ul></li></ul><pre><code>- 正则表达式：非贪婪匹配- error： htmls = None（原因，`__fetch_content 需要 return htmls`）- error：`\s`反斜杆不是/s！！！</code></pre><ul><li>13-7：正则分析获取名字和人数<ul><li>主播姓名：<code>name_pattern = &#39;&lt;/i&gt;([\s\S]*?)&lt;/span&gt;&#39;</code></li><li>观看人数：<code>number_pattern = &#39;&lt;span class=&quot;video-number&quot;&gt;([\s\S]*?)&lt;/span&gt;&#39;</code></li></ul></li></ul><ul><li><p>13-8：数据精炼refine</p><ul><li><p><code>define __refine():</code></p></li><li><p>error：NoneType in map(l,anchors) （<code>__analysis 需要 return anchors</code>）</p></li></ul></li><li><p>13-9：sorted排序</p><ul><li><code>define __sort():</code></li><li><code>define __show():</code></li><li><code>define __sort_seed():</code></li></ul></li></ul><pre><code>- **正则表达式**处理观看人数排序（9人，8000人，1.2万人）</code></pre><ul><li><p>13-10：案例总结</p><ul><li><p>VSCode快速查找：<code>ctrl + shift + o</code> # @…</p></li><li><p>建议数据库存储方法</p></li><li><p>代码规范：主方法（<code>go()</code>函数）里面的函数是平级的，思路清晰</p></li><li><p>注释规范：注释写在里面</p></li><li><p><code>&#39;&#39;&#39;</code>：模块，类，方法</p></li><li><p><code>#</code>：写在代码上面，上一行留空行</p></li><li><p>善用空格增加代码块的概念</p></li><li><p>小技巧：更改熊猫url最后的一个参数</p></li><li><p>代码问题：代码复用性，业务更改时（如，不是熊猫TV）这个代码就用不了了</p></li><li><p>爬虫框架：BeautifulSoup，Scrapy（框架能不用就不用）</p></li><li><p>爬虫难点：爬虫 + 反爬虫 + 反反爬虫</p></li><li><p>遇到问题：IP被封，使用代理IP解决</p></li></ul></li></ul><h3 id="14：Pythonic与Python杂记"><a href="#14：Pythonic与Python杂记" class="headerlink" title="14：Pythonic与Python杂记"></a>14：Pythonic与Python杂记</h3><ul><li><p>14-2：用字典映射代替switch case语句</p></li><li><p>14-4：字典的列表推导式</p><ul><li>列表存储：<code>b = [key for key,value in students.items()]</code></li><li>字典存储：<code>dic = {value:key for key,value in students.items()}</code></li></ul></li><li><p>14-5：iterator与generator</p><ul><li>元组的列表推导式即生成器：<br><code>t = (i for i in range(100))</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构演变过程-系统设计</title>
      <link href="2020/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>2020/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="早期-amp-单体架构"><a href="#早期-amp-单体架构" class="headerlink" title="早期 &amp; 单体架构"></a>早期 &amp; 单体架构</h2><ul><li><p>Web 1.0：简单的静态页面，用户与浏览器几乎没有交互，网页只是单纯的展示功能<br><img src="/images/architecture/revolution/1.png" alt=""></p></li><li><p>Web 2.0：用户与服务器之间开始存在双向交互，并可以持久化到数据库中进行保存<br><img src="/images/architecture/revolution/2.png" alt=""></p></li><li><p>传统MVC模式：一个服务器就包括了数据库，应用，文件服务器<br><img src="/images/architecture/revolution/3.png" alt=""></p></li><li><p>服务分离的架构：独立数据服务器、文件服务器<br><img src="/images/architecture/revolution/4.png" alt=""></p></li><li><p>缓存层减少数据库压力：用户访问量的上升造成的最明显的影响是查询速度的下降，是因为数据库的查询压力过大<br><img src="/images/architecture/revolution/5.png" alt=""></p></li></ul><h2 id="集群-amp-分布式架构"><a href="#集群-amp-分布式架构" class="headerlink" title="集群 &amp; 分布式架构"></a>集群 &amp; 分布式架构</h2><ul><li><p>集群、负载均衡：单体架构最大的弊端就是当服务挂掉之后，服务无法自己修复，用户是无法访问服务的<br><img src="/images/architecture/revolution/6.png" alt=""></p></li><li><p>数据库读写分离：数据库操作中百分之80都是查询操作，剩下的就是写操作，这时候可以使用读写分离的方式来提升架构的性能。主数据库只用来写入，从数据库只用来读取，一定时间内进行主从复制<br><img src="/images/architecture/revolution/7.png" alt=""></p></li><li><p>数据库集群、分库分表：重点是分布式主键，需要保证在数据库集群中的每一条数据主键唯一<br><img src="/images/architecture/revolution/8.png" alt=""></p></li><li><p>分布式搜索引擎：把模糊搜索放在数据库上会有很大的压力，这时候就可以用到搜索引擎来处理模糊搜索<br><img src="/images/architecture/revolution/9.png" alt=""></p></li><li><p>拆分服务、微服务：优点就是业务分离，负载降低，同时开发人员或开发团队可以只专注于一个模块的开发，但是模块的拆分给测试和运维带来了挑战，因为代码变得更加复杂，必须考虑分布式事务<br><img src="/images/architecture/revolution/10.png" alt=""></p></li><li><p>消息队列与性能调优：JVM调优、Tomcat调优、MySQL调优、Linux性能调优、架构调优<br><img src="/images/architecture/revolution/11.png" alt=""></p></li></ul><h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p><img src="/images/architecture/revolution/0.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构演进 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机</title>
      <link href="2020/02/02/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>2020/02/02/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《深入理解Java虚拟机》</p></blockquote><h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><ul><li>Java虚拟机由四部分组成：ClassLoader(类加载器)、Execution Engine(执行引擎)、Native Interface(本地接口)、Runtime Data Area(运行时数据区域)</li><li>运行时数据区域：JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域<br>  <img src="/images/java/jvm/1.png" alt=""></li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul><li>程序计数器（Program Counter Register）是一块较小的内存空间，记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><ul><li>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息</li><li>从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程</li><li>可以通过<code>-Xss</code>参数来指定每个线程的Java虚拟机栈内存大小，JDK1.4默认256K，JDK1.5+默认1M<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure></li><li>该区域可能抛出以下异常<ul><li>当线程请求的栈深度超过最大值，会抛出StackOverflowError异常</li><li>栈进行动态扩展时，如果无法申请到足够内存，会抛出OutOfMemoryError异常<br><img src="/images/java/jvm/2.png" alt=""></li></ul></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>本地方法栈：与虚拟机栈类似，区别是本地方法栈为本地方法服务</li><li>本地方法一般是使用其他语言编写的，并且被编译为基于本机硬件和操作系统的程序，对这些方法需特别处理<ul><li>JNI：Java本地接口（Java Native Interface）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地库，也可以被其他程序调用<br><img src="/images/java/jvm/3.png" alt=""></li></ul></li></ul><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><ul><li>Java堆：所有的对象都在堆中分配内存，是垃圾收集的主要区域（GC堆）</li><li>主要采用分代收集算法，其主要思想是针对不同类型的对象采取不同的垃圾回收算法<ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul></li><li>堆不需要连续内存，并且可以动态增加内存，增加失败会抛出OutOfMemoryError异常</li><li>可以通过<code>-Xms</code>和<code>-Xmx</code>参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个设置最大值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器（JIT编译器）编译后的代码等数据</li><li>和堆一样不需要连续的内存，并且可以动态扩展，扩展失败也会抛出OutOfMemoryError异常</li><li>对方法区的垃圾回收主要目标是：常量池的回收、对类的卸载，但是比较难实现</li><li>永久代<ul><li>HotSpot虚拟机把方法区当作永久代进行垃圾回收，但很难确定永久代的大小，因为有很多因素的影响，并且每次Full GC后永久代的大小都会改变，所以经常抛出OOM异常</li><li>为了更容易管理方法区，从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</li></ul></li><li>方法区是一个JVM规范，永久代与元空间都是方法区的实现方式。JDK1.8后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，堆存储静态变量和常量池</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul><li>运行时常量池：是方法区的一部分。Class文件中的常量池会在类加载后被放入运行时常量池</li><li>除了在编译期生成的常量，也允许动态生成，如String类的intern()方法</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul><li>JDK1.4中引入了NIO（New Input/Output）类，它可以使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作</li><li>好处：能在某些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据</li></ul><h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><ul><li>垃圾收集针对Java堆和方法区进行。程序计数器、虚拟机栈、本地方法栈属于线程私有的，只存在于线程的生命周期内，线程结束后就会消失，不需要进行垃圾回收</li></ul><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><ul><li>为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1，回收引用计数为0的对象</li><li>缺点：循环引用（引用计数器永远不为0）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环引用，无法回收</span></span><br><span class="line">        ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        </span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul><li>以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收</li><li>Java虚拟机使用该算法来判断对象是否可被回收</li><li>可作为GC Roots的对象<ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈JNI中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象<br><img src="/images/java/jvm/4.png" alt=""></li></ul></li></ul><h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><ul><li>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类（常量池的回收和对类的卸载）</li><li>废弃常量：与回收堆中的对象类似。如字符串”abc”进入常量池，却没有String对象引用，则被回收</li><li>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能</li><li>无用的类：需同时满足以下3个条件<ul><li>该类所有的实例都已经被回收，此时Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类的方法</li></ul></li></ul><h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><ul><li>类似C++的析构函数，用于关闭外部资源</li><li>当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救</li><li>自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>判断对象是否可被回收都与引用有关</li></ul><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><ul><li>强引用：被强引用关联的对象不会被回收，可以通过将对象设置为null来弱化引用，使其被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><ul><li>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; a = <span class="keyword">new</span> SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><ul><li>弱引用：被弱引用关联的对象一定会被回收，即只能存活到下一次垃圾回收发生之前<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; b = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><ul><li>虚引用：一个对象是否有虚引用，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li><li>目的：能在这个对象被回收前收到一个系统通知<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">PhantomReference ref = <span class="keyword">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><ul><li>标记-清除（Mark-Sweep），分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象，标记过程使用标记方法判定</li><li>回收对象就是把对象分块，连接到被称为“空间链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块</li><li>缺点<ul><li>效率问题：标记和清除过程效率不高</li><li>空间问题：会产生大量不连续的内存碎片，导致无法给大对象分配内存</li></ul></li></ul><h3 id="2-标记-整理算法"><a href="#2-标记-整理算法" class="headerlink" title="2. 标记-整理算法"></a>2. 标记-整理算法</h3><ul><li>标记-整理（Mark-Compact），让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存</li><li>优点：不会产生内存碎片</li><li>缺点：需要移动大量对象，处理效率比较低</li></ul><h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><ul><li>复制（Copying），将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后把使用过的内存空间进行清理</li><li>现代虚拟机用复制算法回收新生代，但不是划分为相等的两块，而是Eden:Survivor默认为8:1，每次只使用Eden和其中一块Survivor（From、To是变化的），回收时将Eden和From中还存活的对象复制到To区，然后清理Eden和From区</li><li>缺点：只使用了内存的一半，需要额外的空间进行分配担保。且对象存活率高的场景就要进行较多的复制，效率会变低，所以不适用于老年代<br>  <img src="/images/java/jvm/5.png" alt=""></li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><ul><li>分代收集（Generational Collection），现代虚拟机所采用，它根据对象存活周期的不同将内存划分为块，不同块采用不同的收集算法</li><li>新生代：使用复制算法</li><li>老年代：使用标记-清除算法，或标记-整理算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul><li>HotSpot虚拟机中的7个垃圾收集器，连线表示可以配合使用<ul><li>单线程与多线程：ParNew、Parallel Scavenge、Parallel Old是多线程的</li><li>串行与并行：垃圾收集器与用户程序是交替执行或同时执行，只有CMS和G1是并行的<br><img src="/images/java/jvm/6.png" alt=""></li></ul></li></ul><h3 id="1-Serial"><a href="#1-Serial" class="headerlink" title="1. Serial"></a>1. Serial</h3><ul><li>Serial的意思是串行，即以串行的方式执行，Serial是单线程的收集器，只会使用一个线程进行垃圾收集</li><li>Client下默认的新生代收集器，因为该场景下内存一般不会很大</li><li>优点：简单高效，在单CPU下，由于没有线程交互的开销，因此有最高的单线程收集效率</li></ul><h3 id="2-ParNew"><a href="#2-ParNew" class="headerlink" title="2. ParNew"></a>2. ParNew</h3><ul><li>ParNew是Serial收集器的多线程版本</li><li>Server下默认的新生代收集器，除了性能外，主要是因为除了Serial，只有ParNew能与CMS收集器配合使用</li></ul><h3 id="3-Parallel-Scavenge"><a href="#3-Parallel-Scavenge" class="headerlink" title="3. Parallel Scavenge"></a>3. Parallel Scavenge</h3><ul><li>Parallel Scavenge也是多线程收集器，其收集目标是吞吐量优先（适用于后台运行程序），不同于其他的目标是尽可能缩短垃圾收集时用户线程的停顿时间。缩短停顿时间是以牺牲吞吐量和新生代空间换取的：新生代空间变小，垃圾回收变频繁，导致吞吐量下降</li><li>系统吞吐量=运行用户程序时间/(运行用户程序时间+GC时间)</li><li>可以通过开关参数<code>-XX:+UseAdaptiveSizePolicy</code>打开GC自适应的调节策略（GC Ergonomics），就不用手动设置新生代大小、Eden和Survivor比例、晋升老年代对象年龄等参数</li></ul><h3 id="4-Serial-Old"><a href="#4-Serial-Old" class="headerlink" title="4. Serial Old"></a>4. Serial Old</h3><ul><li>Serial Old是Serial收集器的老年代版本，Client下的老年代收集器</li><li>如果用在Server场景下，有两大用途<ul><li>在JDK1.5及以前，与Parallel Scavenge配合使用</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul></li></ul><h3 id="5-Parallel-Old"><a href="#5-Parallel-Old" class="headerlink" title="5. Parallel Old"></a>5. Parallel Old</h3><ul><li>Parallel Old是Parallel Scavenge的老年代版本</li><li>在注重吞吐量和CPU资源敏感的场景，可以优先考虑Parallel Scavenge和Parallel Old收集器</li></ul><h3 id="6-CMS"><a href="#6-CMS" class="headerlink" title="6. CMS"></a>6. CMS</h3><ul><li>CMS（Concurrent Mark Sweep），基于标记-清除算法，是一种以获取最短回收停顿时间为目标，适用于服务端应用（重视服务的响应速度，希望系统停顿时间最短，有更好的用户体验）。使用CMS来收集老年代时，新生代的收集只能选Serial或ParNew<ul><li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿（Stop The World）</li><li>并发标记：进行GC Roots Tracing的过程，在整个回收过程中耗时最长，不需要停顿</li><li>重新标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需用停顿（Stop The World）</li><li>并发清除：不需要停顿</li></ul></li><li>优点：并发收集、低停顿</li><li>缺点<ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高</li><li>无法处理浮动垃圾，可能会出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC才被回收。由于浮动垃圾的存在，因此需要预留出一部分内存，此时CMS不能像其他收集器那样等待老年代快满了才回收。如果预留的内存不够存放，就会出下Concurrent Mode Failure，这时会触发Full GC，使用Serial old临时替换CMS，停顿时间变长</li><li>空间问题：标记-清除算法导致的空间碎片，会出现老年代空间剩余，但无法找到足够大的连续空间来分配当前对象，要提前触发一次Full GC</li></ul></li></ul><h3 id="7-G1"><a href="#7-G1" class="headerlink" title="7. G1"></a>7. G1</h3><ul><li>G1（Garbage First），是一款面向服务端应用的垃圾收集器，在多CPU和大内存场景下有很好的性能</li><li>G1可以直接对新生代和老年代一起回收，它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离</li><li>每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region，通过使用该Set在可达性分析时可以避免全堆扫描<ul><li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活的对象，耗时长，但可并行</li><li>最终标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，虚拟机将对象变化记录在Remembered Set Logs里面，并合并数据到Set中，需要停顿，但可并行</li><li>筛选回收：首先对Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可并行</li></ul></li><li>特点<ul><li>空间整合：整体是标记-整理算法，局部（两Region之间）是复制算法，不会有内存碎片</li><li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间内，消耗在GC上的时间不超过N毫秒<br><img src="/images/java/jvm/7.png" alt=""></li></ul></li></ul><h1 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul><li>Minor GC：回收新生代，新生代对象存活时间短，Minor GC执行频繁，速度也较快。Eden空间满时触发一次Minor GC</li><li>Full GC：回收新生代和老年代，老年代对象存活时间长，Full GC执行较少，速度较慢</li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul><li>大多数情况下，对象在新生代Eden区分配，当其空间不足时，发起Minor GC</li></ul><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><ul><li>大对象：指需要连续内存空间的对象，如很长的字符串或数组</li><li>经常出现大对象容易导致内存还有不少空间，就提前触发垃圾收集以获取足够的连续空间来分配给大对象</li><li><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在Eden和Survivor间大量内存复制</li></ul><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul><li>为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动至Survivor中，年龄增加1岁，增加到一定年龄则移动到老年代中</li><li><code>-XX:MaxTenuringThreshold</code>定义年龄的阈值</li></ul><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul><li>除了达到年龄阈值外，如果在Survivor中相同年龄的所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代</li></ul><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul><li>使用复制算法的Minor GC需要老年代的内存空间作担保</li><li>在Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，成立则Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行Minor GC，否则进行Full GC</li></ul><h2 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h2><h3 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1. 调用System.gc()"></a>1. 调用System.gc()</h3><ul><li>只是建议虚拟机执行Full GC，但不一定真正执行</li></ul><h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><ul><li>老年代不足：大对象、长期存活的对象进入老年代</li><li>可以通过<code>-Xmn</code>参数调大新生代的大小，让对象尽量在新生代被回收。还可以通过<code>-XX:MaxTenuringThreshold</code>调大晋升老年代的年龄，让对象在新生代存活久一点</li></ul><h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><ul><li>使用复制算法的Minor GC需要老年代的内存空间作担保，如果失败会进行Full GC</li></ul><h3 id="4-JDK1-7及以前的永久代空间不足"><a href="#4-JDK1-7及以前的永久代空间不足" class="headerlink" title="4. JDK1.7及以前的永久代空间不足"></a>4. JDK1.7及以前的永久代空间不足</h3><ul><li>当系统中要加载的类、反射的类和调用的方法较多时，永久代空间可能会不足，在未采用CMS时会执行Full GC，如果回收不了则抛出OOM异常</li></ul><h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><ul><li>执行CMS GC的同时有对象要放入老年代，而此时老年代空间不足（如浮动垃圾导致），会报Concurrent Mode Failure错误，并触发Full GC</li></ul><h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><ul><li>类是在运行期间第一次使用时动态加载的，而不是一次性全部加载，因为它会占用很多的内存</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>类的生命周期有7个阶段<ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）<br><img src="/images/java/jvm/8.png" alt=""></li></ul></li></ul><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><ul><li>类加载的5阶段：加载、验证、准备、解析、初始化</li></ul><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><ul><li>加载是类加载（Class Loading）过程的一个阶段，注意不要混淆</li><li>加载过程完成以下三件事<ul><li>通过类的完全限定名称获取定义该类的二进制字节流</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</li><li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li></ul></li><li>其中二进制字节流可以从以下方式中获取<ul><li>从ZIP包读取，成为JAR、EAR、WAR格式的基础</li><li>从网络中获取，最经典的应用是Applet</li><li>运行时计算生成，例如动态代理技术，java.lang.reflect.Proxy使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li><li>由其他文件生成，例如由JSP文件生成对应的Class类</li></ul></li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><ul><li>验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li></ul><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><ul><li>准备阶段为类变量分配内存并设置初始值，使用方法区的内存（类变量是被static修饰的变量）</li><li>不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中</li><li>类变量初始值一般为0，如以下变量初始化为0而不是123<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><ul><li>解析：将常量池的符号引用替换为直接引用的过程。为了支持Java的动态绑定，解析可在初始化阶段之后在开始<ul><li>符号引用：以一组符号来描述所引用的目标，如CONSTANT_Class_info</li><li>直接引用：可以是直接指向目标的指针、相对偏移量、一个能间接定位到目标的句柄</li></ul></li></ul><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><ul><li>初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段是虚拟机执行类构造器<code>&lt;client&gt;()</code>方法的过程。在准备阶段，类变量根据系统要求赋初值，而在初始化阶段，根据程序制定的主观计划去初始化类变量和其他资源</li><li><code>&lt;client&gt;()</code>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并的，编译器收集的顺序由语句在源文件中出现的顺序决定<ul><li>父类的<code>&lt;client&gt;()</code>方法先执行，故父类中定义的静态语句块先于子类。</li><li>接口中不可以使用静态语句块，但有类变量初始化的赋值操作，因此接口也会生成<code>&lt;client&gt;()</code>方法。但接口不需要先执行父接口的<code>&lt;client&gt;()</code>方法，只有当父接口中定义的变量被使用时才会初始化。同样，接口的实现类在初始化时也不会执行接口的<code>&lt;client&gt;()</code>方法</li><li>虚拟机会保证一个类的<code>&lt;client&gt;()</code>方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行该类的<code>&lt;client&gt;()</code></li><li>特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Initial</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                  <span class="comment">// 编译正常通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// Error：非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><ul><li>虚拟机没有强制约束何时加载，但以下五种情况必须对类进行初始化（加载、验证、准备在此之前开始）<ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化（场景：使用new关键字实例化对象时、读取或设置一个类的静态字段时、调用一个类的静态方法时）</li><li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li><li>当初始化一个类的时候，如果其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ul></li></ul><h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><ul><li>除以上五种主动引用外，所有引用类的方式都不会触发初始化，称为被动引用。常见例子有<ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发该类的初始化。该过程会对数组类进行初始化（数组类是由虚拟机自动生成、直接继承自Object的子类，包含数组的属性和方法）</li><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发定义常量类的初始化</li></ul></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>类加载器不仅限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</li><li>也就是说，两个类相等，需要类本身相等，还要使用同一个类加载器进行加载，因为每一个类加载器都拥有一个独立的类名称空间。这里的相等，包括类的Class对象的equals()、isAssignableFrom()、isInstance()方法的返回结果为true，也包括使用instanceof关键字做对象所属关系判定为true</li></ul><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ul><li>从Java虚拟机的角度，只有两种类加载器<ul><li>启动类加载器（Bootstrap ClassLoader）：使用C++实现，是虚拟机自身的一部分</li><li>所有其他类的加载器：使用Java实现，独立于虚拟机，继承自抽象类java.lang.ClassLoader</li></ul></li><li>从Java开发人员的角度，有以下三种加载器<ul><li>启动类加载器（Bootstrap ClassLoader）：负责将存放在<code>&lt;JRE_HOME&gt;\lib</code>目录中的，或被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可</li><li>扩展类加载器（Extension ClassLoader）：由ExtClassLoader实现，它负责将<code>&lt;JAVA_HOME&gt;\lib\ext</code>或者被java.ext.dir系统变量所指定路径中的类库加载到内存中，开发者可以直接使用扩展类加载器</li><li>应用程序类加载器（Application ClassLoader）：由AppClassLoader实现，由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径CLASSPATH上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下默认就是Application ClassLoader</li></ul></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul><li>双亲委派模型（Parents Delegation Model）：要求除了顶层的启动类加载器外，其他的类加载器都要有自己的父类加载器。父子关系一般通过组合关系实现，而不是继承<br>  <img src="/images/java/jvm/9.png" alt=""></li></ul><h3 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h3><ul><li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</li></ul><h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h3><ul><li>使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</li><li>例如，java.lang.Object放在rt.jar中，如果另写一个Object放到CLASSPATH中，程序编译通过。因为双亲委派模型，在rt.jar中的Object优先级更高，其使用的是启动类加载器，而CLASSPATH中的Object使用应用程序类加载器</li></ul><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><ul><li><code>loadClass()</code>方法运行过程：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出ClassNotFoundException，此时尝试自己加载<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义类加载器实现"><a href="#自定义类加载器实现" class="headerlink" title="自定义类加载器实现"></a>自定义类加载器实现</h3><ul><li>应用程序是由三种类加载器相互配合从而实现类加载，此外还可以自定义类加载器</li><li>例如，自定义类加载器FileSystemClassLoader，继承自ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class文件），然后读取该文件内容，最后通过defineClass()方法把字节码转换成Class类的实例。自定义类加载器不需要重写loadClass()方法，但需要重写findClass()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">        + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、Java虚拟机的其他知识"><a href="#五、Java虚拟机的其他知识" class="headerlink" title="五、Java虚拟机的其他知识"></a>五、Java虚拟机的其他知识</h1><h2 id="JVM组成结构"><a href="#JVM组成结构" class="headerlink" title="JVM组成结构"></a>JVM组成结构</h2><ul><li>JVM基本结构，有别于JVM内存结构（也有别于JVM内存模型）<ul><li>ClassLoader(类加载器)：根据特定格式，加载class文件到内存</li><li>Execution Engine(执行引擎)：对命令进行解析</li><li>Native Interface(本地接口)：融合不同语言的原生库为Java所用</li><li>Runtime Data Area(运行时数据区域)：JVM内存结构</li></ul></li></ul><h2 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h2><h3 id="1-JDK的命令行工具"><a href="#1-JDK的命令行工具" class="headerlink" title="1. JDK的命令行工具"></a>1. JDK的命令行工具</h3><ul><li><code>jps</code>: 虚拟机进程状态工具，显示指定系统内所有的HotSpot虚拟机进程</li><li><code>jstat</code>: 虚拟机统计信息监视工具，用于收集HotSpot虚拟机各方面的允许数据</li><li><code>jinfo</code>: Java配置信息工具，显示虚拟机配置信息</li><li><code>jmap</code>: Java内存映像工具，生成虚拟机的内存转储快照（heapdump文件）</li><li><code>jhat</code>: 虚拟机堆转储快照分析工具，用于分析heapdump文件</li><li><code>jstack</code>: Java堆栈跟踪工具，显示虚拟机的线程快照</li></ul><h3 id="2-JDK的可视化工具"><a href="#2-JDK的可视化工具" class="headerlink" title="2. JDK的可视化工具"></a>2. JDK的可视化工具</h3><ul><li>JConsole: Java监视与管理控制台</li><li>Visual VM: 多合一故障处理工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer-分类汇总</title>
      <link href="2020/01/11/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer-%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/"/>
      <url>2020/01/11/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer-%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>数据结构<ul><li><a href="#栈">栈</a></li><li><a href="#队列">队列</a></li><li><a href="#堆">堆</a></li><li><a href="#哈希">哈希</a></li><li><a href="#链表">链表</a></li><li><a href="#树">树</a></li></ul></li><li>算法思想<ul><li><a href="#二分查找">二分查找</a></li><li><a href="#排序">排序</a></li><li><a href="#双指针">双指针</a></li><li><a href="#滑动窗口">滑动窗口</a></li><li><a href="#递归与迭代">递归与迭代</a></li><li><a href="#动态规划">动态规划</a></li><li><a href="#回溯法">回溯法</a></li><li><a href="#数学">数学</a></li><li><a href="#其他">其他</a></li></ul></li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6" target="_blank" rel="noopener">9-用两个栈来实现队列</a>：<a href="#9-用两个栈来实现队列">9题解</a></li><li><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49" target="_blank" rel="noopener">30-包含min函数的栈</a>：<a href="#30-包含min函数的栈">30题解</a></li><li><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">31-栈的压入、弹出序列</a>：<a href="#31-栈的压入、弹出序列">31题解</a></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701" target="_blank" rel="noopener">32.1-从上往下打印二叉树</a>：<a href="#32.1-从上往下打印二叉树">32.1题解</a></li><li><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288" target="_blank" rel="noopener">32.2-把二叉树打印成多行</a>：<a href="#32.2-把二叉树打印成多行">32.2题解</a></li><li><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0" target="_blank" rel="noopener">32.3-按之字形顺序打印二叉树</a>：<a href="#32.3-按之字形顺序打印二叉树">32.3题解</a></li><li><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720" target="_blank" rel="noopener">41.2-字符流中第一个不重复的字符</a>：<a href="#41.2-字符流中第一个不重复的字符">41.2题解</a></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf" target="_blank" rel="noopener">40-最小的K个数</a>：<a href="#40-最小的K个数">40题解</a></li><li><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1" target="_blank" rel="noopener">41.1-数据流中的中位数</a>：<a href="#41.1-数据流中的中位数">41.1题解</a></li><li><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788" target="_blank" rel="noopener">59-滑动窗口的最大值</a>：<a href="#59-滑动窗口的最大值">59题解</a></li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul><li><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8" target="_blank" rel="noopener">3-数组中重复的数字</a>：<a href="#3-数组中重复的数字">3题解</a></li><li><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c" target="_blank" rel="noopener">50-第一个只出现一次的字符</a>：<a href="#50-第一个只出现一次的字符">50题解</a></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035" target="_blank" rel="noopener">6-从尾到头打印链表</a>：<a href="#6-从尾到头打印链表">6题解</a></li><li>18.1-在O(1)时间内删除链表节点：<a href="#18.1-在O(1)时间内删除链表节点">18.1题解</a></li><li><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef" target="_blank" rel="noopener">18.2-删除链表中重复的节点</a>：<a href="#18.2-删除链表的节点">18.2题解</a></li><li><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a" target="_blank" rel="noopener">22-链表中倒数第k个结点</a>：<a href="#22-链表中倒数第k个结点">22题解</a></li><li><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4" target="_blank" rel="noopener">23-链表中环的入口结点</a> ：<a href="#23-链表中环的入口结点">23题解</a></li><li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca" target="_blank" rel="noopener">24-反转链表</a>：<a href="#24-反转链表">24题解</a></li><li><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337" target="_blank" rel="noopener">25-合并两个排序的链表</a>：<a href="#25-合并两个排序的链表">25题解</a></li><li><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba" target="_blank" rel="noopener">35-复杂链表的复制</a>：<a href="#35-复杂链表的复制">35题解</a></li><li><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46" target="_blank" rel="noopener">52-两个链表的第一个公共节点</a>：<a href="#52-两个链表的第一个公共节点">52题解</a></li><li><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a" target="_blank" rel="noopener">54-二叉查找树的第K个结点</a>：<a href="#54-二叉查找树的第K个结点">54题解</a></li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6" target="_blank" rel="noopener">7-重建二叉树</a>：<a href="#7-重建二叉树">7题解</a></li><li><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e" target="_blank" rel="noopener">8-二叉树的下一个节点</a>：<a href="#8-二叉树的下一个节点">8题解</a></li><li><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88" target="_blank" rel="noopener">26-树的子结构</a>：<a href="#26-树的子结构">26题解</a></li><li><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011" target="_blank" rel="noopener">27-二叉树的镜像</a>：<a href="#27-二叉树的镜像">27题解</a></li><li><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb" target="_blank" rel="noopener">28-对称的二叉树</a>：<a href="#28-对称的二叉树">28题解</a></li><li><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd" target="_blank" rel="noopener">33-二叉搜索树的后序遍历序列</a>：<a href="#33-二叉搜索树的后序遍历序列">33题解</a></li><li><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca" target="_blank" rel="noopener">34-二叉树中和为某一值的路径</a>：<a href="#34-二叉树中和为某一值的路径">34题解</a></li><li><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5" target="_blank" rel="noopener">36-二叉搜索树与双向链表</a>：<a href="#36-二叉搜索树与双向链表">36题解</a></li><li><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84" target="_blank" rel="noopener">37-序列化二叉树</a>：<a href="#37-序列化二叉树">37题解</a></li></ul><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba" target="_blank" rel="noopener">11-旋转数组的最小数字</a>：<a href="#11-旋转数组的最小数字">11题解</a></li><li><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2" target="_blank" rel="noopener">53-数字在排序数组中出现的次数</a>：<a href="#53-数字在排序数组中出现的次数">53题解</a></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5" target="_blank" rel="noopener">51-数组中的逆序对</a>：<a href="#51-数组中的逆序对">51题解</a></li><li><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993" target="_blank" rel="noopener">45-把数组排列成最小的数</a>：<a href="#45-把数组排列成最小的数">45题解</a></li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul><li><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e" target="_blank" rel="noopener">4-二维数组中的查找</a>：<a href="#4-二维数组中的查找">4题解</a></li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">48-最长不含重复字符的子字符串</a>：<a href="#48-最长不含重复字符的子字符串">48题解</a></li></ul><h3 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h3><ul><li><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423" target="_blank" rel="noopener">5-替换空格</a>：<a href="#5-替换空格">5题解</a></li><li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c" target="_blank" rel="noopener">19-正则表达式匹配</a>：<a href="#19-正则表达式匹配">19题解</a></li><li><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593" target="_blank" rel="noopener">21-调整数组顺序使奇数位于偶数前面</a>：<a href="#21-调整数组顺序使奇数位于偶数前面">21题解</a></li><li><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a" target="_blank" rel="noopener">29-顺时针打印矩阵</a>：<a href="#29-顺时针打印矩阵">29题解</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">10.1-斐波那契数列</a>：<a href="#10.1-斐波那契数列">10.1题解</a></li><li><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6" target="_blank" rel="noopener">10.2-矩形覆盖</a>：<a href="#10.2-矩形覆盖">10.2题解</a></li><li><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4" target="_blank" rel="noopener">10.3-跳台阶</a>：<a href="#10.3-跳台阶">10.3题解</a></li><li><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">10.4-变态跳台阶</a>：<a href="#10.4-变态跳台阶">10.4题解</a></li><li><a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8" target="_blank" rel="noopener">14-剪绳子</a>：<a href="#14-剪绳子">14题解</a></li><li><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">42-连续子数组的最大和</a>：<a href="#42-连续子数组的最大和">42题解</a></li><li>46-把数字翻译成字符串：<a href="#46-把数字翻译成字符串">46题解</a></li><li><a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab" target="_blank" rel="noopener">47-礼物的最大值</a>：<a href="#47-礼物的最大值">47题解</a></li><li><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b" target="_blank" rel="noopener">49-丑数</a>：<a href="#49-丑数">49题解</a></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><ul><li><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc" target="_blank" rel="noopener">12-矩阵中的路径</a>：<a href="#12-矩阵中的路径">12题解</a></li><li><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8" target="_blank" rel="noopener">13-机器人的运动范围</a>：<a href="#13-机器人的运动范围">13题解</a></li><li><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">38-字符串的排列</a>：<a href="#38-字符串的排列">38题解</a></li></ul><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00" target="_blank" rel="noopener">16-数值的整数次方</a>：<a href="#16-数值的整数次方">16题解</a></li><li><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6" target="_blank" rel="noopener">43-从1到n整数中1出现的次数</a>：<a href="#43-从1到n整数中1出现的次数">43题解</a></li><li>44-数字序列中的某一位数字：<a href="#44-数字序列中的某一位数字">44题解</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8" target="_blank" rel="noopener">15-二进制中1的个数</a>：<a href="#15-二进制中1的个数">15题解</a></li><li>17-打印从1到最大的n位数：<a href="#17-打印从1到最大的n位数">17题解</a></li><li><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2" target="_blank" rel="noopener">20-表示数值的字符串</a>：<a href="#20-表示数值的字符串">20题解</a></li><li><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163" target="_blank" rel="noopener">39-数组中出现次数超过一半的数字</a>：<a href="#39-数组中出现次数超过一半的数字">39题解</a></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="数据结构题解"><a href="#数据结构题解" class="headerlink" title="数据结构题解"></a>数据结构题解</h2><h3 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3-数组中重复的数字"></a>3-数组中重复的数字</h3><ul><li><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8</a></li><li>请找出数组中任意一个重复的数字</li><li>Input: {2,3,1,0,2,5,3}</li><li>Output: 2</li><li>思路1：Hash</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++) &#123;</span><br><span class="line">            freq[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(freq[numbers[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：把值为i的元素调到i的位置</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers, numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4-二维数组中的查找"></a>4-二维数组中的查找</h3><ul><li><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e" target="_blank" rel="noopener">https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e</a></li><li>判断二维数组中是否含有某一整数</li><li>Input: target=5, array=二维数组</li><li>Output: false</li><li>思路：双指针，比target大j–，小i++</li><li>复杂度：O(n+m)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array[<span class="number">0</span>].length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;array.length &amp;&amp; j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5-替换空格"></a>5-替换空格</h3><ul><li><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423" target="_blank" rel="noopener">https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423</a></li><li>替换字符串的空格为“%20”</li><li>思路：扫两遍，从前往后append空格数*2，接着从后往前替换</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从前往后遍历，append空格数*2</span></span><br><span class="line">        <span class="keyword">int</span> size1 = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=size1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后往前，替换</span></span><br><span class="line">        <span class="keyword">int</span> size2 = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size1&gt;=<span class="number">0</span> &amp;&amp; size1&lt;size2) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(size1--);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(size2--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(size2--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(size2--, <span class="string">'%'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                str.setCharAt(size2--, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路：调用自带replace函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    return str.toString().replace(&quot; &quot;, &quot;%20&quot;);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 6-从尾到头打印链表</span><br><span class="line">- https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035</span><br><span class="line">- 反向打印链表</span><br><span class="line">- 思路1：递归，list要放外面</span><br><span class="line">- 复杂度：O(n)、O(n)</span><br><span class="line">```java</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        if(listNode == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        printListFromTailToHead(listNode.next);</span><br><span class="line">        res.add(listNode.val);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：迭代</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路3：模拟栈，利用List的add(index, value)方法</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟栈，每次在第一个位置插入元素，取出来的就是最新的元素</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7-重建二叉树"></a>7-重建二叉树</h3><ul><li><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6</a></li><li>根据前序和中序遍历的结果，重建二叉树</li><li>Input: pre={1,2,4,7,3,5,6,8}, in={4,7,2,1,5,3,8,6}</li><li>Output: TreeNode</li><li>思路：递归，前序找根，中序划分左右子树</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || in.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 遍历in，在中序里找前序的根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// copyOfRange函数，左闭右开</span></span><br><span class="line">                <span class="keyword">int</span>[] leftPre = Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span>[] leftIn = Arrays.copyOfRange(in, <span class="number">0</span>, i);</span><br><span class="line">                root.left = reConstructBinaryTree(leftPre, leftIn);</span><br><span class="line">                <span class="comment">// i为中序的下标找到前序根，pre包括下标i，in不包括i</span></span><br><span class="line">                <span class="keyword">int</span>[] rightPre = Arrays.copyOfRange(pre, i+<span class="number">1</span>, pre.length);</span><br><span class="line">                <span class="keyword">int</span>[] rightIn = Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length);</span><br><span class="line">                root.right = reConstructBinaryTree(rightPre, rightIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8-二叉树的下一个节点"></a>8-二叉树的下一个节点</h3><ul><li><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e</a></li><li>找出二叉树中序遍历顺序的下一个结点并且返回（包含指向父节点的next指针）</li><li>思路：分三种情况，有右子树、无右子树且为左、无右子树且为右</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关键：next为指向父节点的指针</span></span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 有右子树：则下一个为右子树的最左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode pRight = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pRight.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pRight = pRight.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 无右子树，且该节点为父节点的左子树：则下一个为该节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.next!=<span class="keyword">null</span> &amp;&amp; pNode.next.left==pNode) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 无右子树，且该节点为父节点的右子树：则下一个为该节点的最父节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode pNext = pNode.next;</span><br><span class="line">            <span class="keyword">while</span>(pNext.next!=<span class="keyword">null</span> &amp;&amp; pNext.next.right==pNext) &#123;</span><br><span class="line">                pNext = pNext.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNext.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-用两个栈来实现队列"><a href="#9-用两个栈来实现队列" class="headerlink" title="9-用两个栈来实现队列"></a>9-用两个栈来实现队列</h3><ul><li><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6" target="_blank" rel="noopener">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6</a></li><li>用两个栈来实现队列的push和pop</li><li>思路：直接push，pop的时候把in的放入out中</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">       in.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.empty()) &#123;</span><br><span class="line">               out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="算法思想题解"><a href="#算法思想题解" class="headerlink" title="算法思想题解"></a>算法思想题解</h2><h3 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1-斐波那契数列"></a>10.1-斐波那契数列</h3><ul><li><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3</a></li><li>输出斐波那契数列的第n项（从0开始，第0项为0）</li><li>Input: 2</li><li>Output: 1</li><li>思路1：记忆化搜索</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getFib(n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[n] == -<span class="number">1</span>) &#123;</span><br><span class="line">            memo[n] = getFib(n-<span class="number">1</span>, memo) + getFib(n-<span class="number">2</span>, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 思路2：动态规划 */</span></span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            memo[i] = memo[i-<span class="number">1</span>] + memo[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-2-矩形覆盖"><a href="#10-2-矩形覆盖" class="headerlink" title="10.2-矩形覆盖"></a>10.2-矩形覆盖</h3><ul><li><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6" target="_blank" rel="noopener">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6</a></li><li>用n个2<em>1形状的小矩形覆盖一个2</em>n的大矩形，有几种方法</li><li>思路：dp，当n=1时只有一种，n=2时只有两种，递归函数f(n)=f(n-1)+f(n-2)</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=target; i++) &#123;</span><br><span class="line">            res = t1 + t2;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-3-跳台阶"><a href="#10-3-跳台阶" class="headerlink" title="10.3-跳台阶"></a>10.3-跳台阶</h3><ul><li><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4</a></li><li>可以跳一个台阶，也可以跳两个台阶，求n级台阶有几种跳法</li><li>思路：dp</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=target; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-变态跳台阶"><a href="#10-4-变态跳台阶" class="headerlink" title="10.4-变态跳台阶"></a>10.4-变态跳台阶</h3><ul><li><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387</a></li><li>可以跳1阶至n阶，求n级台阶有几种跳法</li><li>思路：dp，递归函数<code>f(n)=2*f(n-1)</code>，分析如下<ul><li><code>f(n-1)=f(n-2)+...+f(0)</code>：跳到n-1级，可以从n-2级到0级开始跳上去</li><li><code>f(n)=f(n-1)+f(n-2)+...+f(0)</code>：由上述式子得，<code>f(n)=2*f(n-1)</code></li></ul></li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// f(n) = 2*f(n-1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;target; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">2</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11-旋转数组的最小数字"></a>11-旋转数组的最小数字</h3><ul><li><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba</a></li><li>递增的数组会进行旋转，根据该特性找出其最小值</li><li>Input: {3,4,5,1,2}</li><li>Output: 1</li><li>思路：二分查找，三种情况，处于递增，处于递减，其他情况</li><li>复杂度：O(logn)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// mid初始为0</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt; array[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[l];</span><br><span class="line">            &#125;</span><br><span class="line">            mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1. 处于递增，改变l</span></span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt; array[mid]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 处于递减，改变r</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[r]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 其余情况，l++缩小范围</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12-矩阵中的路径"></a>12-矩阵中的路径</h3><ul><li><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc</a></li><li>在矩阵中搜索是否包含str的路径</li><li>Input: matrix={‘a’,’b’,’t’,’g’,’c’,’f’,’c’,’s’,’j’,’d’,’e’,’h’}, str={‘b’,’f’,’c’,’e’}</li><li>Output: true</li><li>思路：回溯法，递归树中搜索左上右下四个方向</li><li>复杂度：<code>O(m*n*m*n)、O(m*n)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">  <span class="comment">// 左上右下</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[][] d = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m, n;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">      m = rows;</span><br><span class="line">      n = cols;</span><br><span class="line">      visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(search(matrix, rows, cols, str, <span class="number">0</span>, i, j)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">int</span> startx, <span class="keyword">int</span> starty)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(index == str.length-<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> matrix[startx*cols+starty] == str[index];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(matrix[startx*cols+starty] == str[index]) &#123;</span><br><span class="line">          visited[startx*cols+starty] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 四个方向寻找</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> newx = startx + d[i][<span class="number">0</span>];</span><br><span class="line">              <span class="keyword">int</span> newy = starty + d[i][<span class="number">1</span>];</span><br><span class="line">              <span class="keyword">if</span>(inArea(newx, newy) &amp;&amp; !visited[newx*cols+newy]) &#123;</span><br><span class="line">                  <span class="keyword">if</span>(search(matrix, rows, cols, str, index+<span class="number">1</span>, newx, newy)) &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          visited[startx*cols+starty] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13-机器人的运动范围"></a>13-机器人的运动范围</h3><ul><li><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8</a></li><li>机器人不能进入行坐标和列坐标的数位之和大于k的格子，求总共能访问多少个</li><li>思路：回溯，递归遍历</li><li>复杂度：O(n<em>m)、O(n</em>m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    boolean[][] visited;</span><br><span class="line">    public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line">        visited = new boolean[rows][cols];</span><br><span class="line">        return getNumber(threshold, rows, cols, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getNumber(int threshold, int rows, int cols, int x, int y) &#123;</span><br><span class="line">        if(!inArea(threshold, rows, cols, x, y) || visited[x][y]) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = true;</span><br><span class="line">        return getNumber(threshold, rows, cols, x-1, y)</span><br><span class="line">                + getNumber(threshold, rows, cols, x+1, y)</span><br><span class="line">                + getNumber(threshold, rows, cols, x, y-1)</span><br><span class="line">                + getNumber(threshold, rows, cols, x, y+1)</span><br><span class="line">                + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean inArea(int threshold, int rows, int cols, int x, int y) &#123;</span><br><span class="line">        if(x&lt;0 || x&gt;=rows || y&lt;0 || y&gt;=cols || numSum(x)+numSum(y)&gt;threshold) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private int numSum(int x) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(x != 0) &#123;</span><br><span class="line">            res += x%10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14-剪绳子"></a>14-剪绳子</h3><ul><li><a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8" target="_blank" rel="noopener">https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8</a></li><li>求绳子分段的乘积最大值</li><li>Input: 8 </li><li>Output: 18（8=2+3+3, 18=2<em>3</em>3）</li><li>思路1：动态规划，$f(n)=max(f(j)*f(n-j))$</li><li>复杂度：O(n^2)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n&lt;=3，进一步划分</span></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// n&gt;3，不分的情况</span></span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        memo[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        memo[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 包括target要等于</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                res = Math.max(res, memo[j]*memo[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            memo[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：贪心，尽量减成3，当剩下长度为4剪成2*2</li><li>复杂度：O(1)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> threeTimes = target / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 剩下为4时，要剪成2*2</span></span><br><span class="line">        <span class="keyword">if</span>(target - threeTimes*<span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            threeTimes -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> twoTimes = (target - threeTimes*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, threeTimes) * Math.pow(<span class="number">2</span>, twoTimes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15-二进制中1的个数"></a>15-二进制中1的个数</h3><ul><li><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8</a></li><li>十进制转二进制，求1的个数</li><li>思路：1的个数就是该数与其减一按位与能进行多少次</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n-<span class="number">1</span>)&amp;n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16-数值的整数次方"></a>16-数值的整数次方</h3><ul><li><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00</a></li><li>实现Math.pow函数</li><li>思路：指数的正负数情况要区分，res或1/res</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = Math.abs(exponent);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;e; i++) &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent&gt;<span class="number">0</span> ? res : <span class="number">1</span>/res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17-打印从1到最大的n位数"></a>17-打印从1到最大的n位数</h3><ul><li>如题，输入3，打印1到999</li><li>思路：大数问题，直接for打印会出现整型溢出问题，改用字符串模拟</li><li>复杂度：O(n)、O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void Print1ToMaxOfNDigits(int n) &#123;</span><br><span class="line">    if(n &lt;= 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder num = new StringBuilder(n);</span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        num.append(&apos;0&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    while(increment(num)) &#123;</span><br><span class="line">        String res = num.toString().replaceFirst(&quot;^0*&quot;, &quot;&quot;);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean increment(StringBuilder str) &#123;</span><br><span class="line">    for(int i=str.length()-1; i&gt;=0; i--) &#123;</span><br><span class="line">        if(str.charAt(i)&gt;=&apos;0&apos; &amp;&amp; str.charAt(i)&lt;&apos;9&apos;) &#123;</span><br><span class="line">            str.setCharAt(i, (char) (str.charAt(i)+1));</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(str.charAt(i) == &apos;9&apos;) &#123;</span><br><span class="line">            str.setCharAt(i, &apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-1-在O-1-时间内删除链表节点"><a href="#18-1-在O-1-时间内删除链表节点" class="headerlink" title="18.1-在O(1)时间内删除链表节点"></a>18.1-在O(1)时间内删除链表节点</h3><ul><li>思路：修改链表的值</li><li>复杂度：O(1)、O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void deleteNode(ListNode node) &#123;</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.next == null) &#123;</span><br><span class="line">        node = null;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-2-删除链表中重复的结点"><a href="#18-2-删除链表中重复的结点" class="headerlink" title="18.2-删除链表中重复的结点"></a>18.2-删除链表中重复的结点</h3><ul><li><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef</a></li><li>排序的链表里删除重复的节点</li><li>思路：dummyHead</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = pHead;</span><br><span class="line">        ListNode pre = dummyHead;</span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                <span class="comment">// 一直搜索到不同为止</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.val==cur.next.val) &#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19-正则表达式匹配"></a>19-正则表达式匹配</h3><ul><li><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c" target="_blank" rel="noopener">https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c</a></li><li>实现一个函数用来匹配包含’.’和’*’的正则表达式</li><li>思路：递归</li><li>复杂度：O(n^2)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || pattern==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> s, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个都到尾，则成功</span></span><br><span class="line">        <span class="keyword">if</span>(s==str.length &amp;&amp; p==pattern.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pattern先到尾，则失败</span></span><br><span class="line">        <span class="keyword">if</span>(s!=str.length &amp;&amp; p==pattern.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pattern下一个是*</span></span><br><span class="line">        <span class="comment">// 时刻注意判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(p+<span class="number">1</span>&lt;pattern.length &amp;&amp; pattern[p+<span class="number">1</span>]==<span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配，则str后移1位或pattern后移2位</span></span><br><span class="line">            <span class="keyword">if</span>(s!=str.length &amp;&amp; (str[s]==pattern[p] || pattern[p]==<span class="string">'.'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern, s+<span class="number">1</span>, p)</span><br><span class="line">                        || matchCore(str, pattern, s, p+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不匹配，pattern后移2位，跳过*</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern, s, p+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pattern下一个不是*，且匹配，则str和pattern都后移1位</span></span><br><span class="line">        <span class="keyword">if</span>(s!=str.length &amp;&amp; (str[s]==pattern[p] || pattern[p]==<span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern, s+<span class="number">1</span>, p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20-表示数值的字符串"></a>20-表示数值的字符串</h3><ul><li><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2</a></li><li>判断字符串是否为数值</li><li>思路：正则表达式</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">"^[+-]?\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?$"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21-调整数组顺序使奇数位于偶数前面"></a>21-调整数组顺序使奇数位于偶数前面</h3><ul><li><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593" target="_blank" rel="noopener">https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593</a></li><li>重排序，奇数在前偶数在后，注意相对位置不能变</li><li>思路：游标，但要保持相对位置，所以要对子数组再排序</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(array[i])%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; k) &#123;</span><br><span class="line">                    swap(array, j, j-<span class="number">1</span>);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="22-链表中倒数第k个结点"><a href="#22-链表中倒数第k个结点" class="headerlink" title="22-链表中倒数第k个结点"></a>22-链表中倒数第k个结点</h3><ul><li><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a" target="_blank" rel="noopener">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a</a></li><li>返回倒数第k个节点</li><li>思路：快慢指针</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果k大于链表的长度</span></span><br><span class="line">            <span class="keyword">if</span>(q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23-链表中环的入口结点"></a>23-链表中环的入口结点</h3><ul><li><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4" target="_blank" rel="noopener">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4</a></li><li>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null</li><li>思路：快慢指针</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125; <span class="keyword">while</span>(fast != slow);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果存在环，fast从起点slow从相遇点开始，则会在入口处相遇</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24-反转链表"></a>24-反转链表</h3><ul><li><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca" target="_blank" rel="noopener">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca</a></li><li>反转链表，输出新的头结点</li><li>思路：递归</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25-合并两个排序的链表"></a>25-合并两个排序的链表</h3><ul><li><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337</a></li><li>合并两个单调递增的链表为一个，保持单调递增</li><li>思路1：递归</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val) &#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：迭代</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span> &amp;&amp; list2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26-树的子结构"></a>26-树的子结构</h3><ul><li><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88</a></li><li>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</li><li>思路：递归，两个递归方法</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1, root2) || </span><br><span class="line">            HasSubtree(root1.left, root2) ||</span><br><span class="line">            HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顺序不能变</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1.left, root2.left) &amp;&amp; </span><br><span class="line">            isSubtree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27-二叉树的镜像"></a>27-二叉树的镜像</h3><ul><li><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011" target="_blank" rel="noopener">https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011</a></li><li>操作给定的二叉树，将其变换为源二叉树的镜像</li><li>思路：递归</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(root);</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode t = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28-对称的二叉树"></a>28-对称的二叉树</h3><ul><li><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb</a></li><li>判断一颗二叉树是不是对称的</li><li>思路：递归</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(p.left, q.right) &amp;&amp; </span><br><span class="line">            isSymmetrical(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29-顺时针打印矩阵"></a>29-顺时针打印矩阵</h3><ul><li><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a</a></li><li>按顺时针螺旋状打印数组元素</li><li>思路：定义四个变量表示范围，上下左右边界</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义四个变量表示范围，上下左右边界</span></span><br><span class="line">        <span class="keyword">int</span> up=<span class="number">0</span>, down=matrix.length-<span class="number">1</span>, left=<span class="number">0</span>, right=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(up&lt;=down &amp;&amp; left&lt;=right) &#123;</span><br><span class="line">            <span class="comment">// 先向右记录</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class="line">                res.add(matrix[up][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再向下记录</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up+<span class="number">1</span>; i&lt;=down; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再向左记录</span></span><br><span class="line">            <span class="keyword">if</span>(up != down) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=right-<span class="number">1</span>; i&gt;=left; i--) &#123;</span><br><span class="line">                    res.add(matrix[down][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再向上记录（注意边界）</span></span><br><span class="line">            <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=down-<span class="number">1</span>; i&gt;up; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新边界</span></span><br><span class="line">            up++;down--;left++;right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30-包含min函数的栈"></a>30-包含min函数的栈</h3><ul><li><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49" target="_blank" rel="noopener">https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49</a></li><li>实现一个能够得到栈中所含最小元素的min函数，时间复杂度应为O(1)</li><li>思路：minStack只push最小值</li><li>复杂度：O(1)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        minStack.push(minStack.empty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31-栈的压入、弹出序列"></a>31-栈的压入、弹出序列</h3><ul><li><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106</a></li><li>输入两个序列，一个是压入序列，一个弹出序列，判断是否匹配</li><li>思路：用栈模拟</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length==<span class="number">0</span> || popA.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 序列的下标索引</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pushA.length; i++) &#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="comment">// 如果栈顶元素与popA的相同，则出栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[popIndex]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈为空，则说明全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1-从上往下打印二叉树"></a>32.1-从上往下打印二叉树</h3><ul><li><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701</a></li><li>从上往下，从左向右打印二叉树节点</li><li>思路：队列</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 当前队列的size就是该层的节点数</span></span><br><span class="line">            <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="32-2-把二叉树打印成多行"><a href="#32-2-把二叉树打印成多行" class="headerlink" title="32.2-把二叉树打印成多行"></a>32.2-把二叉树打印成多行</h3><ul><li><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288" target="_blank" rel="noopener">https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288</a></li><li>打印二叉树，按层打印</li><li>思路：队列</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 用List存每一层的节点</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 当前队列的size就是该层的节点数</span></span><br><span class="line">            <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非空判断，不然会添加空list</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="32-3-按之字形顺序打印二叉树"><a href="#32-3-按之字形顺序打印二叉树" class="headerlink" title="32.3-按之字形顺序打印二叉树"></a>32.3-按之字形顺序打印二叉树</h3><ul><li><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0" target="_blank" rel="noopener">https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0</a></li><li>先从左向右，再从右向左</li><li>思路：队列，设置布尔变量rev</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        <span class="comment">// 设置布尔变量表示逆序</span></span><br><span class="line">        <span class="keyword">boolean</span> reverse = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 用List存每一层的节点</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 当前队列的size就是该层的节点数</span></span><br><span class="line">            <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用Collections反转</span></span><br><span class="line">            <span class="keyword">if</span>(reverse == <span class="keyword">true</span>) &#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33-二叉搜索树的后序遍历序列"></a>33-二叉搜索树的后序遍历序列</h3><ul><li><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd" target="_blank" rel="noopener">https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd</a></li><li>判断数组是否为二叉搜索树后序遍历结果</li><li>思路：递归</li><li>复杂度：O(n^2)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> key = sequence[root];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="comment">// 找到左右子树的分界点</span></span><br><span class="line">        <span class="keyword">for</span>(cur=start; cur&lt;root; cur++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[cur] &gt; key) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树中判断是否有小于root的值，有返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cur; i&lt;root; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &lt; key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, start, cur-<span class="number">1</span>) &amp;&amp; </span><br><span class="line">            verify(sequence, cur, root-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34-二叉树中和为某一值的路径"></a>34-二叉树中和为某一值的路径</h3><ul><li><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca" target="_blank" rel="noopener">https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca</a></li><li>返回二叉树中和为某一值的所有路径</li><li>思路：回溯法，递归target-node.val</li><li>复杂度：O(n)、O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtracking(root, target, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.val == target) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用减去node值的方法替代求和</span></span><br><span class="line">        backtracking(node.left, target-node.val, res, path);</span><br><span class="line">        backtracking(node.right, target-node.val, res, path);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35-复杂链表的复制"></a>35-复杂链表的复制</h3><ul><li><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba</a></li><li>复制一个复杂的链表，不能用原来的引用</li><li>思路：迭代，分三步进行（插入新节点、建立random链接、拆分）</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 插入新节点</span></span><br><span class="line">        RandomListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 建立random链接</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode clone = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// random的下一个</span></span><br><span class="line">                clone.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分</span></span><br><span class="line">        cur = pHead;</span><br><span class="line">        RandomListNode cHead = pHead.next;</span><br><span class="line">        <span class="comment">// 要判断next是否为空</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36-二叉搜索树与双向链表"></a>36-二叉搜索树与双向链表</h3><ul><li><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5" target="_blank" rel="noopener">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5</a></li><li>将二叉搜索树改成双向链表</li><li>思路：中序遍历</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双向链表左边头结点、右边头结点</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode lHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode rHead = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最左的叶子节点作为链表第一个结点</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(rHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lHead = pRootOfTree;</span><br><span class="line">            rHead = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根节点插入链表右边，rHead向后移</span></span><br><span class="line">            rHead.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = rHead;</span><br><span class="line">            rHead = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入右叶子节点</span></span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="comment">// 返回左边头结点</span></span><br><span class="line">        <span class="keyword">return</span> lHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37-序列化二叉树"></a>37-序列化二叉树</h3><ul><li><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84" target="_blank" rel="noopener">https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84</a></li><li>序列化和反序列化二叉树，以#结束</li><li>思路：递归，序列化前序遍历，反序列化</li><li>复杂度：O(n)、O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    // 使用index设置树节点的val值，</span><br><span class="line">    int index = -1;</span><br><span class="line">    </span><br><span class="line">    String Serialize(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return &quot;#&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 前序遍历</span><br><span class="line">        return root.val+&quot; &quot;+Serialize(root.left)+&quot; &quot;+Serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode Deserialize(String str) &#123;</span><br><span class="line">        // 将序列化str按分隔符转为数组</span><br><span class="line">        String[] s = str.split(&quot; &quot;);</span><br><span class="line">        index++;</span><br><span class="line">        // 下标越界则返回空</span><br><span class="line">        if(index &gt; s.length) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 前序遍历递归，如果值为#返回空节点</span><br><span class="line">        TreeNode t = null;</span><br><span class="line">        if(!s[index].equals(&quot;#&quot;)) &#123;</span><br><span class="line">            t = new TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">            t.left = Deserialize(str);</span><br><span class="line">            t.right = Deserialize(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38-字符串的排列"></a>38-字符串的排列</h3><ul><li><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7</a></li><li>字符串按字典序排序</li><li>思路：回溯法，按递归树固定第一位、第二位</li><li>复杂度：O(n^n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            backtracking(str.toCharArray(), <span class="number">0</span>, res);</span><br><span class="line">            <span class="comment">// list按字典序排序</span></span><br><span class="line">            Collections.sort(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[] cArr, <span class="keyword">int</span> index, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == cArr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            String str = String.valueOf(cArr);</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(str)) &#123;</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二层，变换第一位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;cArr.length; i++) &#123;</span><br><span class="line">                swap(cArr, i, index);</span><br><span class="line">                <span class="comment">// 第三层，变换第二位</span></span><br><span class="line">                backtracking(cArr, index+<span class="number">1</span>, list);</span><br><span class="line">                <span class="comment">// 再swap一次调整回原样</span></span><br><span class="line">                swap(cArr, i, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] cArr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = cArr[i];</span><br><span class="line">        cArr[i] = cArr[j];</span><br><span class="line">        cArr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39-数组中出现次数超过一半的数字"></a>39-数组中出现次数超过一半的数字</h3><ul><li><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163" target="_blank" rel="noopener">https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163</a></li><li>有一个数字出现次数超过了一半，找到则返回，没找到返回0</li><li>思路：多数投票算法（排序O(nlogn)、哈希时空都是O(n)）</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一遍扫描，得到候选节点</span></span><br><span class="line">        <span class="keyword">int</span> candidate = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="comment">// 计数</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变candidate</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = array[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二遍扫描，判断次数是否过半</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="40-最小的K个数"><a href="#40-最小的K个数" class="headerlink" title="40-最小的K个数"></a>40-最小的K个数</h3><ul><li><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf</a></li><li>找出数组中最小的k个数</li><li>思路1：最大堆维护最小堆，适合海量数据输入（直接用最小堆每次添加都要入堆重建）</li><li>复杂度：O(nlogk)、O(k)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大堆维护最小堆，只剩k个最小的</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : input) &#123;</span><br><span class="line">            pq.add(num);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(pq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：Partition快速选择，会修改数组</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界条件，注意k的边界</span></span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span> || input.length==<span class="number">0</span> || k&lt;=<span class="number">0</span> || k&gt;input.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回前k个是最小的</span></span><br><span class="line">        findKSmall(input, k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findKSmall</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span>(i == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; k) &#123;</span><br><span class="line">                r = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = nums[l];</span><br><span class="line">        <span class="keyword">int</span> i=l, j=r+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=r &amp;&amp; nums[++i]&lt;p);</span><br><span class="line">            <span class="keyword">while</span>(j!=l &amp;&amp; nums[--j]&gt;p);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="41-1-数据流中的中位数"><a href="#41-1-数据流中的中位数" class="headerlink" title="41.1-数据流中的中位数"></a>41.1-数据流中的中位数</h3><ul><li><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1</a></li><li>实现添加和获取中位数操作</li><li>思路：两个优先队列</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大堆：左边是较小的元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">    <span class="comment">// 最小堆：右边是较大的元素</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// 个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 保证两个堆平衡</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 偶数：添加最小的到左边</span></span><br><span class="line">            right.add(num);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 奇数：添加最大的到右边</span></span><br><span class="line">            left.add(num);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="41-2-字符流中第一个不重复的字符"><a href="#41-2-字符流中第一个不重复的字符" class="headerlink" title="41.2-字符流中第一个不重复的字符"></a>41.2-字符流中第一个不重复的字符</h3><ul><li><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720" target="_blank" rel="noopener">https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720</a></li><li>找出第一个不重复的字符</li><li>思路：hash+队列</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">        queue.add(ch);</span><br><span class="line">        <span class="comment">// 重复的字符出队</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; hash[queue.peek()]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42-连续子数组的最大和"></a>42-连续子数组的最大和</h3><ul><li><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484" target="_blank" rel="noopener">https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484</a></li><li>求连续的子数组之和的最大值</li><li>思路：动态规划，如果和小于等于0重新加，否则累加</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="43-从1到n整数中1出现的次数"><a href="#43-从1到n整数中1出现的次数" class="headerlink" title="43-从1到n整数中1出现的次数"></a>43-从1到n整数中1出现的次数</h3><ul><li><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6" target="_blank" rel="noopener">https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6</a></li><li>计算从1开始到n，出现的1的次数</li><li>思路：分别计算个位、十位、百位…上1出现的次数</li><li>复杂度：O(logn)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 高位a，低位b</span></span><br><span class="line">            <span class="keyword">int</span> a = n/i, b = n%i;</span><br><span class="line">            <span class="comment">// 加8处理：当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</span></span><br><span class="line">            count += (a+<span class="number">8</span>)/<span class="number">10</span>*i;</span><br><span class="line">            <span class="comment">// b+1处理：当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)</span></span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                count += b+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="44-数字序列中的某一位数字"><a href="#44-数字序列中的某一位数字" class="headerlink" title="44-数字序列中的某一位数字"></a>44-数字序列中的某一位数字</h3><ul><li>序列化012345678910…，求第n位对应的数字</li><li>思路：找规律</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDigitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1是个位，2是百位...</span></span><br><span class="line">        <span class="keyword">int</span> place = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> amount = getAmountOfPlace(place);</span><br><span class="line">            <span class="keyword">int</span> total = amount*place;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; total) &#123;</span><br><span class="line">                <span class="keyword">return</span> getDigitAtIndex(index, place);</span><br><span class="line">            &#125;</span><br><span class="line">            index -= total;</span><br><span class="line">            place++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * place位数的数字组成的字符串长度：10,90,900</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAmountOfPlace</span><span class="params">(<span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(place == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, place-<span class="number">1</span>)*<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * place位数组成的字符串中，第index个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = getBeginNumberOfPlace(place);</span><br><span class="line">        <span class="keyword">int</span> shift = index / place;</span><br><span class="line">        String num = (begin + shift) + <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = index % place;</span><br><span class="line">        <span class="keyword">return</span> num.charAt(count) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * place位数的起始数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBeginNumberOfPlace</span><span class="params">(<span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(place == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, place-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="45-把数组排列成最小的数"><a href="#45-把数组排列成最小的数" class="headerlink" title="45-把数组排列成最小的数"></a>45-把数组排列成最小的数</h3><ul><li><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993</a></li><li>数组的数字排序组成最小的一个数</li><li>思路：排序</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">        <span class="comment">// 转换为字符串数组</span></span><br><span class="line">        String[] nums = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            nums[i] = numbers[i]+<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符串数组排序：比较s1+s2和s2+s1的大小</span></span><br><span class="line">        Arrays.sort(nums, (s1,s2)-&gt;(s1+s2).compareTo(s2+s1));</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String num : nums) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46-把数字翻译成字符串"></a>46-把数字翻译成字符串</h3><ul><li>将数字对应成字母，计算一个数字对应的字符串有几种</li><li>思路：动态规划</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 判断首位是否为零</span></span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>)==<span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前位的数字</span></span><br><span class="line">            <span class="keyword">int</span> one = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(one != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两位数字</span></span><br><span class="line">            <span class="keyword">int</span> two = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">            <span class="comment">// 累加次数</span></span><br><span class="line">            <span class="keyword">if</span>(two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="47-礼物的最大值"><a href="#47-礼物的最大值" class="headerlink" title="47-礼物的最大值"></a>47-礼物的最大值</h3><ul><li><a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab</a></li><li>在m*n的棋盘格里，从左上角开始拿礼物，求礼物拿到的最大值</li><li>思路：动态规划（dfs不是最优解）</li><li>复杂度：O(n^2)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span> [][] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(values==<span class="keyword">null</span> || values.length==<span class="number">0</span> || values[<span class="number">0</span>].length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = values[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] value : values) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] += value[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i-<span class="number">1</span>]) + value[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48-最长不含重复字符的子字符串"></a>48-最长不含重复字符的子字符串</h3><ul><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></li><li>找不含重复字符的子字符串，使其最长</li><li>思路：滑动窗口</li><li>复杂度：O(n)、O(len(charset))<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 滑动窗口为s[l...r]</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录字符频率</span></span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 右边界往前移动</span></span><br><span class="line">            <span class="keyword">if</span>(r+<span class="number">1</span>&lt;s.length() &amp;&amp; freq[s.charAt(r+<span class="number">1</span>)]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 需判断数组下标是否越界</span></span><br><span class="line">                freq[s.charAt(++r)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                freq[s.charAt(l++)]--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 49-丑数</span><br><span class="line">- https:<span class="comment">//www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b</span></span><br><span class="line">- 丑数的因子只包含<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>，输出第index个丑数</span><br><span class="line">- 思路：动态规划，丑数可分解为<span class="number">2</span>^x * <span class="number">3</span>^y * <span class="number">5</span>^z</span><br><span class="line">- 复杂度：O(n)、O(n)</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 丑数：因子只含2,3,5</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">0</span>, i3=<span class="number">0</span>, i5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="comment">// 1是第一个丑数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;index; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> two=dp[i2]*<span class="number">2</span>, three=dp[i3]*<span class="number">3</span>, five=dp[i5]*<span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 取三者的最小值</span></span><br><span class="line">            dp[i] = Math.min(two, Math.min(three, five));</span><br><span class="line">            <span class="comment">// 丑数 = 2^x * 3^y * 5^z</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == two) &#123; i2++; &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == three) &#123; i3++; &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == five) &#123; i5++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50-第一个只出现一次的字符"></a>50-第一个只出现一次的字符</h3><ul><li><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c</a></li><li>找字符串中，第一个频率为1的字符</li><li>思路1：HashMap计算频率</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算频率：Map</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : str.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找第一个频率为1的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i))==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：优化空间复杂度，用数组代替HashMap（再进一步BitSet存01）</li><li>复杂度：O(n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// 优化计算频率：数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++) &#123;</span><br><span class="line">            hash[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找第一个频率为1的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[str.charAt(i)]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51-数组中的逆序对"></a>51-数组中的逆序对</h3><ul><li><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5" target="_blank" rel="noopener">https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5</a></li><li>逆序对：前面的数字大于后面</li><li>思路：二路归并时计算（暴力TLE）</li><li>复杂度：O(logn)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二路归并</span></span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// %运算必须加括号</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (cnt%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r-l &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, l, mid);</span><br><span class="line">        mergeSort(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        merge(nums, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=l, j=mid+<span class="number">1</span>, k=l;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid || j&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">                tmp[k] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r) &#123;</span><br><span class="line">                tmp[k] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[k] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k] = nums[j++];</span><br><span class="line">                <span class="comment">// nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]</span></span><br><span class="line">                <span class="keyword">this</span>.cnt += mid-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=l; k&lt;=r; k++) &#123;</span><br><span class="line">            nums[k] = tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52-两个链表的第一个公共节点"></a>52-两个链表的第一个公共节点</h3><ul><li><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46</a></li><li>返回两个链表的公共节点</li><li>思路：遍历两遍链表，控制两者同时访问到交点</li><li>复杂度：O(m+n)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// p1到尾时从p2头开始，p2到尾时从p1头开始</span></span><br><span class="line">        ListNode p1=pHead1, p2=pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">            <span class="comment">// p1 = (p1==null) ? pHead2 : p1.next;</span></span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>) &#123;</span><br><span class="line">                p1 = pHead2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="keyword">null</span>) &#123;</span><br><span class="line">                p2 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="53-数字在排序数组中出现的次数"><a href="#53-数字在排序数组中出现的次数" class="headerlink" title="53-数字在排序数组中出现的次数"></a>53-数字在排序数组中出现的次数</h3><ul><li><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2" target="_blank" rel="noopener">https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2</a></li><li>统计一个数字在排序数组中出现的次数</li><li>思路：使用二分法可以把复杂度降至O(logn)</li><li>复杂度：O(logn)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 二分搜索k两端，求下标之差</span></span><br><span class="line">        <span class="keyword">int</span> l = binarySearch(array, k-<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">int</span> r = binarySearch(array, k+<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">return</span> r-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// target为double类型</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最左边的开始下标</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="54-二叉查找树的第K个结点"><a href="#54-二叉查找树的第K个结点" class="headerlink" title="54-二叉查找树的第K个结点"></a>54-二叉查找树的第K个结点</h3><ul><li><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a</a></li><li>返回二叉查找树第k小的节点</li><li>思路：二叉搜索树中序遍历为排序好的数组，直接返回第k个</li><li>复杂度：O(n)、O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 计数器，找第k个**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode res;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrder(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || cnt&gt;=k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left, k);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k) &#123; res = root; &#125;</span><br><span class="line">        inOrder(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59-滑动窗口的最大值"></a>59-滑动窗口的最大值</h3><ul><li><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788</a></li><li>找数组中，窗口大小为size里的最大值，返回list</li><li>思路1：直接遍历，for查找最大值</li><li>复杂度：O((n-size)*size)、O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num.length-size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;size; j++) &#123;</span><br><span class="line">                max = Math.max(num[i+j], max);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：堆，维护一个大小为size的最大堆</li><li>复杂度：O(n)、O(size)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 边界条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span> || size &gt; num.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            maxHeap.add(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(maxHeap.peek());</span><br><span class="line">        <span class="comment">// i从1到n-size</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num.length-size; i++) &#123;</span><br><span class="line">            <span class="comment">// 删除上一个访问过的元素</span></span><br><span class="line">            maxHeap.remove(num[i-<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 添加size长度的下一个元素</span></span><br><span class="line">            maxHeap.add(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            res.add(maxHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode分类汇总</title>
      <link href="2019/12/30/%E7%AE%97%E6%B3%95/leetcode/LeetCode%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/"/>
      <url>2019/12/30/%E7%AE%97%E6%B3%95/leetcode/LeetCode%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><ul><li>栈<ul><li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses</a>：<a href="#20题解">【20题解】</a> </li><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a>：<a href="#144题解">【144题解】</a></li></ul></li></ul><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ul><li>队列<ul><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>：<a href="#102题解">【102题解】</a></li><li><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. Top K Frequent Elements</a>：<a href="#347题解">【347题解】</a></li><li><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a>：<a href="#279题解-Queue">【279题解-Queue】</a></li></ul></li></ul><h2 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h2><ul><li>链表<ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a>：<a href="#206题解">【206题解】</a></li><li><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements</a>：<a href="#203题解">【203题解】</a></li><li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs</a>：<a href="#24题解">【24题解】</a></li><li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List</a>：<a href="#237题解">【237题解】</a></li><li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a>：<a href="#19题解">【19题解】</a></li><li><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a>：<a href="#234题解">【234题解】</a></li></ul></li></ul><h2 id="binarytree"><a href="#binarytree" class="headerlink" title="binarytree"></a>binarytree</h2><ul><li>二叉树<ul><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a>：<a href="#104题解">【104题解】</a></li><li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a>：<a href="#111题解">【11题解】</a></li><li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert Binary Tree</a>：<a href="#226题解">【226题解】</a></li><li><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a>：<a href="#100题解">【100题解】</a></li><li><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a>：<a href="#101题解">【101题解】</a></li><li><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. Count Complete Tree Nodes</a>：<a href="#222题解">【222题解】</a></li><li><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. Balanced Binary Tree</a>：<a href="#110题解">【110题解】</a></li><li><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a>：<a href="#112题解">【112题解】</a></li><li><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. Sum of Left Leaves</a>：<a href="#404题解">【404题解】</a></li><li><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths</a>：<a href="#257题解">【257题解】</a></li><li><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a>：<a href="#113题解">【113题解】</a></li><li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a>：<a href="#129题解">【129题解】</a></li><li><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a>：<a href="#437题解">【437题解】</a></li><li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a>：<a href="#235题解">【235题解】</a></li></ul></li></ul><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><ul><li>查找表<ul><li><a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. Intersection of Two Arrays</a>：<a href="#349题解">【349题解】</a></li><li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. Intersection of Two Arrays II</a>：<a href="#350题解">【350题解】</a></li><li><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram</a>：<a href="#242题解">【242题解】</a></li><li><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">202. Happy Number</a>：<a href="#202题解">【202题解】</a></li><li><a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">290. Word Pattern</a>：<a href="#290题解">【290题解】</a></li><li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum</a>：<a href="#1题解">【1题解】</a></li><li><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 4Sum II</a>：<a href="#454题解">【454题解】</a></li><li><a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. Number of Boomerangs</a>：<a href="#447题解">【447题解】</a></li><li><a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">804. Unique Morse Code Words</a>：<a href="#804题解">【804题解】</a></li><li><a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. Contains Duplicate II</a>：<a href="#219题解">【219题解】</a></li><li><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contain Duplicate III</a>：<a href="#220题解">【220题解】</a></li></ul></li></ul><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h2><ul><li>游标<ul><li><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">283. Move Zeroes</a>：<a href="#283题解">【283题解】</a></li><li><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">27. Remove Element</a>：<a href="#27题解">【27题解】</a></li></ul></li></ul><h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><ul><li>Partition<ul><li><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">75. Sort Colors</a>：<a href="#75题解">【75题解】</a></li><li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a>：<a href="#215题解">【215题解】</a></li></ul></li></ul><h2 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h2><ul><li>双指针<ul><li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted</a>：<a href="#167题解">【167题解】</a></li><li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a>：<a href="#11题解">【11题解】</a></li><li><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. Valid Palindrome</a>：<a href="#125题解">【125题解】</a></li><li><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a>：<a href="#345题解">【345题解】</a></li></ul></li></ul><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul><li>滑动窗口<ul><li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a>：<a href="#209题解">【209题解】</a></li><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a>：<a href="#3题解">【3题解】</a></li><li><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String</a>：<a href="#438题解">【438题解】</a></li><li><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring</a>：<a href="#76题解">【76题解】</a></li><li><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. Permutation in String</a>：<a href="#567题解">【567题解】</a></li><li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. Longest Repeating Character Replacement</a>：<a href="#424题解">【424题解】</a></li></ul></li></ul><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li>动态规划<ul><li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs</a>：<a href="#70题解">【70题解】</a></li><li><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break</a>：<a href="#343题解">【343题解】</a></li><li><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a>：<a href="#198题解">【198题解】</a></li><li><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a>：<a href="#279题解">【279题解】</a></li><li><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways</a>：<a href="#91题解">91题解</a></li><li><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a>：<a href="#416题解">【416题解】</a></li><li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a>：<a href="#300题解">【300题解】</a></li><li><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence</a>：<a href="#1143题解">【1143题解】</a></li></ul></li></ul><h2 id="greedy"><a href="#greedy" class="headerlink" title="greedy"></a>greedy</h2><ul><li>贪心<ul><li><a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">455. Assign Cookies</a>：<a href="#455题解">【455题解】</a></li><li><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. Non-overlapping Intervals</a>：<a href="#435题解">【435题解】</a></li></ul></li></ul><h2 id="backtracking"><a href="#backtracking" class="headerlink" title="backtracking"></a>backtracking</h2><ul><li>回溯<ul><li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number</a>：<a href="#17题解">【17题解】</a></li><li><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations</a>：<a href="#46题解">【46题解】</a></li><li><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. Combinations</a>：<a href="#77题解">【77题解】</a></li><li><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search</a>：<a href="#79题解">【79题解】</a></li><li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands</a>：<a href="#200题解">【200题解】</a></li><li><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">51. N Queens</a>：<a href="#51题解">【51题解】</a></li></ul></li></ul><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>stack</strong></p><h3 id="20题解"><a href="#20题解" class="headerlink" title="20题解"></a>20题解</h3><ul><li>stack<ul><li>20 Valid Parentheses：<a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a><ul><li>判断括号是否匹配</li><li>Input: “()[]{}”</li><li>Output: true</li></ul></li><li>思路：使用栈</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">    for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">        // 注意是单引号，char</span><br><span class="line">        if(s.charAt(i)==&apos;(&apos; || s.charAt(i)==&apos;&#123;&apos; || s.charAt(i)==&apos;[&apos;) &#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(stack.size() == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            char c = stack.pop();</span><br><span class="line">            char match;</span><br><span class="line">            if(s.charAt(i)==&apos;)&apos;) &#123;</span><br><span class="line">                match = &apos;(&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s.charAt(i)==&apos;&#125;&apos;) &#123;</span><br><span class="line">                match = &apos;&#123;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                assert s.charAt(i)==&apos;]&apos;;</span><br><span class="line">                match = &apos;[&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(match != c)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stack.size() != 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="144题解"><a href="#144题解" class="headerlink" title="144题解"></a>144题解</h3><ul><li>stack<ul><li>144 Binary Tree Preorder Traversal：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-preorder-traversal/</a><ul><li>二叉树的前序遍历</li><li>Input: binary tree [1,2,3]</li><li>Output: [1,2,3]</li></ul></li><li>思路1：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    preorderTraversal(root, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void preorderTraversal(TreeNode node, List&lt;Integer&gt; list) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    preorderTraversal(node.left, list);</span><br><span class="line">    preorderTraversal(node.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：非递归（使用栈）</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Command &#123;</span><br><span class="line">    String s;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    Command(String s, TreeNode node)&#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">        this.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(root == null)&#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Command&gt; stack = new Stack&lt;Command&gt;();</span><br><span class="line">    stack.push(new Command(&quot;go&quot;, root));</span><br><span class="line">    while(!stack.empty()) &#123;</span><br><span class="line">        Command command = stack.pop();</span><br><span class="line">        if(command.s == &quot;print&quot;)&#123;</span><br><span class="line">            res.add(command.node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            assert command.s.equals(&quot;go&quot;);</span><br><span class="line">            // 因为栈的先进后出，所以要反过来</span><br><span class="line">            if(command.node.right != null)&#123;</span><br><span class="line">                stack.push(new Command(&quot;go&quot;, command.node.right));</span><br><span class="line">            &#125;</span><br><span class="line">            if(command.node.left != null)&#123;</span><br><span class="line">                stack.push(new Command(&quot;go&quot;, command.node.left));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(new Command(&quot;print&quot;, command.node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>queue</strong></p><h3 id="102题解"><a href="#102题解" class="headerlink" title="102题解"></a>102题解</h3><ul><li>queue<ul><li>102 Binary Tree Level Order Traversal：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a><ul><li>二叉树的层序遍历</li><li>Input: binary tree [3,9,20,null,null,15,7]</li><li>Output: [[3], [9,20], [15,7]]</li></ul></li><li>思路：队列</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // LinkedList实现Queue</span><br><span class="line">    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt;();</span><br><span class="line">    queue.addLast(new Pair&lt;TreeNode, Integer&gt;(root, 0));</span><br><span class="line">    while(!queue.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;TreeNode, Integer&gt; front = queue.removeFirst();</span><br><span class="line">        TreeNode node = front.getKey();</span><br><span class="line">        int level = front.getValue();</span><br><span class="line">        // 等于表示在新的一层中</span><br><span class="line">        if(level == res.size())&#123;</span><br><span class="line">            res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        // 需用get方法，不能直接使用下标索引</span><br><span class="line">        res.get(level).add(node.val);</span><br><span class="line">        if(node.left != null)&#123;</span><br><span class="line">            queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.left, level+1));</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right != null)&#123;</span><br><span class="line">            queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.right, level+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="347题解"><a href="#347题解" class="headerlink" title="347题解"></a>347题解</h3><ul><li>queue<ul><li>347 Top K Frequent Elements：<a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a><ul><li>返回前k个出现频率最高的元素</li><li>Input: nums = [1,1,1,2,2,3], k = 2</li><li>Output: [1,2]</li></ul></li><li>思路：优先队列</li><li>时间复杂度：O(nlogk)</li><li>空间复杂度：O(n+k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">    // 统计每个元素出现的频率：map（元素，频率）</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; freq = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(!freq.containsKey(nums[i])) &#123;</span><br><span class="line">            freq.put(nums[i], 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            freq.put(nums[i], freq.get(nums[i])+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 维护出现频率最高的k个元素：优先队列（频率，元素）</span><br><span class="line">    PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt;(new PairComparator());</span><br><span class="line">    for(Integer num : freq.keySet()) &#123;</span><br><span class="line">        int numFreq = freq.get(num);</span><br><span class="line">        if(pq.size() == k) &#123;</span><br><span class="line">            if(numFreq &gt; pq.peek().getKey()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(new Pair&lt;Integer, Integer&gt;(numFreq, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            pq.add(new Pair&lt;Integer, Integer&gt;(numFreq, num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    while(!pq.isEmpty()) &#123;</span><br><span class="line">        res.add(pq.poll().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// 基于Pair的最大堆</span><br><span class="line">private class PairComparator implements Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2) &#123;</span><br><span class="line">        if(p1.getKey() != p2.getKey()) &#123;</span><br><span class="line">            return p1.getKey() - p2.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        return p1.getValue() - p2.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="279题解-Queue"><a href="#279题解-Queue" class="headerlink" title="279题解-Queue"></a>279题解-Queue</h3><ul><li>queue<ul><li>279 Perfect Squares：<a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a><ul><li>给定一个正整数n，求其由最少个完全平方数组成的和等于n的个数</li><li>Input: n = 13</li><li>Output: 2</li><li>Explanation: 13 = 4 + 9.</li></ul></li><li>思路：Queue</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt;();</span><br><span class="line">    queue.addLast(new Pair&lt;Integer, Integer&gt;(n, 0));</span><br><span class="line">    </span><br><span class="line">    boolean[] visited = new boolean[n+1];</span><br><span class="line">    visited[n] = true;</span><br><span class="line">    </span><br><span class="line">    while(!queue.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;Integer, Integer&gt; front = queue.removeFirst();</span><br><span class="line">        int num = front.getKey();</span><br><span class="line">        int step = front.getValue();</span><br><span class="line">        </span><br><span class="line">        if(num == 0) &#123;</span><br><span class="line">            res = step;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; num-i*i&gt;=0; i++) &#123;</span><br><span class="line">            if(!visited[num-i*i]) &#123;</span><br><span class="line">                queue.addLast(new Pair&lt;Integer, Integer&gt;(num-i*i, step+1));</span><br><span class="line">                visited[num-i*i] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>linkedlist</strong></p><h3 id="206题解"><a href="#206题解" class="headerlink" title="206题解"></a>206题解</h3><ul><li>linkedlist<ul><li>206 Reverse Linked List：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a><ul><li>反转一个链表</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li><li>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li></ul></li><li>思路1：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：迭代</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="203题解"><a href="#203题解" class="headerlink" title="203题解"></a>203题解</h3><pre><code>- 203 Remove Linked List Elements：https://leetcode.com/problems/remove-linked-list-elements/    - 删除链表中特定值的所有元素    - Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6    - Output: 1-&gt;2-&gt;3-&gt;4-&gt;5- 思路：dummy head- 时间复杂度：O(n)- 空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="24题解"><a href="#24题解" class="headerlink" title="24题解"></a>24题解</h3><ul><li>linkedlist<ul><li>24 Swap Nodes in Pairs：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/</a><ul><li>链表两两交换节点</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;null</li><li>Output: 2-&gt;1-&gt;4-&gt;3-&gt;null</li></ul></li><li>思路：dummy head</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;        </span><br><span class="line">    </span><br><span class="line">    ListNode p = dummyHead;</span><br><span class="line">    <span class="comment">// 注意：边界是p.next和p.next.next</span></span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = p.next;</span><br><span class="line">        ListNode node2 = node1.next;</span><br><span class="line">        ListNode next = node2.next;</span><br><span class="line">        </span><br><span class="line">        node2.next = node1;</span><br><span class="line">        node1.next = next;</span><br><span class="line">        p.next = node2;</span><br><span class="line">        p = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="237题解"><a href="#237题解" class="headerlink" title="237题解"></a>237题解</h3><ul><li>linkedlist<ul><li>237 Delete Node in a Linked List：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a><ul><li>给定链表中的一个节点，删除该节点</li><li>Input: head = [4,5,1,9], node = 5</li><li>Output: [4,1,9]</li><li>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</li></ul></li><li>思路：修改链表的值</li><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void deleteNode(ListNode node) &#123;</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.next == null)&#123;</span><br><span class="line">        node = null;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="19题解"><a href="#19题解" class="headerlink" title="19题解"></a>19题解</h3><ul><li>linkedlist<ul><li>19 Remove Nth Node From End of List：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a><ul><li>删除链表的倒数第N个元素</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5, n = 2</li><li>Output: 1-&gt;2-&gt;3-&gt;5</li></ul></li><li>思路：双指针，p和q之间的长度是固定的，只遍历一遍</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode p = dummyHead;</span><br><span class="line">    ListNode q = dummyHead;</span><br><span class="line">    for(int i=0; i&lt;n+1; i++)&#123;</span><br><span class="line">        assert q != null;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q != null) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    </span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>基础解法：遍历两遍，第一遍求链表的size，第二遍使用dummyHead删除第size-n个元素</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead.next;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while(cur != null)&#123;</span><br><span class="line">        index ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = dummyHead;</span><br><span class="line">    for(int i=0; i&lt;index-n; i++)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="234题解"><a href="#234题解" class="headerlink" title="234题解"></a>234题解</h3><ul><li>linkedlist<ul><li>234 Palindrome Linked List：<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a><ul><li>判断链表是否是回文的</li><li>Input: 1-&gt;2-&gt;2-&gt;1</li><li>Output: true</li></ul></li><li>思路：双指针</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode q = head;</span><br><span class="line">    while(q!=null &amp;&amp; q.next!=null) &#123;</span><br><span class="line">        q = q.next.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q != null)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = reverse(p);</span><br><span class="line"></span><br><span class="line">    q = head;</span><br><span class="line">    while(p != null) &#123;</span><br><span class="line">        if(p.val != q.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">private ListNode reverse(ListNode node) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = node;</span><br><span class="line">    while(cur != null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>binarytree</strong></p><h3 id="104题解"><a href="#104题解" class="headerlink" title="104题解"></a>104题解</h3><ul><li>104题解<ul><li>104 Maximum Depth of Binary Tree：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a><ul><li>返回二叉树的最大深度</li><li>Input: Given binary tree [3,9,20,null,null,15,7]</li><li>Output: 3</li></ul></li><li>知识：深度K=「log2n」+1（向下取整）</li><li>思路：递归</li><li>时间复杂度：O(n)，n是节点数</li><li>空间复杂度：O(h)，h是树深度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="111题解"><a href="#111题解" class="headerlink" title="111题解"></a>111题解</h3><ul><li>111题解<ul><li>111 Minimum Depth of Binary Tree：<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a><ul><li>求二叉树的最低深度</li><li>Input: Given binary tree [3,9,20,null,null,15,7]</li><li>Output: 2</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int minDepth(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    if (root.left!=null) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.left)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right!=null) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.right)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="226题解"><a href="#226题解" class="headerlink" title="226题解"></a>226题解</h3><ul><li>226题解<ul><li>226 Invert Binary Tree：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a><ul><li>反转二叉树，左右子树对调</li><li>Input: Given binary tree [4,2,7,1,3,6,9]</li><li>Output: return binary tree [4,7,2,9,6,3,1]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    // swap</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="100题解"><a href="#100题解" class="headerlink" title="100题解"></a>100题解</h3><ul><li>100题解<ul><li>100 Same Tree：<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/</a><ul><li>判断两颗二叉树是否相同</li><li>Input: binary tree [1,2,null], [1,null,2]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (p==null &amp;&amp; q==null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p==null || q==null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.val != q.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left = isSameTree(p.left, q.left);</span><br><span class="line">    boolean right = isSameTree(p.right, q.right);</span><br><span class="line">    return left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="101题解"><a href="#101题解" class="headerlink" title="101题解"></a>101题解</h3><ul><li>101题解<ul><li>101 Symmetric Tree：<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a><ul><li>判断二叉树是否对称</li><li>Input: binary tree [1,2,2,null,3,null,3]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return isMirror(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line">private boolean isMirror(TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (p==null &amp;&amp; q==null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p==null || q==null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.val != q.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="222题解"><a href="#222题解" class="headerlink" title="222题解"></a>222题解</h3><ul><li>222题解<ul><li>222 Count Complete Tree Nodes：<a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-complete-tree-nodes/</a><ul><li>计算完全二叉树节点个数</li><li>Input: binary tree [1,2,3,4,5,6,null]</li><li>Output: 6</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int countNodes(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归过程</span><br><span class="line">    return 1+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="110题解"><a href="#110题解" class="headerlink" title="110题解"></a>110题解</h3><ul><li>110题解<ul><li>110 Balanced Binary Tree：<a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/balanced-binary-tree/</a><ul><li>判断是否为平衡二叉树（每个节点的左右子树高度差不超过1）</li><li>Input: binary tree [1,2,2,3,3,null,null,4,4]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Math.abs(getDepth(root.left)-getDepth(root.right))&gt;1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归过程</span><br><span class="line">    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line">private int getDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1 + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="112题解"><a href="#112题解" class="headerlink" title="112题解"></a>112题解</h3><ul><li>112题解<ul><li>112 Path Sum：<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/</a><ul><li>找出二叉树路径中的是否有一条和等于sum</li><li>Input: binary tree [5,4,8,11,null,13,4,7,2]</li><li>Output: true</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return root.val == sum;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return hasPathSum(root.left, sum-root.val) ||</span><br><span class="line">            hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="404题解"><a href="#404题解" class="headerlink" title="404题解"></a>404题解</h3><ul><li>404题解<ul><li>404 Sum of Left Leaves：<a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-left-leaves/</a><ul><li>求左叶子节点的和</li><li>Input: binary tree [3,9,20,null,null,15,7]</li><li>Output: 24</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left!=null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null) &#123;</span><br><span class="line">        sum += root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    sum += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="257题解"><a href="#257题解" class="headerlink" title="257题解"></a>257题解</h3><ul><li>257题解<ul><li>257 Binary Tree Paths：<a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-paths/</a><ul><li>返回二叉树所有路径的path</li><li>Input: binary tree [1,2,3,null,5]</li><li>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null ) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        result.add(Integer.toString(root.val));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    List&lt;String&gt; leftPath = binaryTreePaths(root.left);</span><br><span class="line">    for (String i : leftPath) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(&quot;-&gt;&quot;);</span><br><span class="line">        sb.append(i);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; rightPath = binaryTreePaths(root.right);</span><br><span class="line">    for (String j : rightPath) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(&quot;-&gt;&quot;);</span><br><span class="line">        sb.append(j);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="113题解"><a href="#113题解" class="headerlink" title="113题解"></a>113题解</h3><ul><li>113题解<ul><li>113 Path Sum II：<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a><ul><li>返回二叉树路径中的所有等于sum的路径</li><li>Input: binary tree [5,4,8,11,null,13,4,7,2,null,null,5,1]</li><li>Output: [[5,4,11,2],[5,8,4,5]]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; middle = new ArrayList&lt;&gt;();</span><br><span class="line">    getPathSum(root, sum, middle, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private void getPathSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; middle, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    middle.add(root.val);</span><br><span class="line">    if(root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        if(root.val == sum) &#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(middle));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    getPathSum(root.left, sum-root.val, middle, result);</span><br><span class="line">    getPathSum(root.right, sum-root.val, middle, result);</span><br><span class="line">    middle.remove(middle.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="129题解"><a href="#129题解" class="headerlink" title="129题解"></a>129题解</h3><ul><li>129题解<ul><li>129 Sum Root to Leaf Numbers：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a><ul><li>求所有路径组成的数字的和</li><li>Input: binary tree [1,2,3]</li><li>Output: 25</li><li>Explanation:<ul><li>The root-to-leaf path 1-&gt;2 represents the number 12.</li><li>The root-to-leaf path 1-&gt;3 represents the number 13.</li><li>Therefore, sum = 12 + 13 = 25.</li></ul></li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">    return getSum(root, 0);</span><br><span class="line">&#125;</span><br><span class="line">private int getSum(TreeNode root, int curSum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    curSum = curSum*10 + root.val;</span><br><span class="line">    if(root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return curSum;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    return getSum(root.left, curSum) + getSum(root.right, curSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="437题解"><a href="#437题解" class="headerlink" title="437题解"></a>437题解</h3><ul><li>437题解<ul><li>437 Path Sum III：<a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/</a><ul><li>求二叉树中等于给定sum的路径，路径可以不从根节点开始</li><li>Input: binary tree [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</li><li>Output: 3</li><li>Explanation: three paths [[5,3], [5,2,1], [-3,11]]</li></ul></li><li>思路：递归嵌套递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    return findPath(root, sum)</span><br><span class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">&#125;</span><br><span class="line">private int findPath(TreeNode node, int sum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    if(node.val == sum)&#123;</span><br><span class="line">        res += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    res += findPath(node.left, sum-node.val);</span><br><span class="line">    res += findPath(node.right, sum-node.val);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="235题解"><a href="#235题解" class="headerlink" title="235题解"></a>235题解</h3><ul><li>235题解<ul><li>235 Lowest Common Ancestor of a Binary Search Tree：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a><ul><li>寻找两个节点最近的公共祖先</li><li>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</li><li>Output: 2</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    if(p.val&lt;root.val &amp;&amp; q.val&lt;root.val) &#123;</span><br><span class="line">        return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    if(p.val&gt;root.val &amp;&amp; q.val&gt;root.val) &#123;</span><br><span class="line">        return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>collection</strong></p><h3 id="349题解"><a href="#349题解" class="headerlink" title="349题解"></a>349题解</h3><ul><li>349题解<ul><li>349 Intersection of Two Arrays：<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays/</a><ul><li>找两个数组的交集</li><li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li><li>Output: [2]</li></ul></li><li>思路：Set</li><li>时间复杂度：O(n+m)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; record = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums1) &#123;</span><br><span class="line">        record.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; result = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums2) &#123;</span><br><span class="line">        if(record.contains(num)) &#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] res = new int[result.size()];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(Integer num : result) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="350题解"><a href="#350题解" class="headerlink" title="350题解"></a>350题解</h3><ul><li>350题解<ul><li>350 Intersection of Two Arrays II：<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a><ul><li>找两个数组的交集（包括重复的）</li><li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li><li>Output: [2,2]</li></ul></li><li>思路：Map</li><li>时间复杂度：O(n+mlogn)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int num : nums1) &#123;</span><br><span class="line">        if(!map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            map.put(num, map.get(num)+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums2) &#123;</span><br><span class="line">        if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0) &#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">            map.put(num, map.get(num)-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] res = new int[result.size()];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(Integer num : result) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="242题解"><a href="#242题解" class="headerlink" title="242题解"></a>242题解</h3><ul><li>242题解<ul><li>242 Valid Anagram：<a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a><ul><li>判断两个字符串是否为回文串</li><li>Input: s = “anagram”, t = “nagaram”</li><li>Output: true</li></ul></li><li>思路：Hash Table</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(26)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">    if(s.length() != t.length())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // HashTable</span><br><span class="line">    int[] freq = new int[26];</span><br><span class="line">    for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">        freq[s.charAt(i)-&apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">        freq[t.charAt(i)-&apos;a&apos;]--;</span><br><span class="line">        if(freq[t.charAt(i)-&apos;a&apos;] &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="202题解"><a href="#202题解" class="headerlink" title="202题解"></a>202题解</h3><ul><li>202题解<ul><li>202 Happy Number：<a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a><ul><li>判断一个数字是否为happy number</li><li>Input: 19</li><li>Output: true</li><li>Explanation: <ul><li>1^2 + 9^2 = 82</li><li>8^2 + 2^2 = 68</li><li>6^2 + 8^2 = 100</li><li>1^2 + 0^2 + 0^2 = 1</li></ul></li></ul></li><li>思路：Set</li><li>时间复杂度：O(?)</li><li>空间复杂度：O(?)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">     if(n&lt;1) &#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">     int t;</span><br><span class="line">     int newN;</span><br><span class="line">     while(n!=1 &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">         set.add(n);</span><br><span class="line">         newN = 0;</span><br><span class="line">         while(n&gt;0) &#123;</span><br><span class="line">             t = n%10;</span><br><span class="line">             n /= 10;</span><br><span class="line">             newN += t*t;</span><br><span class="line">         &#125;</span><br><span class="line">         n = newN;</span><br><span class="line">     &#125;</span><br><span class="line">     return n == 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="290题解"><a href="#290题解" class="headerlink" title="290题解"></a>290题解</h3><ul><li>290题解<ul><li>290 Word Pattern：<a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">https://leetcode.com/problems/word-pattern/</a><ul><li>判断所给的string是否是pattern的形式</li><li>Input: pattern = “abba”, str = “dog cat cat dog”</li><li>Output: true</li></ul></li><li>思路：Map</li><li>时间复杂度：O(nlogm)</li><li>空间复杂度：O(n+m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">    HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;();</span><br><span class="line">    char[] patterns = pattern.toCharArray();</span><br><span class="line">    String[] strs = str.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">    if(patterns.length != strs.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;patterns.length; i++) &#123;</span><br><span class="line">        char c = patterns[i];</span><br><span class="line">        if(!map.containsKey(c)) &#123;</span><br><span class="line">            if(map.containsValue(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            String value = map.get(c);</span><br><span class="line">            if(!value.equals(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1题解"><a href="#1题解" class="headerlink" title="1题解"></a>1题解</h3><ul><li>1题解<ul><li>1 Two Sum：<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a><ul><li>找出数组中和等于target的数字的下标（注意nums不是有序的）</li><li>Input: nums = [2, 7, 11, 15], target = 9</li><li>Output: [0,1]</li></ul></li><li>思路：将元素a放入Map中，之后查找target-a是否存在</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if(map.containsKey(complement)) &#123;</span><br><span class="line">            res[0] = i;</span><br><span class="line">            res[1] = map.get(complement);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="454题解"><a href="#454题解" class="headerlink" title="454题解"></a>454题解</h3><ul><li>454题解<ul><li>454 4Sum II：<a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a><ul><li>求四个整型数组的有多少种组合相加等于0</li><li>Input: A = [ 1, 2], B = [-2,-1], C = [-1, 2], D = [ 0, 2]</li><li>Output: 2</li><li>Explanation: The two tuples are:<ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></li></ul></li><li>思路：将C+D的所有组合放入Map中</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;C.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; D.length; j++) &#123;</span><br><span class="line">            int sum = C[i] + D[j];</span><br><span class="line">            if(!map.containsKey(sum)) &#123;</span><br><span class="line">                map.put(sum, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map.put(sum, map.get(sum)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i=0; i&lt;A.length; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;B.length; j++) &#123;</span><br><span class="line">            if(map.containsKey(0-A[i]-B[j])) &#123;</span><br><span class="line">                res += map.get(0-A[i]-B[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="447题解"><a href="#447题解" class="headerlink" title="447题解"></a>447题解</h3><ul><li>447题解<ul><li>447 Number of Boomerangs：<a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-boomerangs/</a><ul><li>寻找符合Boomerangs定义的三元组的个数</li><li>Input: [[0,0],[1,0],[2,0]]</li><li>Output: 2</li><li>Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</li></ul></li><li>思路：以i为枢纽点，把其他点跟i的距离放入Map，查找距离相同点的个数的组合</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int numberOfBoomerangs(int[][] points) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    // 遍历枢纽点i</span><br><span class="line">    for(int i=0; i&lt;points.length; i++) &#123;</span><br><span class="line">        // 把其他点的距离放入Map</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(int j=0; j&lt;points.length; j++) &#123;</span><br><span class="line">            if(j != i) &#123;</span><br><span class="line">                // 对比距离时使用距离的平方，无浮点数误差问题</span><br><span class="line">                int dist = dis(points[i], points[j]);</span><br><span class="line">                if(!map.containsKey(dist))</span><br><span class="line">                    map.put(dist, 1);</span><br><span class="line">                else</span><br><span class="line">                    map.put(dist, map.get(dist)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算相同距离点的个数的组合</span><br><span class="line">        for(Integer dis : map.keySet())</span><br><span class="line">            res += map.get(dis) * (map.get(dis)-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private int dis(int[] a, int[] b) &#123;</span><br><span class="line">    return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="804题解"><a href="#804题解" class="headerlink" title="804题解"></a>804题解</h3><ul><li>804题解<ul><li>804 Unique Morse Code Words：<a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-morse-code-words/</a><ul><li>返回不同摩斯码的个数</li><li>Input: words = [“gin”, “zen”, “gig”, “msg”]</li><li>Output: 2</li><li>Explanation: There are 2 different transformations, “–…-.” and “–…–.”.</li></ul></li><li>思路：使用Set返回不同摩斯码的个数</li><li>时间复杂度：O(n+s)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int uniqueMorseRepresentations(String[] words) &#123;</span><br><span class="line">    String[] codes = &#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;</span><br><span class="line">    TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();</span><br><span class="line">    for(String word : words) &#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i=0; i&lt;word.length(); i++)</span><br><span class="line">            res.append(codes[word.charAt(i)-&apos;a&apos;]);</span><br><span class="line">        set.add(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="219题解"><a href="#219题解" class="headerlink" title="219题解"></a>219题解</h3><ul><li>219题解<ul><li>219 Contains Duplicate II：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-ii/</a><ul><li>判断数组是否在k长度内有重复元素</li><li>Input: nums = [1,2,3,1], k = 3</li><li>Output: true</li></ul></li><li>思路：Set+滑动窗口</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(set.contains(nums[i]))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        // 保持set中最多有k个元素（边界：i-k）</span><br><span class="line">        if(set.size() == k+1)&#123;</span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="220题解"><a href="#220题解" class="headerlink" title="220题解"></a>220题解</h3><ul><li>220题解<ul><li>220 Contain Duplicate III：<a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-iii/</a><ul><li>判断数组是否在k长度内有差值不大于t的两个数</li><li>Input: nums = [1,2,3,1], k = 3, t = 0</li><li>Output: true</li></ul></li><li>思路：set+滑动窗口</li><li>时间复杂度：O(nlogk)</li><li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">    // 需要用Long和long，会发生整型溢出</span><br><span class="line">    TreeSet&lt;Long&gt; set = new TreeSet&lt;Long&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(set.ceiling((long)nums[i]-(long)t) != null &amp;&amp; set.ceiling((long)nums[i]-(long)t)&lt;=(long)nums[i]+(long)t)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((long)nums[i]);</span><br><span class="line">        if(set.size() == k+1)&#123;</span><br><span class="line">            set.remove((long)nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>cursor</strong></p><h3 id="283题解"><a href="#283题解" class="headerlink" title="283题解"></a>283题解</h3><ul><li>283题解<ul><li>283 Move Zeroes：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a><ul><li>把数组中的零移到后面去</li><li>Input: [0,1,0,3,12]</li><li>Output: [1,3,12,0,0]</li></ul></li><li>问题：使用了O(n)的空间，可以原地吗？</li><li>优化1：用一个k游标去保存非零元素的个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">    // 优化1：原地，不用O(n)的空间</span><br><span class="line">    // 时间复杂度：O(n)</span><br><span class="line">    // 空间复杂度：O(1)</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        if(nums[i]!=0)</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">    for(int i=k; i&lt;nums.length; i++)</span><br><span class="line">        nums[i] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>优化2：swap 0和非0（用游标k，就不用再for循环了）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">    // 优化2：swap 0和非0（用游标k，就不用再for循环了）</span><br><span class="line">    // 时间复杂度：O(n)</span><br><span class="line">    // 空间复杂度：O(1)</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        if(nums[i]!=0)&#123;</span><br><span class="line">            // swap(nums[i], nums[k])</span><br><span class="line">            if(i!=k)&#123;</span><br><span class="line">                int t = nums[i];</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k] = t;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            else // i==k</span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="27题解"><a href="#27题解" class="headerlink" title="27题解"></a>27题解</h3><ul><li>27题解<ul><li>27 Remove Element：<a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-element/</a> <ul><li>给定nums，删除指定的值val</li><li>Input: nums = [3,2,2,3], val = 3,</li><li>Output: Your function should return length = 2, with the first two elements of nums being 2.</li></ul></li><li>思路：cursor</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        if(nums[i] != val)&#123;</span><br><span class="line">            if(i!=k)&#123;</span><br><span class="line">                int t = nums[i];</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k] = t;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>partition</strong></p><h3 id="75题解"><a href="#75题解" class="headerlink" title="75题解"></a>75题解</h3><ul><li>75题解<ul><li>75 Sort Color：<a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a><ul><li>对三种颜色进行排序，用0,1,2表示颜色</li><li>Input: [2,0,2,1,1,0]</li><li>Output: [0,0,1,1,2,2]</li></ul></li><li>思路：使用三路快排：只需一次for循环</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">    int zero = -1;</span><br><span class="line">    int two = nums.length;</span><br><span class="line">    for(int i=0; i&lt;two; )&#123;</span><br><span class="line">        // 1</span><br><span class="line">        if(nums[i]==1)</span><br><span class="line">            i++;</span><br><span class="line">        // 2</span><br><span class="line">        else if(nums[i]==2)&#123;</span><br><span class="line">            two--;</span><br><span class="line">            swap(nums, i, two);</span><br><span class="line">        &#125;</span><br><span class="line">        // 0</span><br><span class="line">        else&#123;</span><br><span class="line">            assert(nums[i]==0);</span><br><span class="line">            zero++;</span><br><span class="line">            swap(nums, i, zero);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="215题解"><a href="#215题解" class="headerlink" title="215题解"></a>215题解</h3><ul><li>215题解<ul><li>215 Kth Largest Element in an Array：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> <ul><li>返回第K大的数</li><li>Input: [3,2,1,5,6,4] and k = 2</li><li>Output: 5</li></ul></li><li>思路：快排Partition思路</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(logn)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    return findKthLargest(nums, 0, nums.length-1, k-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int findKthLargest(int[] nums, int l, int r, int k)&#123;</span><br><span class="line">    if(l==r)</span><br><span class="line">        return nums[l];</span><br><span class="line">    int p = partition(nums, l, r);</span><br><span class="line"></span><br><span class="line">    if( p == k )</span><br><span class="line">        return nums[p];</span><br><span class="line">    else if( k &lt; p )</span><br><span class="line">        return findKthLargest(nums, l, p-1, k);</span><br><span class="line">    else // k &gt; p</span><br><span class="line">        return findKthLargest(nums, p+1 , r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int l , int r)&#123;</span><br><span class="line">    int p = (int) (Math.random()%(r-l+1) + l);</span><br><span class="line">    swap(nums, l, p);</span><br><span class="line">    int lt = l + 1;</span><br><span class="line">    for( int i = l + 1 ; i &lt;= r ; i ++ )</span><br><span class="line">        if( nums[i] &gt; nums[l] )</span><br><span class="line">            swap(nums, i, lt++);</span><br><span class="line">    swap(nums, l, lt-1);</span><br><span class="line">    return lt-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>pointers</strong></p><h3 id="167题解"><a href="#167题解" class="headerlink" title="167题解"></a>167题解</h3><ul><li>167题解<ul><li>167 Two Sum II：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</a> <ul><li>给定排序好的数组，找出两数和等于target的下标，index1&lt;index2</li><li>Input: numbers = [2,7,11,15], target = 9</li><li>Output: [1,2]</li></ul></li><li>思路：使用双指针，一个在前，一个在后，指针随sum与target的差距而变化</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">    int index1;</span><br><span class="line">    int index2 = numbers.length-1;</span><br><span class="line">    int[] result = &#123;0, 0&#125;;</span><br><span class="line">    for(index1=0; index1&lt;numbers.length; )&#123;</span><br><span class="line">        if(numbers[index1]+numbers[index2]==target)&#123;</span><br><span class="line">            result[0] = index1+1;</span><br><span class="line">            result[1] = index2+1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(numbers[index1]+numbers[index2]&lt;target)</span><br><span class="line">            index1++;</span><br><span class="line">        else</span><br><span class="line">            index2--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="11题解"><a href="#11题解" class="headerlink" title="11题解"></a>11题解</h3><ul><li>11题解<ul><li>11 Container With Most Water：<a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a> <ul><li>求Container的最大面积</li><li>Input: [1,8,6,2,5,4,8,3,7]</li><li>Output: 49</li></ul></li><li>思路：双指针</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">    int area = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = height.length-1;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        int t = (j-i)*Math.min(height[i], height[j]);</span><br><span class="line">        if(t&gt;area)</span><br><span class="line">            area = t;</span><br><span class="line">        if(height[i]&lt;height[j])</span><br><span class="line">            i++;</span><br><span class="line">        else</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="125题解"><a href="#125题解" class="headerlink" title="125题解"></a>125题解</h3><ul><li>125题解<ul><li>125 Valid Palindrome：<a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a><ul><li>判断字符串是否为回文串，可跳过符号（空字符串是回文串）</li><li>Input: “A man, a plan, a canal: Panama”</li><li>Output: true</li></ul></li><li>思路：双指针</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">    if(s==null)</span><br><span class="line">        return true;</span><br><span class="line">    String reg = &quot;[^0-9a-zA-Z]&quot;;</span><br><span class="line">    s = s.replaceAll(reg, &quot;&quot;);</span><br><span class="line">    int i=0, j=s.length()-1;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        char c1 = Character.toLowerCase(s.charAt(i));</span><br><span class="line">        char c2 = Character.toLowerCase(s.charAt(j));</span><br><span class="line">        if(c1 == c2)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="345题解"><a href="#345题解" class="headerlink" title="345题解"></a>345题解</h3><ul><li>345题解<ul><li>345 Reverse Vowels of a String：<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-vowels-of-a-string/</a><ul><li>swap字符串中的元音字母</li><li>Input: “hello”</li><li>Output: “holle”</li></ul></li><li>思路：双指针</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String reverseVowels(String s) &#123;</span><br><span class="line">    int i=0, j=s.length()-1;</span><br><span class="line">    char[] arr = s.toCharArray();</span><br><span class="line">    String vowels = &quot;aeiouAEIOU&quot;;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        if(!vowels.contains(arr[i]+&quot;&quot;))&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!vowels.contains(arr[j]+&quot;&quot;))&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(vowels.contains(arr[i]+&quot;&quot;)&amp;&amp;vowels.contains(arr[j]+&quot;&quot;))&#123;</span><br><span class="line">            char c = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>window</strong></p><h3 id="209题解"><a href="#209题解" class="headerlink" title="209题解"></a>209题解</h3><ul><li>209题解<ul><li>209 Minimum Size Subarray Sum：<a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-size-subarray-sum/</a><ul><li>求最短子序和sum&lt;=s</li><li>Input: s = 7, nums = [2,3,1,2,4,3]</li><li>Output: 2</li><li>注意：子数组是否连续？没有解怎么办？</li></ul></li><li>思路：滑动窗口（维护nums[i…j]，如果sum比s小 sum += nums[++j]，否则sum -= nums[i++]）</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">    int i = 0, j = -1; // j最开始是-1，不包含任何元素</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int min= nums.length+1; // 设一个最大的数n+1取不到</span><br><span class="line">    while (i&lt;nums.length)&#123; // 遍历[0...n-1]，不是i&lt;j</span><br><span class="line">        if(j+1&lt;nums.length &amp;&amp; sum &lt; s)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(sum&gt;=s)</span><br><span class="line">           min = Math.min(len, j-i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(min==nums.length+1) // 没有判断过不了输出为0的测试用例：[1,1] 3</span><br><span class="line">        return 0;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3题解"><a href="#3题解" class="headerlink" title="3题解"></a>3题解</h3><ul><li>3题解<ul><li>3 Longest Substring Without Repeating Characters：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a><ul><li>求字符串不重复子串的最长值</li><li>Input: “abcabcbb”</li><li>Output: 3 </li><li>Explanation: The answer is “abc”, with the length of 3.</li></ul></li><li>思路：滑动窗口，使用freq[256]记录重复字符</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int[] freq = new int[256]; // 记录字母是否重复</span><br><span class="line">    int i=0, j=-1;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(i&lt;s.length())&#123;</span><br><span class="line">        if(j+1&lt;s.length() &amp;&amp; freq[s.charAt(j+1)]==0)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            freq[s.charAt(j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            freq[s.charAt(i)]--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        len = Math.max(len, j-i+1); // 注意：是最长子串max</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="438题解"><a href="#438题解" class="headerlink" title="438题解"></a>438题解</h3><ul><li>438题解<ul><li>438 Find All Anagrams in a String：<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-anagrams-in-a-string/</a><ul><li>找字符串的Anagram的开始下标</li><li>Input: s: “cbaebabacd” p: “abc”</li><li>Output: [0, 6]</li><li>Explanation:<ul><li>The substring with start index = 0 is “cba”, which is an anagram of “abc”.</li><li>The substring with start index = 6 is “bac”, which is an anagram of “abc”.</li></ul></li></ul></li><li>思路：滑动窗口</li><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">    List&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    int i=0, j=0;</span><br><span class="line">    int count = p.length();</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    for (char c : p.toCharArray())&#123;</span><br><span class="line">        freq[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt; s.length())&#123;</span><br><span class="line">        if (freq[s.charAt(j++)]-- &gt; 0)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            indexList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (j-i==p.length() &amp;&amp; freq[s.charAt(i++)]++ &gt;= 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return indexList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="76题解"><a href="#76题解" class="headerlink" title="76题解"></a>76题解</h3><ul><li>76题解<ul><li>76 Minimum Window Substring：<a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a><ul><li>求字符串s中包含字符串t的最小窗口</li><li>Input: S = “ADOBECODEBANC”, T = “ABC”</li><li>Output: “BANC”</li></ul></li><li>思路：滑动窗口</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">    int[] sFreq = new int[256];</span><br><span class="line">    int count = 0;</span><br><span class="line">    int[] tFreq = new int[256];</span><br><span class="line">    for (int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">        tFreq[t.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int minLen = s.length()+1;</span><br><span class="line">    int startIndex = -1;</span><br><span class="line">    int i=0, j=-1;</span><br><span class="line">    while (i&lt;s.length())&#123;</span><br><span class="line">        if (j+1&lt;s.length() &amp;&amp; count&lt;t.length())&#123;</span><br><span class="line">            sFreq[s.charAt(j+1)]++;</span><br><span class="line">            if (sFreq[s.charAt(j+1)] &lt;= tFreq[s.charAt(j+1)])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            assert count&lt;=t.length();</span><br><span class="line">            if(count==t.length() &amp;&amp; j-i+1&lt;minLen)&#123;</span><br><span class="line">                minLen = j-i+1;</span><br><span class="line">                startIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            sFreq[s.charAt(i)]--;</span><br><span class="line">            if (sFreq[s.charAt(i)] &lt; tFreq[s.charAt(i)])&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (startIndex != -1)&#123;</span><br><span class="line">        return s.substring(startIndex, startIndex+minLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="567题解"><a href="#567题解" class="headerlink" title="567题解"></a>567题解</h3><ul><li>567题解<ul><li>567 Permutation in String：<a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">https://leetcode.com/problems/permutation-in-string/</a><ul><li>在字符串s2里找是否有字符串s1的全排列</li><li>Input: s1 = “ab” s2 = “eidbaooo”</li><li>Output: True</li><li>Explanation: s2 contains one permutation of s1 (“ba”)</li></ul></li><li>思路：滑动窗口</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean checkInclusion(String s1, String s2) &#123;</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    for (char c : s1.toCharArray()) &#123;</span><br><span class="line">        freq[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0, count=0;</span><br><span class="line">    for (int j=0; j&lt;s2.length(); j++) &#123;</span><br><span class="line">        freq[s2.charAt(j)]--;</span><br><span class="line">        if (freq[s2.charAt(j)] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &gt;= s1.length()) &#123;</span><br><span class="line">            freq[s2.charAt(i)]++;</span><br><span class="line">            if (freq[s2.charAt(i)] &gt;= 1) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count==s1.length()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="424题解"><a href="#424题解" class="headerlink" title="424题解"></a>424题解</h3><ul><li>424题解<ul><li>424 Longest Repeating Character Replacement：<a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-repeating-character-replacement/</a><ul><li>如字符串s可以替换k次，求最长的连续重复字符的个数</li><li>Input: s = “ABAB”, k = 2    </li><li>Output: 4</li><li>Explanation: Replace the two ‘A’s with two ‘B’s or vice versa.</li></ul></li><li>思路：滑动窗口</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">    int i=0, j=0;</span><br><span class="line">    int max = 0;</span><br><span class="line">    int maxCount = 0;</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    while (j&lt;s.length()) &#123;</span><br><span class="line">        freq[s.charAt(j)]++;</span><br><span class="line">        maxCount = Math.max(maxCount, freq[s.charAt(j)]);</span><br><span class="line">        j++;</span><br><span class="line">        while(j-i-maxCount &gt; k) &#123;</span><br><span class="line">            freq[s.charAt(i++)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>dp</strong></p><h3 id="70题解"><a href="#70题解" class="headerlink" title="70题解"></a>70题解</h3><ul><li>dp<ul><li>70 Climbing Stairs：<a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a><ul><li>给定n，求step的组合，step仅为1和2</li><li>Input: 2</li><li>Output: 2</li><li>Explanation: There are two ways to climb to the top.<ul><li>1 step + 1 step</li><li>2 steps</li></ul></li></ul></li><li>递归解法：StackOverflowError栈溢出（原因没有指定n=1的情况）<ul><li>过不了：Time Limit Exceeded </li></ul></li><li>Key：爬上n-1阶台阶再爬1阶，或者爬上n-2阶台阶再爬2阶</li><li>记忆化搜索memo：自顶向下的解决问题</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    memo = new int[n+2];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return climbing(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int climbing(int n)&#123;</span><br><span class="line">    if(n==1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(n==2)</span><br><span class="line">        return 2;</span><br><span class="line">    if(memo[n]==-1)</span><br><span class="line">        memo[n] = climbing(n-1) + climbing(n-2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划：自底向上的解决问题</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+2];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    memo[1] = 1;</span><br><span class="line">    memo[2] = 2;</span><br><span class="line">    for(int i=3; i&lt;=n; i++)</span><br><span class="line">       memo[i] = memo[i-1]+memo[i-2];</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="343题解"><a href="#343题解" class="headerlink" title="343题解"></a>343题解</h3><ul><li>dp<ul><li>343 Integer Break：<a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode.com/problems/integer-break/</a> <ul><li>给定正整数n，分割n为至少两个数之和，返回分割后的数字相乘的最大值</li><li>Input: 10</li><li>Output: 36</li><li>Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</li></ul></li><li>Key：f(n) = max(i*f(n-i))</li></ul></li></ul><pre><code>- 递归：Time Limit Exceeded（暴力解法：回溯遍历这个数分割的所有可能性 O(2^n)）- 思路1：记忆化搜索- 时间复杂度：O(n^2)- 空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int integerBreak(int n) &#123;</span><br><span class="line">    memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return breakInteger(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// break</span><br><span class="line">private int breakInteger(int n)&#123;</span><br><span class="line">    if(n==1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(memo[n] != -1)</span><br><span class="line">        return memo[n];</span><br><span class="line">    int max = -1;</span><br><span class="line">    for(int i=1; i&lt;=n-1; i++)</span><br><span class="line">        max = max3(max, i*(n-i), i*breakInteger(n-i));</span><br><span class="line">    memo[n] = max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// max3</span><br><span class="line">private int max3(int a, int b, int c)&#123;</span><br><span class="line">    return Math.max(a, Math.max(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 思路2：动态规划- 时间复杂度：O(n^2)- 空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int integerBreak(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    </span><br><span class="line">    memo[1] = 1;</span><br><span class="line">    for(int i=2; i&lt;=n; i++)</span><br><span class="line">        // 求解memo[i]</span><br><span class="line">        for(int j=1; j&lt;=i-1; j++)</span><br><span class="line">            memo[i] = max3(memo[i], j*(i-j), j*memo[i-j]);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// max3</span><br><span class="line">private int max3(int a, int b, int c)&#123;</span><br><span class="line">    return Math.max(a, Math.max(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="198题解"><a href="#198题解" class="headerlink" title="198题解"></a>198题解</h3><ul><li>dp<ul><li>198 House Robber：<a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a> <ul><li>给定nums数组代表连续相邻的家庭所有的money，若抢相邻的两家会触发报警，求所能抢的money的最大值</li><li>Input: [1,2,3,1]</li><li>Output: 4</li><li>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<ul><li>Total amount you can rob = 1 + 3 = 4.</li></ul></li></ul></li><li>Key<ul><li>状态（函数的定义）：考虑偷取[x…n-1]范围里的房子</li><li>状态转移方程：f(0)=max{v(0)+f(2), v(1)+f(3), v(2)+f(4), …, v(n-3)+f(n-1), v(n-2), v(n-1)}</li></ul></li></ul></li></ul><pre><code>- 思路1：记忆化搜索- 时间复杂度：O(n^2)- 空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return tryRobber(nums, 0);</span><br><span class="line">&#125;</span><br><span class="line">// 考虑抢劫[x...n-1]</span><br><span class="line">private int tryRobber(int[] nums, int index)&#123;</span><br><span class="line">    if(index &gt;= nums.length)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[index] != -1)</span><br><span class="line">        return memo[index];</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=index; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, nums[i] + tryRobber(nums, i+2));</span><br><span class="line">    memo[index] = max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 思路2：动态规划- 时间复杂度：O(n^2)- 空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[] memo = new int[n];</span><br><span class="line">        Arrays.fill(memo, -1);</span><br><span class="line">        memo[n-1] = nums[n-1];</span><br><span class="line">        for(int i=n-2; i&gt;=0; i--)&#123;</span><br><span class="line">            // memo[i]</span><br><span class="line">            for(int j=i; j&lt;n; j++)</span><br><span class="line">// memo[i] = Math.max(memo[i], nums[j] + memo[j+2]);</span><br><span class="line">                memo[i] = Math.max(memo[i], nums[j] + (j+2&lt;n ? memo[j+2] : 0));</span><br><span class="line">        &#125;</span><br><span class="line">        return memo[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="279题解"><a href="#279题解" class="headerlink" title="279题解"></a>279题解</h3><ul><li>dp<ul><li>279 Perfect Squares：<a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a><ul><li>给定一个正整数n，求其由最少个完全平方数组成的和等于n的个数</li><li>Input: n = 13</li><li>Output: 2</li><li>Explanation: 13 = 4 + 9.</li></ul></li><li>Key：f(n) = min(1+f(n-i^2))</li><li>思路1：记忆化搜索</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return squares(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int squares(int n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[n] != -1)</span><br><span class="line">        return memo[n];</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    for(int i=1; n-i*i&gt;=0; i++)</span><br><span class="line">        min = Math.min(min, 1+squares(n-i*i));</span><br><span class="line">    memo[n] = min;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, Integer.MAX_VALUE);</span><br><span class="line">    memo[0] = 0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        for(int j=1; i-j*j&gt;=0; j++)</span><br><span class="line">        memo[i] = Math.min(memo[i], 1+memo[i-j*j]);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="91题解"><a href="#91题解" class="headerlink" title="91题解"></a>91题解</h3><ul><li>dp<ul><li>91 Decode Ways：<a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a><ul><li>求数字解码对应的字母含义的组合个数</li><li>Input: “12”</li><li>Output: 2</li><li>Explanation: It could be decoded as “AB” (1 2) or “L” (12)</li></ul></li><li>思路1：记忆化搜索</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int numDecodings(String s) &#123;</span><br><span class="line">    memo = new int[s.length()+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    memo[s.length()] = 1;</span><br><span class="line">    return getNum(s, 0);</span><br><span class="line">&#125;</span><br><span class="line">private int getNum(String s, int i) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    if(n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(memo[i] &gt; -1) &#123;</span><br><span class="line">        return memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(s.charAt(i) == &apos;0&apos;) &#123;</span><br><span class="line">        return memo[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = getNum(s, i+1);</span><br><span class="line">    if(i&lt;s.length()-1 &amp;&amp; Integer.parseInt(s.substring(i, i+2)) &lt;= 26) &#123;</span><br><span class="line">        res += getNum(s, i+2);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int numDecodings(String s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    if(n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    memo[n] = 1;</span><br><span class="line">    memo[n-1] = s.charAt(n-1)==&apos;0&apos; ? 0 : 1;</span><br><span class="line">    for(int i=n-2; i&gt;=0; i--) &#123;</span><br><span class="line">        if(s.charAt(i) == &apos;0&apos;) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            memo[i] = Integer.parseInt(s.substring(i, i+2)) &lt;= 26 ? memo[i+1] + memo[i+2] : memo[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="416题解"><a href="#416题解" class="headerlink" title="416题解"></a>416题解</h3><ul><li>dp<ul><li>416 Partition Equal Subset Sum：<a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-equal-subset-sum/</a><ul><li>给定数组nums，求其是否可以被分成两个子数组，其和相等（注意：最多有200个数字，每个数字最大为100）</li><li>Input: [1, 5, 11, 5]</li><li>Output: true</li><li>Explanation: The array can be partitioned as [1, 5, 5] and [11].</li></ul></li><li>是背包问题：在n个物品中选一定物品，是否可以完全填满sum/2的背包</li><li>Key：状态：F(i,c) = F(i-1,c) || F(i-1, c-w(i))</li><li>数据规模 $n<em>sum/2=100</em>100*200/2$：最多有200个数字，每个数字最大为100</li><li>思路1：记忆化搜索</li><li>时间复杂度：O(n*sum)</li><li>空间复杂度：O(n*sum)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int[][] memo; // memo[i][c]: -1是未计算，0是不可填充，1是可以填充</span><br><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        assert nums[i]&gt;0;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum%2 != 0)</span><br><span class="line">        return false;</span><br><span class="line">    memo = new int[nums.length][sum/2+1]; // 表示0...sum/2，故+1</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        Arrays.fill(memo[i], -1);</span><br><span class="line">    return tryPartition(nums, nums.length-1, sum/2);</span><br><span class="line">&#125;</span><br><span class="line">// 使用nums[0...index]是否可以完全填满sum的背包</span><br><span class="line">private boolean tryPartition(int[] nums, int index, int sum)&#123;</span><br><span class="line">    if(sum==0) // 背包没有空间，即填满了</span><br><span class="line">        return true;</span><br><span class="line">    if(sum&lt;0 || index&lt;0)</span><br><span class="line">        return false;</span><br><span class="line">    if(memo[index][sum] != -1)</span><br><span class="line">        return memo[index][sum] == 1;</span><br><span class="line">    memo[index][sum] = tryPartition(nums, index-1, sum) || tryPartition(nums, index-1, sum-nums[index]) ? 1: 0;</span><br><span class="line">    return memo[index][sum] == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划</li><li>时间复杂度：O(n*sum)</li><li>空间复杂度：O(sum)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">        assert nums[i]&gt;0;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int C = sum/2;</span><br><span class="line">    if(sum%2 != 0)</span><br><span class="line">        return false;</span><br><span class="line">    boolean[] memo = new boolean[C+1]; // 表示0...sum/2</span><br><span class="line">    for(int j=0; j&lt;=C; j++)</span><br><span class="line">        memo[j] = (nums[0] == j); // j -&gt; c</span><br><span class="line">    for(int i=1; i&lt;n; i++)</span><br><span class="line">        for(int j=C; j&gt;=nums[i]; j--)</span><br><span class="line">            memo[j] = memo[j] || memo[j-nums[i]];</span><br><span class="line">        </span><br><span class="line">    return memo[C];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="300题解"><a href="#300题解" class="headerlink" title="300题解"></a>300题解</h3><ul><li>dp<ul><li>300 Longest Increasing Subsequence：<a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/</a><ul><li>求最长上升子序列的length </li><li>Input: [10,9,2,5,3,7,101,18]</li><li>Output: 4 </li><li>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </li></ul></li><li>Key<ul><li>状态：f(i)表示以第i个数字为结尾的最长上升子序列的长度（即[0…i]里选择nums[i]可以获得的最长上升子序列）</li><li>转移方程：f(i) = max(1+f(j) if nums[j]&lt;nums[i])</li></ul></li><li>思路1：记忆化搜索</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0)</span><br><span class="line">        return 0;</span><br><span class="line">    memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, getMaxLen(nums, i));</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">private int getMaxLen(int[] nums, int index)&#123;</span><br><span class="line">    if(memo[index] != -1)</span><br><span class="line">        return memo[index];</span><br><span class="line">    int max = 1;</span><br><span class="line">    for(int i=0; i&lt;index; i++)</span><br><span class="line">        if(nums[i] &lt; nums[index])</span><br><span class="line">            max = Math.max(max, 1+getMaxLen(nums, i));</span><br><span class="line">    memo[index] = max;</span><br><span class="line">    return memo[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0)</span><br><span class="line">        return 0;</span><br><span class="line">    int[] memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, 1);</span><br><span class="line">    for(int i=1; i&lt;nums.length; i++)</span><br><span class="line">        for(int j=0; j&lt;i; j++)</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                memo[i] = Math.max(memo[i], 1+memo[j]);</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, memo[i]);</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1143题解"><a href="#1143题解" class="headerlink" title="1143题解"></a>1143题解</h3><ul><li>dp<ul><li>1143 Longest Common Subsequence：<a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-subsequence/</a><ul><li>LCS：找两个字符串的最长公共子序列的长度</li><li>Input: text1 = “abcde”, text2 = “ace” </li><li>Output: 3  </li><li>Explanation: The longest common subsequence is “ace” and its length is 3.</li></ul></li><li>Key<ul><li>状态：f(m,n)表示两个字符串s1[0…m]，s2[0…n]的LCS长度</li><li>状态转移方程：若s1[m]==s2[n] 则f(m,n)=1+f(m-1,n-1)，若s1[m]!=s2[n] 则f(m,n)=max( f(m-1,n), f(m,n-1) )</li></ul></li><li>思路1：记忆化搜索</li><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int[][] memo;</span><br><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    assert text1!=null &amp;&amp; text2!=null;</span><br><span class="line">    if(text1.length()==0 || text2.length()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    memo = new int[text1.length()][text2.length()];</span><br><span class="line">    for(int i=0; i&lt;text1.length(); i++)</span><br><span class="line">        Arrays.fill(memo[i], -1);</span><br><span class="line">    return lcs(text1, text2, text1.length()-1, text2.length()-1);</span><br><span class="line">&#125;</span><br><span class="line">// 求s1[0...m]和s2[0...n]的最长公共子序列的长度</span><br><span class="line">private int lcs(String s1, String s2, int m, int n)&#123;</span><br><span class="line">    if(m&lt;0 || n&lt;0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[m][n] != -1)</span><br><span class="line">        return memo[m][n];</span><br><span class="line">    int max = 0;</span><br><span class="line">    if(s1.charAt(m)==s2.charAt(n))</span><br><span class="line">        max = 1 + lcs(s1, s2, m-1, n-1);</span><br><span class="line">    else</span><br><span class="line">        max = Math.max(lcs(s1, s2, m-1, n), lcs(s1, s2, m, n-1));</span><br><span class="line">    memo[m][n] =max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划</li><li>时间复杂度：O(m*n)</li><li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int m = text1.length();</span><br><span class="line">    int n = text2.length();</span><br><span class="line">    int memo[][] = new int[m][n];</span><br><span class="line">    // init</span><br><span class="line">    for(int i=0; i&lt;m; i++)</span><br><span class="line">        if(text1.charAt(i)==text2.charAt(0))&#123;</span><br><span class="line">            for(int j=i; j&lt;m; j++)</span><br><span class="line">                memo[j][0] = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=0; i&lt;n; i++)</span><br><span class="line">        if(text1.charAt(0)==text2.charAt(i))&#123;</span><br><span class="line">            for(int j=i; j&lt;n; j++)</span><br><span class="line">                memo[0][j] = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    // dp</span><br><span class="line">    for(int i=1; i&lt;m; i++)</span><br><span class="line">        for(int j=1; j&lt;n; j++)</span><br><span class="line">            if(text1.charAt(i) == text2.charAt(j))</span><br><span class="line">                memo[i][j] = 1 + memo[i-1][j-1];</span><br><span class="line">            else</span><br><span class="line">                memo[i][j] = Math.max(memo[i-1][j], memo[i][j-1]);</span><br><span class="line">    return memo[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>greedy</strong></p><h3 id="455题解"><a href="#455题解" class="headerlink" title="455题解"></a>455题解</h3><ul><li>greedy<ul><li>455 Assign Cookies：<a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">https://leetcode.com/problems/assign-cookies/</a><ul><li>分饼干，s为饼干大小，g为满意的最小值，返回最多可以让几个小朋友开心</li><li>Input: g=[1,2,3], s=[1,1]</li><li>Output: 1</li></ul></li><li>思路：贪心，最大的饼干满足最贪的小朋友</li><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">    int gi = g.length-1, si = s.length-1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while(gi&gt;=0 &amp;&amp; si&gt;=0) &#123;</span><br><span class="line">        if(s[si] &gt;= g[gi]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            si--;</span><br><span class="line">            gi--;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            gi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="435题解"><a href="#435题解" class="headerlink" title="435题解"></a>435题解</h3><ul><li>greedy<ul><li>435 Non-overlapping Intervals：<a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/non-overlapping-intervals/</a><ul><li>给定一个区间，问最少删除多少个区间，可以让这些区间之间不重叠</li><li>Input: [[1,2],[2,3],[3,4],[1,3]]</li><li>Output: 1</li></ul></li><li>思路：贪心，选择区间结尾最早的且和前面不重叠</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">    if(intervals.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结尾早的靠前</span><br><span class="line">    Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            if (o1[1] != o2[1]) &#123;</span><br><span class="line">                return o1[1] - o2[1];</span><br><span class="line">            &#125;</span><br><span class="line">            return o1[0] - o2[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int count = 1;</span><br><span class="line">    int pre = 0;</span><br><span class="line">    for(int i=1; i&lt;intervals.length; i++) &#123;</span><br><span class="line">        if(intervals[i][0] &gt;= intervals[pre][1]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：动态规划</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">    if(intervals.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            if (o1[0] != o2[0]) &#123;</span><br><span class="line">                return o1[0] - o2[0];</span><br><span class="line">            &#125;</span><br><span class="line">            return o1[1] - o2[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // memo[i] 表示使用 intervals[0...i] 的区间能构成的最长不重叠区间序列的长度；</span><br><span class="line">    int[] memo = new int[intervals.length];</span><br><span class="line">    Arrays.fill(memo, 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= intervals[j][1]) &#123;</span><br><span class="line">                memo[i] = Math.max(memo[i], 1 + memo[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = 0; i &lt; memo.length; i++) &#123;</span><br><span class="line">        count = Math.max(count, memo[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>backtracking</strong></p><h3 id="17题解"><a href="#17题解" class="headerlink" title="17题解"></a>17题解</h3><ul><li>17题解<ul><li>17 Letter Combinations of a Phone Number：<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a><ul><li>返回数字字符串的所有字母组合</li><li>Input: “23”</li><li>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private String[] letterMap = &#123;</span><br><span class="line">        &quot; &quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;abc&quot;,</span><br><span class="line">        &quot;def&quot;,</span><br><span class="line">        &quot;ghi&quot;,</span><br><span class="line">        &quot;jkl&quot;,</span><br><span class="line">        &quot;mno&quot;,</span><br><span class="line">        &quot;pqrs&quot;,</span><br><span class="line">        &quot;tuv&quot;,</span><br><span class="line">        &quot;wxyz&quot;</span><br><span class="line">&#125;;</span><br><span class="line">private ArrayList&lt;String&gt; resultList;</span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">    resultList = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (digits.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    findCombination(digits, 0, &quot;&quot;);</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br><span class="line">// s保存从digits[0...index-1]的字符串</span><br><span class="line">private void findCombination(String digits, int index, String s) &#123;</span><br><span class="line">    if (index==digits.length()) &#123;</span><br><span class="line">        resultList.add(s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Character c = digits.charAt(index);</span><br><span class="line">    String letters = letterMap[c-&apos;0&apos;];</span><br><span class="line">    for (int i=0; i&lt;letters.length(); i++) &#123;</span><br><span class="line">        findCombination(digits, index+1, s+letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="46题解"><a href="#46题解" class="headerlink" title="46题解"></a>46题解</h3><ul><li>backtracking<ul><li>46 Permutations：<a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><ul><li>求数组的全排列</li><li>Input: [1,2,3]</li><li>Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li></ul></li><li>思路：回溯法，Perms(nums)={取出一个数字}+Perms(nums-这个数字)</li><li>时间复杂度：O(n^n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">private boolean[] used;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(nums.length == 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    used = new boolean[nums.length];</span><br><span class="line">    generatePerm(nums, 0, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void generatePerm(int[] nums, int index, LinkedList&lt;Integer&gt; p) &#123;</span><br><span class="line">    if(index == nums.length) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;) p.clone());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        // used[i]没有被使用</span><br><span class="line">        if(!used[i]) &#123;</span><br><span class="line">            p.addLast(nums[i]);</span><br><span class="line">            used[i] = true;</span><br><span class="line">            generatePerm(nums, index+1, p);</span><br><span class="line">            p.removeLast();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="77题解"><a href="#77题解" class="headerlink" title="77题解"></a>77题解</h3><ul><li>backtracking<ul><li>77 Combinations：<a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/combinations/</a><ul><li>在n个数字中选出k个数字的所有组合</li><li>Input: n = 4, k = 2</li><li>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</li></ul></li><li>思路：回溯法</li><li>时间复杂度：O(n^k)</li><li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(n&lt;=0 || k&lt;=0 || k&gt;n) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateCombinations(n, k, 1, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void generateCombinations(int n, int k, int start, LinkedList&lt;Integer&gt; c) &#123;</span><br><span class="line">    if(c.size() == k) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;)c.clone());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=start; i&lt;=n; i++) &#123;</span><br><span class="line">        c.addLast(i);</span><br><span class="line">        generateCombinations(n, k, i+1, c);</span><br><span class="line">        c.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>优化：剪枝<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || k&lt;=<span class="number">0</span> || k&gt;n) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateCombinations(n, k, <span class="number">1</span>, <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCombinations</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.size() == k) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;)c.clone());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有k-c.size()个空位，所以，[i...n]中至少有k-c.size()个元素</span></span><br><span class="line">    <span class="comment">// i最多为n-(k-c.size())+1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=n-(k-c.size())+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        c.addLast(i);</span><br><span class="line">        generateCombinations(n, k, i+<span class="number">1</span>, c);</span><br><span class="line">        c.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="79题解"><a href="#79题解" class="headerlink" title="79题解"></a>79题解</h3><ul><li>backtracking<ul><li>79 Word Search：<a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a><ul><li>查询二维字符数组中，连起来是否有word</li><li>Input: board=[[‘A’,’B’,’C’,’E’],[‘S’,’F’,’C’,’S’],[‘A’,’D’,’E’,’E’]]，word=”ABCCED”</li><li>Output: true</li></ul></li><li>思路：回溯法，递归树中搜索上下左右四个方向</li><li>时间复杂度：O(m<em>n</em>m*n)</li><li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private boolean[][] visited;</span><br><span class="line">private int[][] d = &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int m, n;</span><br><span class="line">public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[0].length;</span><br><span class="line">    visited = new boolean[m][n];</span><br><span class="line">    for(int i=0; i&lt;m; i++) &#123;</span><br><span class="line">        for(int j=0; j&lt;n; j++) &#123;</span><br><span class="line">            if(searchWord(board, word, 0, i, j) == true) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">private boolean searchWord(char[][] board, String word, int index, int startx, int starty) &#123;</span><br><span class="line">    if(index == word.length()-1) &#123;</span><br><span class="line">        return board[startx][starty] == word.charAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">    if(board[startx][starty] == word.charAt(index)) &#123;</span><br><span class="line">        visited[startx][starty] = true;</span><br><span class="line">        // 向四个方向寻找</span><br><span class="line">        for(int i=0; i&lt;4; i++) &#123;</span><br><span class="line">            int newx = startx + d[i][0];</span><br><span class="line">            int newy = starty + d[i][1];</span><br><span class="line">            if(inArea(newx, newy) &amp;&amp; !visited[newx][newy]) &#123;</span><br><span class="line">                if(searchWord(board, word, index+1, newx, newy) == true) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[startx][starty] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">private boolean inArea(int x, int y) &#123;</span><br><span class="line">    return x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="200题解"><a href="#200题解" class="headerlink" title="200题解"></a>200题解</h3><ul><li>backtracking<ul><li>200 Number of Islands：<a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a><ul><li>二维数组中查找岛屿的个数，值为1</li><li>Input: [[11110][11010][11000][00000]]</li><li>Output: 1</li></ul></li><li>思路：回溯法，递归树中搜索上下左右四个方向</li><li>时间复杂度：O(n*m)</li><li>空间复杂度：O(n*m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private boolean[][] visited;</span><br><span class="line">private int[][] d = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">private int m, n;</span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">    if(grid.length==0 || grid[0].length==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[0].length;</span><br><span class="line">    visited = new boolean[m][n];</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i=0; i&lt;m; i++) &#123;</span><br><span class="line">        for(int j=0; j&lt;n; j++) &#123;</span><br><span class="line">            if(grid[i][j]==&apos;1&apos; &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void dfs(char[][] grid, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for(int i=0; i&lt;4; i++) &#123;</span><br><span class="line">        int newx = x + d[i][0];</span><br><span class="line">        int newy = y + d[i][1];</span><br><span class="line">        if(inArea(newx, newy) &amp;&amp; grid[newx][newy]==&apos;1&apos; &amp;&amp;!visited[newx][newy]) &#123;</span><br><span class="line">            dfs(grid, newx, newy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean inArea(int x, int y)&#123;</span><br><span class="line">    return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="51题解"><a href="#51题解" class="headerlink" title="51题解"></a>51题解</h3><ul><li>backtracking<ul><li>51 N Queens：<a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode.com/problems/n-queens/</a><ul><li>n皇后问题的所有解，在横竖斜方向都不会有两个皇后</li><li>Input: 4</li><li>Output: [[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</li></ul></li><li>思路：回溯法</li><li>时间复杂度：O(n^n)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private boolean[] col;</span><br><span class="line">private boolean[] dia1;</span><br><span class="line">private boolean[] dia2;</span><br><span class="line">private ArrayList&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    col = new boolean[n];</span><br><span class="line">    dia1 = new boolean[2*n-1];</span><br><span class="line">    dia2 = new boolean[2*n-1];</span><br><span class="line"></span><br><span class="line">    putQueen(n, 0, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void putQueen(int n, int index, LinkedList&lt;Integer&gt; row)&#123;</span><br><span class="line">    if(index == n) &#123;</span><br><span class="line">        res.add(generateBoard(n, row));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        if(!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) &#123;</span><br><span class="line">            row.addLast(i);</span><br><span class="line">            col[i] = true;</span><br><span class="line">            dia1[index+i] = true;</span><br><span class="line">            dia2[index-i+n-1] = true;</span><br><span class="line">            putQueen(n, index+1, row);</span><br><span class="line">            col[i] = false;</span><br><span class="line">            dia1[index + i] = false;</span><br><span class="line">            dia2[index - i + n - 1] = false;</span><br><span class="line">            row.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">private List&lt;String&gt; generateBoard(int n, LinkedList&lt;Integer&gt; row) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; board = new ArrayList&lt;String&gt;();</span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        char[] chars = new char[n];</span><br><span class="line">        Arrays.fill(chars, &apos;.&apos;);</span><br><span class="line">        chars[row.get(i)] = &apos;Q&apos;;</span><br><span class="line">        board.add(new String(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    return board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思想-滑动窗口类经典题</title>
      <link href="2019/12/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
      <url>2019/12/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul><li><a href="#滑动窗口">滑动窗口</a><ul><li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a>：<a href="#209题解">【209题解】</a><br><img src="/images/algo/window/minimum-size.gif" alt=""></li><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a>：<a href="#3题解">【3题解】</a><br><img src="/images/algo/window/longest-substring.gif" alt=""></li></ul></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209题解"><a href="#209题解" class="headerlink" title="209题解"></a>209题解</h3><ul><li>209题解<ul><li>209 Minimum Size Subarray Sum：<a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-size-subarray-sum/</a><ul><li>求最短子序和sum&lt;=s</li><li>Input: s = 7, nums = [2,3,1,2,4,3]</li><li>Output: 2</li><li>注意：子数组是否连续？没有解怎么办？</li></ul></li><li>思路1：两次遍历：求往后的和值达到要求的长度最小能为多少（包含了大量的重复计算）</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两次遍历：求往后的和值达到要求的长度最小能为多少</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= s) &#123;</span><br><span class="line">                min = Math.min(min, j-i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min==Integer.MAX_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：滑动窗口（维护nums[i…j]，如果sum比s小 sum += nums[++j]，否则sum -= nums[i++]）</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边界不包含任何元素</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>, r=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span>&lt;nums.length &amp;&amp; sum &lt; s) &#123;</span><br><span class="line">            <span class="comment">// 需判断是否越界</span></span><br><span class="line">            sum += nums[++r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= s) &#123;</span><br><span class="line">            min = Math.min(min, r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果判断，如果没找到为0</span></span><br><span class="line">    <span class="keyword">if</span>(min == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3题解"><a href="#3题解" class="headerlink" title="3题解"></a>3题解</h3><ul><li>3题解<ul><li>3 Longest Substring Without Repeating Characters：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a><ul><li>求字符串不重复子串的最长值</li><li>Input: “abcabcbb”</li><li>Output: 3</li><li>Explanation: The answer is “abc”, with the length of 3.</li></ul></li><li>思路：滑动窗口，使用freq[256]记录重复字符</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(len(charset))<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 滑动窗口为s[l...r]</span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>, r=-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录字符频率</span></span><br><span class="line">    <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 右边界往前移动</span></span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span>&lt;s.length() &amp;&amp; freq[s.charAt(r+<span class="number">1</span>)]==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 需判断数组下标是否越界</span></span><br><span class="line">            freq[s.charAt(++r)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            freq[s.charAt(l++)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析-ThreeSum</title>
      <link href="2019/12/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-ThreeSum/"/>
      <url>2019/12/01/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-ThreeSum/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreeSum问题"><a href="#ThreeSum问题" class="headerlink" title="ThreeSum问题"></a>ThreeSum问题</h2><ul><li>问题定义：找出数组中使得A+B+C=0的组合数量</li><li>接口定义：ThreeSum interface<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计数组中和为0的三元组的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 统计个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countZero</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ThreeSum题解"><a href="#ThreeSum题解" class="headerlink" title="ThreeSum题解"></a>ThreeSum题解</h2><ul><li>复杂度排序：logn &lt; n &lt; nlogn &lt; n^2 &lt; n^2logn &lt; n^3</li></ul><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumBrute</span> <span class="keyword">implements</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路1：暴力解法，直接for循环三次</span></span><br><span class="line"><span class="comment">     * 复杂度：O(n^3)、O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countZero</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环三次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;nums.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二分搜索"><a href="#2-二分搜索" class="headerlink" title="2. 二分搜索"></a>2. 二分搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumBinarySearch</span> <span class="keyword">implements</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路2：二分搜索，不含重复元素时可用</span></span><br><span class="line"><span class="comment">     * 复杂度：O(n^2logn)、O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countZero</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 循环两次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> target = nums[i]+nums[j];</span><br><span class="line">                <span class="comment">// 二分查找-(A+B)</span></span><br><span class="line">                <span class="keyword">int</span> index = binarySearch(nums, <span class="number">0</span>-target);</span><br><span class="line">                <span class="comment">// index不能在j前面，不然会重复统计</span></span><br><span class="line">                <span class="keyword">if</span>(index &gt; j) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-双指针"><a href="#3-双指针" class="headerlink" title="3. 双指针"></a>3. 双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumTwoPointer</span> <span class="keyword">implements</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路3：双指针，适用于无重复</span></span><br><span class="line"><span class="comment">     * 复杂度：O(n^2)、O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countZero</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 循环两次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l=i+<span class="number">1</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="comment">// 双指针寻找target</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">                <span class="comment">// 找到target，l++，r--</span></span><br><span class="line">                <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比target小，l++</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 比target大，r--</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试指南-imooc</title>
      <link href="2019/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-imooc/"/>
      <url>2019/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="四、MySQL面试指南"><a href="#四、MySQL面试指南" class="headerlink" title="四、MySQL面试指南"></a>四、MySQL面试指南</h2><h3 id="Ch1-课程介绍"><a href="#Ch1-课程介绍" class="headerlink" title="Ch1-课程介绍"></a>Ch1-课程介绍</h3><ul><li>面试要求<ul><li>熟悉MySQL数据库设计、使用及优化</li></ul></li><li>课程内容<ul><li>版本、用户管理、服务器配置、日志、存储引擎、架构、备份恢复、管理监控、异常处理</li></ul></li></ul><h3 id="Ch2-MySQL版本类问题"><a href="#Ch2-MySQL版本类问题" class="headerlink" title="Ch2-MySQL版本类问题"></a>Ch2-MySQL版本类问题</h3><ul><li>版本类问题<ul><li>为什么选择某一发行版本</li><li>各种版本之间的缺点和优点</li><li>如何对MySQL进行升级</li></ul></li><li>MySQL发行版本对比<ul><li>MySQL官方版</li><li>Percona MySQL</li><li>MariaDB</li></ul></li><li>MySQL8.0版本的新特性<ul><li>服务器功能：无frm文件、支持资源管理组、窗口函数…</li><li>用户安全功能：默认使用caching_sha2_password认证插件</li><li>InnoDB功能：DDL语句支持原子操作 </li></ul></li></ul><h3 id="Ch3-用户管理类问题"><a href="#Ch3-用户管理类问题" class="headerlink" title="Ch3-用户管理类问题"></a>Ch3-用户管理类问题</h3><ul><li>用户管理类问题<ul><li>给定场景下对用户授权</li><li>数据库帐号的安全</li><li>如何迁移数据库帐号</li></ul></li><li>MySQL数据库账号定义<ul><li><code>用户名@可访问控制列表</code>：%表示所有IP</li></ul></li><li>用户授权<ul><li><code>Grant</code>命令授权</li></ul></li></ul><h3 id="Ch4-服务器配置类问题"><a href="#Ch4-服务器配置类问题" class="headerlink" title="Ch4-服务器配置类问题"></a>Ch4-服务器配置类问题</h3><ul><li>服务器配置类问题<ul><li>SQLMode的影响</li><li>对比运行时配制</li><li>MySQL关键参数</li></ul></li><li>分析一个Group By语句的异常原因<ul><li>SQL_Mode：配置MySQL处理SQL的方式（ONLY_FULL_GROUP_BY）</li></ul></li><li>比较系统运行配置和配置文件中的配置<ul><li>使用set配置动态参数，修改系统配置</li><li>使用pt-config-diff工具比较配置文件</li></ul></li><li>常用的性能参数<ul><li><code>max_connections</code>：最大连接数</li></ul></li></ul><h3 id="Ch5-日志类问题"><a href="#Ch5-日志类问题" class="headerlink" title="Ch5-日志类问题"></a>Ch5-日志类问题</h3><ul><li>日志类问题<ul><li>常用MySQL日志有哪些，在什么情况下使用？</li><li>如何通过日志来审计用户活动</li></ul></li><li>常用日志类型<ul><li>错误日志</li><li>常规日志</li><li>慢查询日志</li><li>二进制日志</li><li>中继日志</li></ul></li></ul><h3 id="Ch6-存储引擎类问题"><a href="#Ch6-存储引擎类问题" class="headerlink" title="Ch6-存储引擎类问题"></a>Ch6-存储引擎类问题</h3><ul><li>存储引擎类问题<ul><li>说说你了解MySQL存储引擎及其适用场景</li><li>在什么情况下InnoDB无法在线修改表结构</li><li>无法在线修改表结构时，要如何操作 </li><li>Innodb是如何实现事务的</li><li>InnoDB读操作是否会阻塞写操作（InnoDB MVCC实现方式）</li></ul></li><li>常用存储引擎<ul><li>MyISAM、CSV、Archive、Memory、Innodb、NDB</li></ul></li><li>InnoDB不支持在线修改表结构的场景<ul><li>加全文索引、加空间索引、删除主键…</li></ul></li><li>如何更安全的在线修改表结构<ul><li><code>pt-online-schema-change [options] dsn</code></li></ul></li><li>Innodb是如何实现事务的<ul><li>原子性(A)：回滚日志</li><li>一致性(C)：重作日志</li><li>隔离性(I)：锁，用于资源隔离，分为共享锁和排它锁</li><li>持久性(D)：重作日志+回滚日志</li></ul></li><li>InnoDB MVCC实现方式<ul><li>InnoDB查询对资源加共享锁(S)，修改加排它锁(x)</li><li>MVCC（多版本并发控制）：通过加共享锁和排它锁实现</li></ul></li></ul><h3 id="Ch7-MySQL架构类问题"><a href="#Ch7-MySQL架构类问题" class="headerlink" title="Ch7-MySQL架构类问题"></a>Ch7-MySQL架构类问题</h3><ul><li>高可用架构类问题<ul><li>MySQL的主从复制是如何工作的</li><li>比较基于GTID方式的复制和基于日志点的复制</li><li>比较MMM和MHA两种高可用架构的优缺点</li><li>如何减少主从复制延迟</li><li>如何使用MGR集群</li><li>如何解决数据库读/写负载大的问题</li></ul></li><li>MySQL主从复制的实现原理<ul><li>MySQL异步复制</li><li>MySQL半同步复制</li><li>MySQL主从复制的配置步骤</li></ul></li><li>主从复制的方式<ul><li>基于日志点的复制</li><li>基于GTID的复制</li><li>两种复制方式的对比</li></ul></li><li>MMM和MHA两种高可用复制架构<ul><li>MMM架构</li><li>MHA架构</li></ul></li><li>减少主从复制延迟</li><li>MGR复制</li><li>解决数据库读/写负载大的问题</li></ul><h3 id="Ch8-备份恢复类问题"><a href="#Ch8-备份恢复类问题" class="headerlink" title="Ch8-备份恢复类问题"></a>Ch8-备份恢复类问题</h3><ul><li>备份恢复类问题<ul><li>数据库备份的种类</li><li>常用备份工具的使用方法</li><li>如何对数据库进行全量备份和增量备份</li><li>如何恢复数据库备份</li></ul></li></ul><h3 id="Ch9-管理及监控类问题"><a href="#Ch9-管理及监控类问题" class="headerlink" title="Ch9-管理及监控类问题"></a>Ch9-管理及监控类问题</h3><ul><li>管理及监控类问题<ul><li>如何监控死锁</li><li>如何监控慢查询</li><li>如何监控主从延迟</li><li>如何监控主从状态</li></ul></li></ul><h3 id="Ch10-异常处理类问题"><a href="#Ch10-异常处理类问题" class="headerlink" title="Ch10-异常处理类问题"></a>Ch10-异常处理类问题</h3><ul><li>优化及异常处理类问题<ul><li>CPU负载过大问题的分析和处理</li><li>IO负载过大问题的分析和处理</li><li>如何解决主从数据不一致问题</li><li>如何解决复制中的主键冲突</li><li>如何解决RelayLog故障</li><li>数据库优化概论</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL电商项目-imooc</title>
      <link href="2019/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-imooc/"/>
      <url>2019/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="三、MySQL电商项目"><a href="#三、MySQL电商项目" class="headerlink" title="三、MySQL电商项目"></a>三、MySQL电商项目</h2><h3 id="Ch1-数据库开发规范的制定"><a href="#Ch1-数据库开发规范的制定" class="headerlink" title="Ch1-数据库开发规范的制定"></a>Ch1-数据库开发规范的制定</h3><h3 id="Ch2-电商实例数据库结构设计"><a href="#Ch2-电商实例数据库结构设计" class="headerlink" title="Ch2-电商实例数据库结构设计"></a>Ch2-电商实例数据库结构设计</h3><h3 id="Ch3-MySQL执行计划（explain）分析"><a href="#Ch3-MySQL执行计划（explain）分析" class="headerlink" title="Ch3-MySQL执行计划（explain）分析"></a>Ch3-MySQL执行计划（explain）分析</h3><h3 id="Ch4-MySQL数据库备份和恢复"><a href="#Ch4-MySQL数据库备份和恢复" class="headerlink" title="Ch4-MySQL数据库备份和恢复"></a>Ch4-MySQL数据库备份和恢复</h3><h3 id="Ch5-高性能高可用MySQL架构变迁"><a href="#Ch5-高性能高可用MySQL架构变迁" class="headerlink" title="Ch5-高性能高可用MySQL架构变迁"></a>Ch5-高性能高可用MySQL架构变迁</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库架构-imooc</title>
      <link href="2019/11/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84-imooc/"/>
      <url>2019/11/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="二、MySQL数据库架构"><a href="#二、MySQL数据库架构" class="headerlink" title="二、MySQL数据库架构"></a>二、MySQL数据库架构</h2><h3 id="Ch1-实例和故事"><a href="#Ch1-实例和故事" class="headerlink" title="Ch1-实例和故事"></a>Ch1-实例和故事</h3><ul><li>在双11大促中的数据库服务器<ul><li>和Web服务器的不同：一个可以做水平扩展（集群），另一个要保证完整性和一致性，不能做集群</li><li>数据库架构—1主15从：35万QPS、10万TPS（每秒处理的事务数目）</li><li>并发量vs同时连接数：连接不一定处理请求，大多数处于sleep状态</li><li>idle：CPU空闲百分比</li></ul></li><li>在大促中是什么影响了数据库性能<ul><li>超高的QPS和TPS：慢查询、低效率的SQL</li><li>大量的并发和超高的CPU使用率<ul><li>大并发会导致数据库连接数被占满，没连上会出现500错误</li><li>超高的CPU使用率会使资源耗尽而宕机</li></ul></li><li>磁盘IO性能突然下降：使用更快的磁盘设备、调整计划任务，如备份计划</li><li>网卡IO被占满：减少从服务器数量、进行分级缓存、避免使用select *、分离业务网络和服务器网络</li></ul></li><li>还有什么会影响数据库性能<ul><li>大表带来的问题（大表：行数超过千万行、数据超过10G）<ul><li>慢查询：很难在一定的时间内过滤出想要的数据</li><li>建立索引需要很长的时间</li><li>修改表结构需要长时间锁表</li></ul></li><li>如何处理大表<ul><li>分库分表，难点：分表主键的选择、分表后夸分区数据的查询和统计</li><li>归档历史数据，难点：归档时间点的选择、如何进行归档操作</li></ul></li><li>事务是什么<ul><li>事务：ACID，是数据库系统区别于文件系统的重要特性之一</li><li>原子性：转账操作的扣钱和加钱应该一起完成</li><li>一致性：转账前后的总金额应该一致</li><li>隔离性：扣钱时，如果要汇总账户金额，应汇总扣钱之前的余额<ul><li>四种隔离级别：未提交读（脏读）、已提交读、可重复读（InnoDB默认，即使另一个commit了也看不到操作，多次读SQL的结果是一样的） 、可串行化（读取的每一行数据都加锁）</li></ul></li><li>持久性：修改后永久保存到数据库</li></ul></li><li>大事务带来的问题（大事务：运行时间长、操作数据多，如余额宝）<ul><li>锁定太多数据，造成大量的阻塞和锁超时</li><li>回滚时所需的时间比较长</li><li>执行时间长，容易造成主从延迟</li></ul></li><li>如何处理大事务<ul><li>避免一次处理太多的数据（如一次处理1000个用户）</li><li>移除不必要在事务中的SELECT操作</li></ul></li></ul></li></ul><h3 id="Ch2-什么影响了MySQL性能"><a href="#Ch2-什么影响了MySQL性能" class="headerlink" title="Ch2-什么影响了MySQL性能"></a>Ch2-什么影响了MySQL性能</h3><h3 id="Ch3-MySQL基准测试"><a href="#Ch3-MySQL基准测试" class="headerlink" title="Ch3-MySQL基准测试"></a>Ch3-MySQL基准测试</h3><h3 id="Ch4-MySQL数据库结构优化"><a href="#Ch4-MySQL数据库结构优化" class="headerlink" title="Ch4-MySQL数据库结构优化"></a>Ch4-MySQL数据库结构优化</h3><h3 id="Ch5-MySQL高可用架构设计"><a href="#Ch5-MySQL高可用架构设计" class="headerlink" title="Ch5-MySQL高可用架构设计"></a>Ch5-MySQL高可用架构设计</h3><h3 id="Ch6-数据库索引优化"><a href="#Ch6-数据库索引优化" class="headerlink" title="Ch6-数据库索引优化"></a>Ch6-数据库索引优化</h3><h3 id="Ch7-SQL查询优化"><a href="#Ch7-SQL查询优化" class="headerlink" title="Ch7-SQL查询优化"></a>Ch7-SQL查询优化</h3><h3 id="Ch8-数据库的分库分表"><a href="#Ch8-数据库的分库分表" class="headerlink" title="Ch8-数据库的分库分表"></a>Ch8-数据库的分库分表</h3><h3 id="Ch9-数据库监控"><a href="#Ch9-数据库监控" class="headerlink" title="Ch9-数据库监控"></a>Ch9-数据库监控</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL8.0详解与实战-imooc</title>
      <link href="2019/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL8.0%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-imooc/"/>
      <url>2019/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL8.0%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL8-0详解与实战"><a href="#一、MySQL8-0详解与实战" class="headerlink" title="一、MySQL8.0详解与实战"></a>一、MySQL8.0详解与实战</h2><h3 id="Ch1-开篇引导"><a href="#Ch1-开篇引导" class="headerlink" title="Ch1-开篇引导"></a>Ch1-开篇引导</h3><ul><li>课程目标<ul><li>用SQL解决企业中存在的真实业务痛点问题</li></ul></li><li>课程大纲<ul><li>数据库选型<ul><li>NoSQL or SQL</li><li>各种数据存储系统的适用场景</li><li>构建MySQL开发环境</li></ul></li><li>数据库设计<ul><li>逻辑设计：范式化 vs 反范式化</li><li>物理设计</li><li>业务分析</li></ul></li><li>数据库访问<ul><li>MySQL驱动</li><li>访问故障处理</li></ul></li><li>SQL开发<ul><li>基本功：DCL&amp;DDL&amp;DML</li><li>必备技能：常用函数</li><li>高阶：CTE、窗口函数</li></ul></li><li>SQL优化<ul><li>分析执行计划</li><li>索引和SQL改写</li><li>排查性能瓶颈</li></ul></li><li>事务和高并发<ul><li>什么是事务</li><li>高并发的隐患</li><li>事务隔离级别</li><li>阻塞和死锁</li></ul></li></ul></li></ul><h3 id="Ch2-数据库选型"><a href="#Ch2-数据库选型" class="headerlink" title="Ch2-数据库选型"></a>Ch2-数据库选型</h3><ul><li>问题<ul><li>面对全新的业务场景，如何开展数据库选型？</li></ul></li><li>SQL vs NoSQL<ul><li>关系型数据库<ul><li>数据结构化存储在二维表中</li><li>支持事务的ACID（原子性、一致性、隔离性、持久性）</li><li>支持使用SQL进行数据操作</li></ul></li><li>关系型数据库适用场景<ul><li>数据之间存在着一定的关系，需要关联查询数据的场景</li><li>需要事务支持的业务场景</li><li>需要使用SQL语言灵活操作数据的场景</li></ul></li><li>非关系型数据库<ul><li>存储结构灵活，没有固定的结构</li><li>对事务的支持弱，但对数据的并发处理性能高</li><li>大多不使用SQL处理数据</li></ul></li><li>非关系型数据库适用场景<ul><li>数据结构不固定的场景</li><li>对事务要求不高，但读写并发比较大的场景</li><li>对数据处理操作比较简单的场景</li></ul></li></ul></li><li>关系型数据库选型原则<ul><li>数据库使用是否广泛</li><li>数据库的可扩展性</li><li>数据库的安全性和稳定性</li><li>数据库所支持的系统</li><li>数据库的使用成本</li></ul></li></ul><h3 id="Ch3-数据库设计"><a href="#Ch3-数据库设计" class="headerlink" title="Ch3-数据库设计"></a>Ch3-数据库设计</h3><ul><li>业务分析<ul><li>一般步骤：业务分析 -&gt; 逻辑设计 -&gt; 数据类型 -&gt; 对象命名 -&gt; 建立库表</li><li>慕课网前端数据库结构设计</li><li>总结所需的属性（课程的属性、课程列表、讲师、评论、笔记、用户、评价）</li></ul></li><li>逻辑设计<ul><li>逻辑设计之宽表模式：设计到一张大表中，有很多列<ul><li>宽表模式问题：数据冗余、数据更新异常（修改一行的值，同时修改了多行），插入异常（缺失主键而无法插入表），删除异常（删除时必须删除另一数据）</li><li>宽表模式适用场景：配合列存储的数据报表应用</li></ul></li><li>逻辑设计之数据库设计范式<ul><li>第一范式：表中的所有字段都是不可再分的<ul><li>联系方式字段，有手机、邮箱、微信</li></ul></li><li>第二范式：表中必须存在主键，并且非主键依赖于全部的主键<ul><li>笔记表中，用户积分不依赖于符合主键（用户+章节+标题）</li></ul></li><li>第三范式：表中的非主键列之间不能相互依赖<ul><li>课程表中，讲师职位依赖于讲师名</li></ul></li></ul></li><li>面向对象设计<ul><li>课程对象逻辑建模：课程表、课程方向表、课程分类表、课程难度表</li><li>课程列表对象逻辑建模：章节表、小节表、课程同章节关联表、章节同小节关联表（删除关联表，反范式化设计）</li><li>用户对象逻辑建模：用户表、讲师表合并（讲师标识字段）</li><li>问答评论对象逻辑建模：问答评论表</li><li>笔记对象逻辑建模：笔记表</li><li>课程评价对象逻辑建模：评价表、用户选课表</li></ul></li><li>范式化设计存在的问题<ul><li>如何获取出一门课程包括的所有章节和小节信息（需要5张表：课程表、章节表、小节表、课程同章节关联表、章节同小节关联表）</li></ul></li><li>反范式化设计：减少查询时所需要关联表的数量，以提高查询性能<ul><li>课程表和章节表是一对多的关系：所以可以合并{课程主标题、课程章节名、章节说明、章节编号}，虽然违反第二范式，但是可以少关联表</li><li>章节表和小节表也是一对多的关系：合并</li><li>现在，只需要3章节就可以查询信息：课程表、章节表、小节表</li></ul></li></ul></li><li>物理设计<ul><li>MySQL常见的存储引擎<ul><li>MyISAM：不支持事务，MySQL5.6之前的默认引擎</li><li>InnoDB：最常用的事务型存储引擎</li><li>CSV：不支持事务，以CSV格式存储</li><li>Archive：不支持事务，只允许查询和新增数据而不允许修改</li><li>Memory：不支持事务，存储在内存中，容易丢失数据</li></ul></li><li>InnoDB存储引擎的特点<ul><li>支持ACID</li><li>数据按主键聚集存储</li><li>支持行级锁及MVCC（多版本并发控制）</li><li>支持BTree和自适应Hash索引</li><li>支持全文和空间索引</li></ul></li><li>根据InnoDB特性优化表逻辑结构<ul><li>课程表：新增课程ID（自增ID）</li><li>章节表：新增章节ID</li><li>小节表：新增小节ID</li></ul></li><li>常用的数据类型<ul><li>整数类型：<code>tinyint、smallint、mediumint、int、bigint（-2^7~2^7-1）</code></li><li>浮点类型：<code>float、double、decimal（精确类型）</code></li><li>时间类型：<code>date、time、year、datetime、timestamp（时区）</code></li><li>字符串类型：<code>char、varchar、tinytext、text、mediumtext、longtext、enum</code></li></ul></li><li>为列选择合适的数据类型<ul><li>优先选择符合存储数据需求的最小数据类型<ul><li>举例：字符串转整数存储，如IP地址：<code>inet_aton(&#39;255.255.255.255&#39;) = 4294967295</code></li></ul></li><li>谨慎使用text、enum字符串类型<ul><li>text：内存临时表不支持大数据类型</li><li>enum：转为整数存储的</li></ul></li><li>同财务相关的数值型数据，必须使用decimal类型</li></ul></li><li>回归项目的物理设计<ul><li>课程表字段的数据类型选择：课程ID选int unsigned，时长time</li><li>章节表字段的数据类型选择：章节ID选int unsigned，章节编号tinyint(2) unsigned</li><li>小节表字段的数据类型选择：小节ID选int unsigned，视频格式enum(‘avi’,’mp4’,’mpeg’)</li><li>课程分类表字段的数据类型选择：课程分类ID选smallint unsigned</li><li>用户表字段的数据类型选择：密码选char(32)、性别选char(2)，说明varchar(100)</li><li>问答评论表字段的数据类型选择：评论内容text</li></ul></li><li>数据库对象命名规则<ul><li>名称必须使用小写字母，可选用下划线分割</li><li>禁止使用保留关键字</li><li>命名应见名识义，不超过32个字符</li><li>临时表必须以tmp为前缀，并以日期为后缀</li><li>用于备份的库，表必须以bak为前缀，并以日期为后缀</li><li>所有存储相同数据的列名和列类型必须一致</li></ul></li><li>项目的库、表和列命名</li></ul></li></ul><h3 id="Ch4-数据库访问"><a href="#Ch4-数据库访问" class="headerlink" title="Ch4-数据库访问"></a>Ch4-数据库访问</h3><h3 id="Ch5-SQL开发"><a href="#Ch5-SQL开发" class="headerlink" title="Ch5-SQL开发"></a>Ch5-SQL开发</h3><h3 id="Ch6-SQL优化"><a href="#Ch6-SQL优化" class="headerlink" title="Ch6-SQL优化"></a>Ch6-SQL优化</h3><h3 id="Ch7-事务和高并发"><a href="#Ch7-事务和高并发" class="headerlink" title="Ch7-事务和高并发"></a>Ch7-事务和高并发</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-算法思想</title>
      <link href="2019/10/25/%E7%AE%97%E6%B3%95/leetcode/LeetCode-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>2019/10/25/%E7%AE%97%E6%B3%95/leetcode/LeetCode-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-数据结构</title>
      <link href="2019/10/22/%E7%AE%97%E6%B3%95/leetcode/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2019/10/22/%E7%AE%97%E6%B3%95/leetcode/LeetCode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>数据结构<ul><li><a href="#stack">stack</a></li><li><a href="#queue">queue</a></li><li><a href="#linkedlist">linkedlist</a></li><li><a href="#binarytree">binarytree</a></li><li><a href="#collection">collection</a></li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><ul><li>栈<ul><li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses</a>：<a href="#20题解">【20题解】</a> </li><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a>：<a href="#144题解">【144题解】</a></li></ul></li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li>队列<ul><li><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. Top K Frequent Elements</a>：<a href="#347题解">【347题解】</a></li></ul></li></ul><h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><ul><li>链表<ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a>：<a href="#206题解">【206题解】</a></li><li><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements</a>：<a href="#203题解">【203题解】</a></li><li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs</a>：<a href="#24题解">【24题解】</a></li><li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List</a>：<a href="#237题解">【237题解】</a></li><li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a>：<a href="#19题解">【19题解】</a></li><li>more</li><li><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a>：<a href="#234题解">【234题解】</a></li></ul></li></ul><h3 id="binarytree"><a href="#binarytree" class="headerlink" title="binarytree"></a>binarytree</h3><ul><li>二叉树<ul><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a>：<a href="#104题解">【104题解】</a></li><li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a>：<a href="#111题解">【11题解】</a></li><li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert Binary Tree</a>：<a href="#226题解">【226题解】</a></li><li><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a>：<a href="#112题解">【112题解】</a></li><li><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths</a>：<a href="#257题解">【257题解】</a></li><li><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a>：<a href="#437题解">【437题解】</a></li><li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a>：<a href="#235题解">【235题解】</a></li><li>more</li><li><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a>：<a href="#100题解">【100题解】</a></li><li><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a>：<a href="#101题解">【101题解】</a></li><li><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. Count Complete Tree Nodes</a>：<a href="#222题解">【222题解】</a></li><li><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. Balanced Binary Tree</a>：<a href="#110题解">【110题解】</a></li><li><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. Sum of Left Leaves</a>：<a href="#404题解">【404题解】</a></li><li><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a>：<a href="#113题解">【113题解】</a></li><li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a>：<a href="#129题解">【129题解】</a></li></ul></li></ul><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul><li>查找表<ul><li><a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. Intersection of Two Arrays</a>：<a href="#349题解">【349题解】</a></li><li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. Intersection of Two Arrays II</a>：<a href="#350题解">【350题解】</a></li><li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum</a>：<a href="#1题解-Map">【1题解-Map】</a></li><li><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 4Sum II</a>：<a href="#454题解">【454题解】</a></li><li><a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. Number of Boomerangs</a>：<a href="#447题解">【447题解】</a></li><li><a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. Contains Duplicate II</a>：<a href="#219题解">【219题解】</a></li><li><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contain Duplicate III</a>：<a href="#220题解">【220题解】</a></li><li>more</li><li><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram</a>：<a href="#242题解">【242题解】</a></li><li><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">202. Happy Number</a>：<a href="#202题解">【202题解】</a></li><li><a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">290. Word Pattern</a>：<a href="#290题解">【290题解】</a></li><li><a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">804. Unique Morse Code Words</a>：<a href="#804题解">【804题解】</a></li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>stack</strong></p><h3 id="20题解"><a href="#20题解" class="headerlink" title="20题解"></a>20题解</h3><ul><li>stack<ul><li>20 Valid Parentheses：<a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a><ul><li>判断括号是否匹配</li><li>Input: “()[]{}”</li><li>Output: true</li></ul></li><li>思路：栈（只关心最近一次操作）</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历string</span></span><br><span class="line">    <span class="comment">// -- 如果是左括号，压入栈</span></span><br><span class="line">    <span class="comment">// -- 如果是右括号，弹出栈</span></span><br><span class="line">    <span class="comment">// ---- 如果不匹配，返回false</span></span><br><span class="line">    <span class="comment">// ---- 如果for结束，栈不为空，返回false</span></span><br><span class="line">    <span class="comment">// ---- 否则，返回true</span></span><br><span class="line">    </span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] matchs = &#123;<span class="string">'('</span>, <span class="string">'&#123;'</span>, <span class="string">'['</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// s.charAt(i) (</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'('</span> || s.charAt(i)==<span class="string">'&#123;'</span> || s.charAt(i)==<span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(s.charAt(i));    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 【Runtime Error："]"】没有进行size为0的判断</span></span><br><span class="line">            <span class="keyword">if</span>(stack.size()==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = stack.pop();</span><br><span class="line">            <span class="keyword">char</span> match;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">')'</span>) &#123;</span><br><span class="line">                match = matchs[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                match = matchs[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                match = matchs[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(c != match) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="144题解"><a href="#144题解" class="headerlink" title="144题解"></a>144题解</h3><ul><li>stack<ul><li>144 Binary Tree Preorder Traversal：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-preorder-traversal/</a><ul><li>二叉树的前序遍历</li><li>Input: binary tree [1,2,3]</li><li>Output: [1,2,3]</li></ul></li><li>思路1：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归解法：根节点-&gt;左节点-&gt;右节点</span></span><br><span class="line">    <span class="comment">// 要返回List，所以需要辅助函数来做递归</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    preorderTraversal(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorderTraversal(root.left, res);</span><br><span class="line">    preorderTraversal(root.right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：非递归（栈+Command）</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非递归解法：栈（递归的本质是栈）</span></span><br><span class="line">    <span class="comment">// 把第一个指令go-root压入栈，while循环直到stack为空</span></span><br><span class="line">    <span class="comment">// -- 如果指令是print，把command.node的值add进List</span></span><br><span class="line">    <span class="comment">// -- 否则指令就是go，把指令倒序压入stack：print-root, go-left, go-right</span></span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 【Runtime Error: []】没有进行非空判断</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;Command&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, root));</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty()) &#123;</span><br><span class="line">        <span class="comment">// 取出栈顶元素</span></span><br><span class="line">        Command command = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(command.s == <span class="string">"print"</span>) &#123;</span><br><span class="line">            res.add(command.node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是go命令，倒序压入指令</span></span><br><span class="line">            <span class="keyword">if</span>(command.node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, command.node.right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(command.node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, command.node.left));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>, command.node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指令：print、go</span></span><br><span class="line">    String s;</span><br><span class="line">    <span class="comment">// 指令要作用于某个节点上</span></span><br><span class="line">    TreeNode node;</span><br><span class="line">    Command(String s, TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>queue</strong></p><h3 id="347题解"><a href="#347题解" class="headerlink" title="347题解"></a>347题解</h3><ul><li>queue<ul><li>347 Top K Frequent Elements：<a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a><ul><li>返回前k个出现频率最高的元素</li><li>Input: nums = [1,1,1,2,2,3], k = 2</li><li>Output: [1,2]</li></ul></li><li>思路：前K大（优先队列+PairComparator），频率（Map）</li><li>时间复杂度：O(nlogk)</li><li>空间复杂度：O(n+k)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列，频率为优先级(频率，元素)</span></span><br><span class="line">    <span class="comment">// 怎么计算频率：Map（元素，频率）</span></span><br><span class="line">    <span class="comment">// 怎么根据频率排序：PairComparator</span></span><br><span class="line">    </span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(nums[i])) &#123;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> PairComparator());</span><br><span class="line">    <span class="keyword">for</span>(Integer num : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> freq = map.get(num);</span><br><span class="line">        <span class="comment">// 维护最高的k个：如果频率大于队首的频率，队首出队，该元素入队</span></span><br><span class="line">        <span class="keyword">if</span>(pq.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(freq &gt; pq.peek().getKey()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(<span class="keyword">new</span> Pair&lt;Integer, Integer&gt;(freq, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> Pair&lt;Integer, Integer&gt;(freq, num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">        res.add(pq.poll().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PairComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Pair</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.getKey() != p2.getKey())&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.getKey() - p2.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.getValue() - p2.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>linkedlist</strong></p><h3 id="206题解"><a href="#206题解" class="headerlink" title="206题解"></a>206题解</h3><ul><li>linkedlist<ul><li>206 Reverse Linked List：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a><ul><li>反转一个链表</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li><li>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li></ul></li><li>思路1：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路2：迭代</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="203题解"><a href="#203题解" class="headerlink" title="203题解"></a>203题解</h3><ul><li>linkedlist<ul><li>203 Remove Linked List Elements：<a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-linked-list-elements/</a><ul><li>删除链表中特定值的所有元素</li><li>Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</li><li>Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</li></ul></li><li>思路：dummy head</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="24题解"><a href="#24题解" class="headerlink" title="24题解"></a>24题解</h3><ul><li>linkedlist<ul><li>24 Swap Nodes in Pairs：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/</a><ul><li>链表两两交换节点</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;null</li><li>Output: 2-&gt;1-&gt;4-&gt;3-&gt;null</li></ul></li><li>思路：dummy head</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 涉及头结点：dummyHead，四指针（p、node1、node2、next）</span></span><br><span class="line">    <span class="comment">// 定义pre指向dummyHead</span></span><br><span class="line">    <span class="comment">// while循环：当pre.next(node1)和pre.next.next(node2)不为空时</span></span><br><span class="line">    <span class="comment">// -- 定义node1、node2</span></span><br><span class="line">    <span class="comment">// -- 更改指向</span></span><br><span class="line">    <span class="comment">// -- 将pre指向下一个目标之前(node1)</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode pre = dummyHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = pre.next;</span><br><span class="line">        ListNode node2 = node1.next;</span><br><span class="line">        ListNode next = node2.next;</span><br><span class="line">        </span><br><span class="line">        pre.next = node2;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        node1.next = next;</span><br><span class="line">        </span><br><span class="line">        pre = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="237题解"><a href="#237题解" class="headerlink" title="237题解"></a>237题解</h3><ul><li>linkedlist<ul><li>237 Delete Node in a Linked List：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a><ul><li>给定链表中的一个节点，删除该节点</li><li>Input: head = [4,5,1,9], node = 5</li><li>Output: [4,1,9]</li><li>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</li></ul></li><li>思路：修改链表的值</li><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="19题解"><a href="#19题解" class="headerlink" title="19题解"></a>19题解</h3><ul><li>linkedlist<ul><li>19 Remove Nth Node From End of List：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a><ul><li>删除链表的倒数第N个元素</li><li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5, n = 2</li><li>Output: 1-&gt;2-&gt;3-&gt;5</li></ul></li><li>思路：双指针，p和q之间的长度是固定的，只遍历一遍</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode p = dummyHead;</span><br><span class="line">    ListNode q = dummyHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">assert</span> q != <span class="keyword">null</span>;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>基础解法：遍历两遍，第一遍求链表的size，第二遍使用dummyHead删除第size-n个元素</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        index ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = dummyHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index-n; i++)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="234题解"><a href="#234题解" class="headerlink" title="234题解"></a>234题解</h3><ul><li>linkedlist<ul><li>234 Palindrome Linked List：<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a><ul><li>判断链表是否是回文的</li><li>Input: 1-&gt;2-&gt;2-&gt;1</li><li>Output: true</li></ul></li><li>思路：双指针</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode q = head;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="keyword">null</span> &amp;&amp; q.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        q = q.next.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = reverse(p);</span><br><span class="line"></span><br><span class="line">    q = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = node;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>binarytree</strong></p><h3 id="104题解"><a href="#104题解" class="headerlink" title="104题解"></a>104题解</h3><ul><li>104题解<ul><li>104 Maximum Depth of Binary Tree：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a><ul><li>返回二叉树的最大深度</li><li>Input: Given binary tree [3,9,20,null,null,15,7]</li><li>Output: 3</li></ul></li><li>知识：深度K=「log2n」+1（向下取整）</li><li>思路：递归</li><li>时间复杂度：O(n)，n是节点数</li><li>空间复杂度：O(h)，h是树深度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="111题解"><a href="#111题解" class="headerlink" title="111题解"></a>111题解</h3><ul><li>111题解<ul><li>111 Minimum Depth of Binary Tree：<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a><ul><li>求二叉树的最低深度</li><li>Input: Given binary tree [3,9,20,null,null,15,7]</li><li>Output: 2</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.left)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.right)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="226题解"><a href="#226题解" class="headerlink" title="226题解"></a>226题解</h3><ul><li>226题解<ul><li>226 Invert Binary Tree：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a><ul><li>反转二叉树，左右子树对调</li><li>Input: Given binary tree [4,2,7,1,3,6,9]</li><li>Output: return binary tree [4,7,2,9,6,3,1]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    <span class="comment">// swap</span></span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="112题解"><a href="#112题解" class="headerlink" title="112题解"></a>112题解</h3><ul><li>112题解<ul><li>112 Path Sum：<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/</a><ul><li>找出二叉树路径中的是否有一条和等于sum</li><li>Input: binary tree [5,4,8,11,null,13,4,7,2]</li><li>Output: true</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val == sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) ||</span><br><span class="line">            hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="257题解"><a href="#257题解" class="headerlink" title="257题解"></a>257题解</h3><ul><li>257题解<ul><li>257 Binary Tree Paths：<a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-paths/</a><ul><li>返回二叉树所有路径的path</li><li>Input: binary tree [1,2,3,null,5]</li><li>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(Integer.toString(root.val));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    List&lt;String&gt; leftPath = binaryTreePaths(root.left);</span><br><span class="line">    <span class="keyword">for</span> (String i : leftPath) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        sb.append(i);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; rightPath = binaryTreePaths(root.right);</span><br><span class="line">    <span class="keyword">for</span> (String j : rightPath) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        sb.append(j);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="437题解"><a href="#437题解" class="headerlink" title="437题解"></a>437题解</h3><ul><li>437题解<ul><li>437 Path Sum III：<a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/</a><ul><li>求二叉树中等于给定sum的路径，路径可以不从根节点开始</li><li>Input: binary tree [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</li><li>Output: 3</li><li>Explanation: three paths [[5,3], [5,2,1], [-3,11]]</li></ul></li><li>思路：递归嵌套递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="keyword">return</span> findPath(root, sum)</span><br><span class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPath</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.val == sum)&#123;</span><br><span class="line">        res += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    res += findPath(node.left, sum-node.val);</span><br><span class="line">    res += findPath(node.right, sum-node.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="235题解"><a href="#235题解" class="headerlink" title="235题解"></a>235题解</h3><ul><li>235题解<ul><li>235 Lowest Common Ancestor of a Binary Search Tree：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a><ul><li>寻找两个节点最近的公共祖先</li><li>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</li><li>Output: 2</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val&lt;root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.val&gt;root.val &amp;&amp; q.val&gt;root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="100题解"><a href="#100题解" class="headerlink" title="100题解"></a>100题解</h3><ul><li>100题解<ul><li>100 Same Tree：<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/</a><ul><li>判断两颗二叉树是否相同</li><li>Input: binary tree [1,2,null], [1,null,2]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span> || q==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="101题解"><a href="#101题解" class="headerlink" title="101题解"></a>101题解</h3><ul><li>101题解<ul><li>101 Symmetric Tree：<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a><ul><li>判断二叉树是否对称</li><li>Input: binary tree [1,2,2,null,3,null,3]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span> || q==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="222题解"><a href="#222题解" class="headerlink" title="222题解"></a>222题解</h3><ul><li>222题解<ul><li>222 Count Complete Tree Nodes：<a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-complete-tree-nodes/</a><ul><li>计算完全二叉树节点个数</li><li>Input: binary tree [1,2,3,4,5,6,null]</li><li>Output: 6</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="110题解"><a href="#110题解" class="headerlink" title="110题解"></a>110题解</h3><ul><li>110题解<ul><li>110 Balanced Binary Tree：<a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/balanced-binary-tree/</a><ul><li>判断是否为平衡二叉树（每个节点的左右子树高度差不超过1）</li><li>Input: binary tree [1,2,2,3,3,null,null,4,4]</li><li>Output: false</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(getDepth(root.left)-getDepth(root.right))&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="404题解"><a href="#404题解" class="headerlink" title="404题解"></a>404题解</h3><ul><li>404题解<ul><li>404 Sum of Left Leaves：<a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-left-leaves/</a><ul><li>求左叶子节点的和</li><li>Input: binary tree [3,9,20,null,null,15,7]</li><li>Output: 24</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left!=<span class="keyword">null</span> &amp;&amp; root.left.left==<span class="keyword">null</span> &amp;&amp; root.left.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        sum += root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归过程</span></span><br><span class="line">    sum += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="113题解"><a href="#113题解" class="headerlink" title="113题解"></a>113题解</h3><ul><li>113题解<ul><li>113 Path Sum II：<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a><ul><li>返回二叉树路径中的所有等于sum的路径</li><li>Input: binary tree [5,4,8,11,null,13,4,7,2,null,null,5,1]</li><li>Output: [[5,4,11,2],[5,8,4,5]]</li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; middle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getPathSum(root, sum, middle, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, ArrayList&lt;Integer&gt; middle, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    middle.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == sum) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(middle));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    getPathSum(root.left, sum-root.val, middle, result);</span><br><span class="line">    getPathSum(root.right, sum-root.val, middle, result);</span><br><span class="line">    middle.remove(middle.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="129题解"><a href="#129题解" class="headerlink" title="129题解"></a>129题解</h3><ul><li>129题解<ul><li>129 Sum Root to Leaf Numbers：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a><ul><li>求所有路径组成的数字的和</li><li>Input: binary tree [1,2,3]</li><li>Output: 25</li><li>Explanation:<ul><li>The root-to-leaf path 1-&gt;2 represents the number 12.</li><li>The root-to-leaf path 1-&gt;3 represents the number 13.</li><li>Therefore, sum = 12 + 13 = 25.</li></ul></li></ul></li><li>思路：递归</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(h)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSum(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> curSum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curSum = curSum*<span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="keyword">return</span> getSum(root.left, curSum) + getSum(root.right, curSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>collection</strong></p><h3 id="349题解"><a href="#349题解" class="headerlink" title="349题解"></a>349题解</h3><ul><li>349题解<ul><li>349 Intersection of Two Arrays：<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays/</a><ul><li>找两个数组的交集</li><li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li><li>Output: [2]</li></ul></li><li>思路：HashSet，一个set、一个resultSet</li><li>时间复杂度：O(n+m)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums1.length; i++) &#123;</span><br><span class="line">            set.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; resultSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num)) &#123;</span><br><span class="line">                resultSet.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[resultSet.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : resultSet) &#123;</span><br><span class="line">            res[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="350题解"><a href="#350题解" class="headerlink" title="350题解"></a>350题解</h3><ul><li>350题解<ul><li>350 Intersection of Two Arrays II：<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a><ul><li>找两个数组的交集（包括重复的）</li><li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li><li>Output: [2,2]</li></ul></li><li>思路：HashMap，计算元素个数</li><li>时间复杂度：O(n+mlogn)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">            map.put(num, map.get(num)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Integer num : result) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1题解-Map"><a href="#1题解-Map" class="headerlink" title="1题解-Map"></a>1题解-Map</h3><ul><li>1题解<ul><li>1 Two Sum：<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a><ul><li>找出数组中和等于target的数字的下标（注意nums不是有序的）</li><li>Input: nums = [2, 7, 11, 15], target = 9</li><li>Output: [0,1]</li></ul></li><li>思路：将元素a放入Map中，之后查找target-a是否存在</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(complement)) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = i;</span><br><span class="line">            res[<span class="number">1</span>] = map.get(complement);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="454题解"><a href="#454题解" class="headerlink" title="454题解"></a>454题解</h3><ul><li>454题解<ul><li>454 4Sum II：<a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a><ul><li>求四个整型数组的有多少种组合相加等于0</li><li>Input: A = [ 1, 2], B = [-2,-1], C = [-1, 2], D = [ 0, 2]</li><li>Output: 2</li><li>Explanation: The two tuples are:<ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></li></ul></li><li>思路：将C+D的所有组合放入Map中，查找0-A-B</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;C.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = C[i] + D[j];</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(sum)) &#123;</span><br><span class="line">                map.put(sum, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(sum, map.get(sum)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;B.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(<span class="number">0</span>-A[i]-B[j])) &#123;</span><br><span class="line">                res += map.get(<span class="number">0</span>-A[i]-B[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="447题解"><a href="#447题解" class="headerlink" title="447题解"></a>447题解</h3><ul><li>447题解<ul><li>447 Number of Boomerangs：<a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-boomerangs/</a><ul><li>寻找符合Boomerangs定义的三元组的个数</li><li>Input: [[0,0],[1,0],[2,0]]</li><li>Output: 2</li><li>Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</li></ul></li><li>思路：以i为枢纽点，把其他点跟i的距离放入map&lt;距离，频数&gt;，查找距离相同的点组合个数(频数*频数-1)</li><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfBoomerangs</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历枢纽点i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 把其他点的距离放入Map</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j != i) &#123;</span><br><span class="line">                <span class="comment">// 对比距离时使用距离的平方，无浮点数误差问题</span></span><br><span class="line">                <span class="keyword">int</span> dist = dis(points[i], points[j]);</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(dist))</span><br><span class="line">                    map.put(dist, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    map.put(dist, map.get(dist)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算相同距离点的个数的组合</span></span><br><span class="line">        <span class="keyword">for</span>(Integer dis : map.keySet())</span><br><span class="line">            res += map.get(dis) * (map.get(dis)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>]-b[<span class="number">0</span>])*(a[<span class="number">0</span>]-b[<span class="number">0</span>]) + (a[<span class="number">1</span>]-b[<span class="number">1</span>])*(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="219题解"><a href="#219题解" class="headerlink" title="219题解"></a>219题解</h3><ul><li>219题解<ul><li>219 Contains Duplicate II：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-ii/</a><ul><li>判断数组是否在k长度内有重复元素</li><li>Input: nums = [1,2,3,1], k = 3</li><li>Output: true</li></ul></li><li>思路：Set+滑动窗口</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(k)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保持set中最多有k个元素（边界：i-k）</span></span><br><span class="line">        <span class="keyword">if</span>(set.size() == k+<span class="number">1</span>)&#123;</span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="220题解"><a href="#220题解" class="headerlink" title="220题解"></a>220题解</h3><ul><li>220题解<ul><li>220 Contain Duplicate III：<a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-iii/</a><ul><li>判断数组是否在k长度内有差值不大于t的两个数</li><li>Input: nums = [1,2,3,1], k = 3, t = 0</li><li>Output: true</li></ul></li><li>思路：Set+滑动窗口：TreeSet(有序)，查找比x-t大的最小的元素(ceiling)是否&lt;=x+t</li><li>时间复杂度：O(nlogk)</li><li>空间复杂度：O(k)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要用long，否则会发生整型溢出</span></span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.ceiling((<span class="keyword">long</span>)nums[i]-(<span class="keyword">long</span>)t) != <span class="keyword">null</span> &amp;&amp; set.ceiling((<span class="keyword">long</span>)nums[i]-(<span class="keyword">long</span>)t)&lt;=(<span class="keyword">long</span>)nums[i]+(<span class="keyword">long</span>)t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(set.size() == k+<span class="number">1</span>)&#123;</span><br><span class="line">            set.remove((<span class="keyword">long</span>)nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="242题解"><a href="#242题解" class="headerlink" title="242题解"></a>242题解</h3><ul><li>242题解<ul><li>242 Valid Anagram：<a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a><ul><li>判断两个字符串是否为回文串</li><li>Input: s = “anagram”, t = “nagaram”</li><li>Output: true</li></ul></li><li>思路：Hash Table</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(26)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">    if(s.length() != t.length())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // HashTable</span><br><span class="line">    int[] freq = new int[26];</span><br><span class="line">    for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">        freq[s.charAt(i)-&apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">        freq[t.charAt(i)-&apos;a&apos;]--;</span><br><span class="line">        if(freq[t.charAt(i)-&apos;a&apos;] &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="202题解"><a href="#202题解" class="headerlink" title="202题解"></a>202题解</h3><ul><li>202题解<ul><li>202 Happy Number：<a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a><ul><li>判断一个数字是否为happy number</li><li>Input: 19</li><li>Output: true</li><li>Explanation: <ul><li>1^2 + 9^2 = 82</li><li>8^2 + 2^2 = 68</li><li>6^2 + 8^2 = 100</li><li>1^2 + 0^2 + 0^2 = 1</li></ul></li></ul></li><li>思路：Set</li><li>时间复杂度：O(?)</li><li>空间复杂度：O(?)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">     if(n&lt;1) &#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">     int t;</span><br><span class="line">     int newN;</span><br><span class="line">     while(n!=1 &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">         set.add(n);</span><br><span class="line">         newN = 0;</span><br><span class="line">         while(n&gt;0) &#123;</span><br><span class="line">             t = n%10;</span><br><span class="line">             n /= 10;</span><br><span class="line">             newN += t*t;</span><br><span class="line">         &#125;</span><br><span class="line">         n = newN;</span><br><span class="line">     &#125;</span><br><span class="line">     return n == 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="290题解"><a href="#290题解" class="headerlink" title="290题解"></a>290题解</h3><ul><li>290题解<ul><li>290 Word Pattern：<a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">https://leetcode.com/problems/word-pattern/</a><ul><li>判断所给的string是否是pattern的形式</li><li>Input: pattern = “abba”, str = “dog cat cat dog”</li><li>Output: true</li></ul></li><li>思路：Map</li><li>时间复杂度：O(nlogm)</li><li>空间复杂度：O(n+m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">    HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;();</span><br><span class="line">    char[] patterns = pattern.toCharArray();</span><br><span class="line">    String[] strs = str.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">    if(patterns.length != strs.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;patterns.length; i++) &#123;</span><br><span class="line">        char c = patterns[i];</span><br><span class="line">        if(!map.containsKey(c)) &#123;</span><br><span class="line">            if(map.containsValue(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            String value = map.get(c);</span><br><span class="line">            if(!value.equals(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="804题解"><a href="#804题解" class="headerlink" title="804题解"></a>804题解</h3><ul><li>804题解<ul><li>804 Unique Morse Code Words：<a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-morse-code-words/</a><ul><li>返回不同摩斯码的个数</li><li>Input: words = [“gin”, “zen”, “gig”, “msg”]</li><li>Output: 2</li><li>Explanation: There are 2 different transformations, “–…-.” and “–…–.”.</li></ul></li><li>思路：使用Set返回不同摩斯码的个数</li><li>时间复杂度：O(n+s)</li><li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int uniqueMorseRepresentations(String[] words) &#123;</span><br><span class="line">    String[] codes = &#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;</span><br><span class="line">    TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();</span><br><span class="line">    for(String word : words) &#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i=0; i&lt;word.length(); i++)</span><br><span class="line">            res.append(codes[word.charAt(i)-&apos;a&apos;]);</span><br><span class="line">        set.add(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-入门与进阶-imooc</title>
      <link href="2019/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-imooc/"/>
      <url>2019/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/Redis-%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6-imooc/</url>
      
        <content type="html"><![CDATA[<h3 id="《Redis入门》"><a href="#《Redis入门》" class="headerlink" title="《Redis入门》"></a>《Redis入门》</h3><ul><li>NoSQL<ul><li>NoSQL（Not Only SQL）：非关系型数据库</li><li>NoSQL的兴起：高并发读写、海量数据的高效存储和访问、高可拓展性和高可用性</li><li>NoSQL数据库的四大分类<ul><li>键值对存储：Redis</li><li>列存储：HBase</li><li>文档数据库：Mongodb</li><li>图数据库：Neo4j</li></ul></li><li>NoSQL的特点：易扩展、灵活的数据模型、大数据量高性能、高可用</li></ul></li><li>Redis概述<ul><li>Redis的由来：2009年推出，用C语言开发</li><li>Redis是高性能键值对数据库，支持丰富的键值数据类型<ul><li>字符串类型</li><li>列表类型</li><li>有序集合类型</li><li>散列类型</li><li>集合类型</li></ul></li><li>Redis的应用场景<ul><li>缓存</li><li>任务队列</li><li>网站访问统计</li><li>数据过期处理</li><li>应用排行榜</li><li>分布式集群架构中的Session分离</li></ul></li></ul></li><li>Redis安装与使用<ul><li>Windows安装：GitHub下载 <a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">https://github.com/microsoftarchive/redis/releases</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure></li></ul></li><li>Jedis入门<ul><li>Jedis：是Redis官方首选的Java客户端开发包</li><li>Spring Boot下使用Redis：</li><li>引入依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>单实例测试（服务器上需要打开6379端口：<code>vim /etc/sysconfig/iptables</code>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void redisTest()&#123;</span><br><span class="line">    // 保存字符串</span><br><span class="line">    stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">    Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Redis存储对象：需要实现RedisSerializer<T>接口来对传入对象进行序列化和反序列化</li><li>连接池方式</li></ul></li><li>Redis的数据结构<ul><li>字符串（string）<ul><li>赋值：<code>set name imooc</code></li><li>查看：<code>get name</code></li><li>先查看再赋值：<code>getset name bytedance</code> ==&gt; imooc</li><li>删除：<code>del name</code></li><li>添加：<code>append num 5</code> ==&gt; “55” </li><li>递增<ul><li><code>incr num</code>（如果没有该变量，设置其初值为0，再加1）==&gt; 1</li><li><code>incrby num 5</code> ==&gt; 6</li></ul></li><li>递减<ul><li><code>decr num</code>（如果没有该变量，设置其初值为0，再加-1）==&gt; -1</li><li><code>decrby num 5</code> ==&gt; 6</li></ul></li></ul></li><li>哈希（hash）<ul><li>是String Key和String Value的map容器</li><li>赋值<ul><li><code>hset myhash name louis</code>、<code>hset myhash age 22</code></li><li><code>hmset myhash name louis age 22</code> </li></ul></li><li>查看<ul><li><code>hget myhash name</code>、<code>hget myhash age</code></li><li><code>hmget myhash name age</code></li><li><code>hgetall myhash</code> ==&gt; name, louis, age, 22</li></ul></li><li>删除<ul><li><code>hdel myhash name age</code>、<code>hdel myhash name</code></li><li><code>del myhash</code> ==&gt; (empty list or set)</li></ul></li><li>增加<ul><li><code>hincrby myhash age 1</code>（无hincr、无hdecr、无hdecrby）</li></ul></li><li>判断存在： <code>hexists myhash age</code> ==&gt; 1</li><li>map的长度：<code>hlen myhash</code> ==&gt; 2</li><li>所有的key：<code>hkeys myhash</code> </li><li>所有的value：<code>hvals myhash</code> </li></ul></li><li>字符串列表（list）<ul><li>底层结构：ArrayList数组、LinkedList双向链表</li><li>添加<ul><li>左端添加：<code>lpush list 1 2 3</code> ==&gt; 3 2 1 </li><li>右端添加：<code>rpush mylist 1 2 3</code> ==&gt; 1 2 3</li><li>存在时才添加：<code>lpushx list x</code></li><li>按index添加：<code>lset list 3 x</code>（在index=3的地方添加x）</li><li>按elem插入：<code>linsert list before 3 x</code>（在第一个3前面插入x，<code>after</code>）</li></ul></li><li>查看<ul><li><code>lrange list 0 -1</code></li></ul></li><li>弹出<ul><li>左端弹出：<code>lpop list</code> ==&gt; 3</li><li>右端弹出：<code>rpop mylist</code> ==&gt; 3</li></ul></li><li>删除<ul><li>从左删除：<code>lrem list 2 3</code>（从前往后删除2个3）</li><li>从右删除：<code>lrem list -2 3</code>（从后往前删除2个3）</li><li>全部删除：<code>lrem list 0 3</code>（删除所有的3）</li></ul></li><li>返回长度：<code>llen list</code></li><li>组合<ul><li>从source取出添加到target：<code>rpoplpush mylist list</code>（mylist的最后弹出插入到list中的第一个）</li><li>消费者：<code>rpop</code></li><li>生产者：<code>lpush</code></li></ul></li></ul></li><li>字符串集合（set）<ul><li>set不允许添加重复的元素</li><li>添加：<code>sadd set 1 2 3</code></li><li>查看：<code>smembers set</code></li><li>删除：<code>srem set 1 2</code></li><li>判断存在：<code>sismember set a</code> ==&gt; 1</li><li>差集：<code>sdiff set set1</code> ==&gt; c 3</li><li>交集：<code>sinter set set1</code> ==&gt; a b 1 2</li><li>并集：<code>sunion set set1</code> ==&gt; a b c 1 2 3</li><li>长度：<code>scard set</code> ==&gt; 6</li><li>随机：<code>srandmember set</code> ==&gt; b</li><li>存储<ul><li><code>sdiffstore set2 set set1</code></li><li><code>sinterstore set2 set set1</code></li><li><code>sunionstore set2 set set1</code></li></ul></li></ul></li><li>有序字符串集合（sorted-set / zset）<ul><li>添加：<code>zadd sort 1 a 2 b 3 c</code></li><li>修改：<code>zadd sort 2 a</code> ==&gt; 0</li><li>查看：<code>zscore sort a</code> ==&gt;2</li><li>长度：<code>zcard sort</code></li><li>删除：<code>zrem sort a b</code><ul><li>排名范围删除：<code>zremrangebyrank sort 0 4</code></li><li>分数范围删除：<code>zremrangebyscore sort 80 100</code></li></ul></li><li>排序：<code>zrange sort 0 -1 [withscores]</code><ul><li>降序：<code>zrevrange sort 0 -1 [withscores]</code></li><li>范围：<code>zrangebyscore sort 0 100 [withscores] [limit 0 2]</code></li></ul></li><li>自增<ul><li><code>zincrby sort 1 a</code></li></ul></li><li>计数<ul><li><code>zcount sort 80 100</code> </li></ul></li></ul></li></ul></li><li>Redis的通用命令<ul><li>查看所有的key：<code>keys *</code></li><li>通配符：<code>keys my*</code>（my开头的key）</li><li>重命名：<code>rename name newname</code></li><li>设置过期时间：<code>expire name 1</code>（1秒后过期）</li><li>查看过期时间：<code>ttl name</code></li><li>类型：<code>type name</code></li><li>全部清空：<code>flushall</code></li></ul></li><li>Redis的特性<ul><li>Redis的多数据库<ul><li>默认0号数据库</li><li>使用1号数据库：<code>select 1</code></li><li>移动key到1号数据库：<code>move name 1</code></li></ul></li><li>Redis的事务<ul><li>事务中所有命令都会被串行化，保证事务中的命令被原子化执行</li><li>开启事务：<code>multi</code></li><li>提交事务：<code>exec</code></li><li>回滚事务：<code>discard</code></li></ul></li></ul></li><li>Redis的持久化<ul><li>Redis的高性能（所有的数据都存在内存中），持久化：数据从内存到硬盘的过程</li><li>RDB方式（Redis DataBase，全量持久化）</li><li>AOF方式（Append Only File，增量持久化） <ul><li>从appendonly.aop文件中删除历史命令</li></ul></li></ul></li></ul><h3 id="《Redis进阶》"><a href="#《Redis进阶》" class="headerlink" title="《Redis进阶》"></a>《Redis进阶》</h3><ul><li>4-1：Redis简介<ul><li>主流应用架构<ul><li>穿透：缓存层查询不到数据，穿透到存储层查询</li><li>熔断：当存储层宕机时，请求只访问缓存层<br><img src="/images/basic/redis/1.jpg" alt=""></li></ul></li><li>缓存中间件：Memcache、Redis<ul><li>Memcache代码层次类型Hash，支持简单数据类型</li><li>Memcache缺点：不支持数据持久化存储、不支持主从同步、不支持分片 (Sharding)</li><li>Redis数据类型丰富</li><li>Redis优点：支持数据持久化存储、支持主从同步、支持分片</li></ul></li><li>Redis为什么这么快<ul><li>10W+ QPS（Query Per Second，每秒内查询次数）</li><li>Redis完全基于内存，绝大部分请求是内存操作，执行效率高</li><li>Redis数据结构简单，对数据操作也简单，没有表及关系，性能比关系型数据库高很多</li><li>采用单线程，单线程配合I/O多路复用，非阻塞IO，来处理高并发请求</li></ul></li><li>多路I/O复用模型<ul><li>FD（File Descriptor，文件描述符）<ul><li>一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射</li></ul></li><li>Blocking I/O（BIO，传统的阻塞I/O模型）<ul><li><a href="https://juejin.im/post/5dc37d895188256d85228de6" target="_blank" rel="noopener">BIO</a>通信方式在单线程服务器下一次只能处理一个请求，在处理完毕之前一直阻塞，因此不适用于高并发的情况</li></ul></li><li>Select系统调用<ul><li>I/O多路复用模型允许同时等待多个套接字描述符是否就绪</li><li><a href="https://blog.csdn.net/lihao21/article/details/66097377" target="_blank" rel="noopener">select</a>允许进程指示内核等待多个事件中的任何一个发生，并只有在一个或多个事件发生或经历一段指定的时间后才唤醒它</li></ul></li><li>多路复用函数（epoll/kqueue/evport/select）<ul><li>Redis优先选择时间复杂度为O(1)的多路复用函数作为底层实现</li><li>以时间复杂度O(n)的select作为保底</li><li>Redis基于react设计模式监听I/O事件 </li></ul></li></ul></li></ul></li><li>4-2：常用数据类型<ul><li>String：最基本的数据类型，是二进制安全的<ul><li>保存字符串对象的结构：<code>struct sdshdr { int len; int free; char buf[] }</code></li></ul></li><li>Hash：String元素组成的字典，适合用于存储对象</li><li>List：安装String元素插入顺序排列的列表<ul><li><code>lpush</code>+<code>lpop</code>：栈</li></ul></li><li>Set：String元素组成的无序集合，通过哈希表实现，不允许重复<ul><li>集合操作：可以很容易实现微博的共同关注功能</li></ul></li><li>Sorted Set：通过分数来为集合中的成员进行从小到大的排序</li><li>HyperLogLog（计数）、Geo（地理位置）</li><li>Redis的底层数据类型基础<ul><li>简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表、对象</li></ul></li></ul></li><li>4-3：从海量key中查询某一固定前缀的key<ul><li>思维要严谨：如果没加海量，也要问面试官数据的规模，不同规模有不同的方案</li><li><code>keys k1*</code>：KEYS pattern，查找所有符合给定pattern的key<ul><li>keys的问题：keys一次性返回所匹配的key、key数量过大会导致卡顿</li><li><code>dbsize</code>：查key的规模</li></ul></li><li><code>scan cursor</code>：基于游标的迭代器，增量式迭代<ul><li>需要基于上一次的游标延续之前的迭代过程</li><li>以0作为游标开始一次新的迭代，知道命令返回游标0，完成一次遍历</li><li>不保证每次执行都返回某个给定数量的元素，count参数大致约束，支持模糊查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># SCAN cursor [MATCH pattern] [COUTN count]</span><br><span class="line">scan 0 match k1* count 10</span><br><span class="line">scan 11534336 match k1* count 10</span><br><span class="line">// Jedis：使用HashMap对cursor进行去重</span><br></pre></td></tr></table></figure></li></ul></li><li>批量生成redis测试数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Linux Bash下面执行</span><br><span class="line">  for((i=1;i&lt;=20000000;i++)); do echo &quot;set k$i v$i&quot; &gt;&gt; /tmp/redisTest.txt ;done;</span><br><span class="line">  生成2千万条redis批量设置kv的语句(key=kn,value=vn)写入到/tmp目录下的redisTest.txt文件中</span><br><span class="line">2.用vim去掉行尾的^M符号，使用方式如下：：</span><br><span class="line">  vim /tmp/redisTest.txt</span><br><span class="line">    :set fileformat=dos #设置文件的格式，通过这句话去掉每行结尾的^M符号</span><br><span class="line">    ::wq #保存退出</span><br><span class="line">3.通过redis提供的管道--pipe形式，去跑redis，传入文件的指令批量灌数据，需要花10分钟左右</span><br><span class="line">  cat /tmp/redisTest.txt | 路径/redis-5.0.0/src/redis-cli -h 主机ip -p 端口号 --pipe</span><br></pre></td></tr></table></figure></li></ul></li><li>4-4：如何通过Redis实现分布式锁<ul><li>分布式锁：控制分布式系统中访问共同资源的实现，互斥保证一致性<ul><li>需要解决的问题：互斥性、安全性(锁只能被持有方删除)、死锁、容错(部分节点即Redis宕机时还可以获取释放锁)</li></ul></li><li><code>SETNX key value</code>：如果key不存在，则创建并赋值<ul><li>时间复杂度O(1)，返回1成功，返回0失败<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx locknx test # ==&gt; 1</span><br><span class="line">setnx locknx task # ==&gt; 0</span><br></pre></td></tr></table></figure></li></ul></li><li><code>EXPIRE key second</code>：解决setnx长期有效的问题<ul><li>设置key的生存时间，当key过期时，会被自动删除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire locknx 2 # 两秒后过期</span><br></pre></td></tr></table></figure></li><li>Jedis中使用SETNX和EXPIRE：但二者结合，失去了原子性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService.class);</span><br><span class="line">long status = redisService.setnx(key, &quot;1&quot;);</span><br><span class="line">if(status == 1) &#123;</span><br><span class="line">    redisService.expire(key, expire);</span><br><span class="line">    // pass</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Redis2.6.12后：SET组合了setnx和expire<ul><li>SET key value [EX seconds] [PX milliseconds] [NX|XX]</li><li>PX：设置过期时间为毫秒</li><li>NX：当键不存在时，才对键进行设置操作</li><li>XX：当键存在时，才对键进行设置操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set lock 12345 ex 10 nx</span><br></pre></td></tr></table></figure></li></ul></li><li>大量的key同时过期的注意事项：执行随机过期时间</li></ul></li><li>4-5：如何实现异步队列<ul><li>List作队列，rpush生产消息，lpop消费消息<ul><li>缺点：lpop不会等待队列里有值，直接消费</li><li>弥补：通过在应用层引入sleep机制去调用lpop重试</li></ul></li><li><code>BLPOP key timeout</code>：阻塞直到队列有消息或超时<ul><li>一端执行blpop后，会监听另一端是否生产消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop list 30 # rpush后 ==&gt; aaa</span><br><span class="line">rpush list aaa</span><br></pre></td></tr></table></figure></li></ul></li><li>pub/sub（主题订阅者模式）：一对多消费队列<ul><li>发送者pub发送消息，订阅者sub接收消息</li><li>订阅者sub可以订阅任意数量的频道</li><li>缺点：消息发布无状态，无法保证可达（需用Kafka）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subscribe mytopic</span><br><span class="line">subscribe mytopic2</span><br><span class="line">publish mytopic hello</span><br><span class="line">publish mytopic2 good</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>4-6：持久化RDB<ul><li>RDB（快照）持久化：保存某个时间点的全量数据快照<ul><li>SAVE：阻塞Redis主进程，直到RDB文件被创建完毕<ul><li>配置中添加<code>save &quot;&quot;</code>来禁用RDB</li></ul></li><li>BGSAVE：Fork (派生)出一个子进程来创建RDB文件，不阻塞服务器进程<ul><li>系统调用fork()：创建进程，实现了<a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">Copy on Write</a> (写时复制)</li></ul></li></ul></li><li>自动化触发RDB持久化<ul><li>根据redis.conf配置里的SAVE m n定时触发（用的是BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行Debug Reload</li><li>执行Shutdown且没有开启AOF持久化</li></ul></li><li>RDB持久化的缺点<ul><li>内存数据全量同步，数据量大会由于I/O而严重影响性能</li><li>可能会因为Redis宕机而丢失从当前至最近一次快照期间的数据</li></ul></li></ul></li><li>4-7：持久化AOF<ul><li>Append-Only-File：保存写状态<ul><li>保存除查询以外的所有指令</li><li>以append的形式追加保存到aof文件中（保存增量数据）</li><li>修改配置为yes <code>appendonly yes</code>来开启AOF</li></ul></li><li>日志重写（aofrewrite）：解决aof文件大小不断变大的问题（原理：Copy on Write）<ul><li>调用fork()，创建一个子进程</li><li>子进程把新的aof写到一个临时文件里，不依赖原来的aof文件</li><li>主进程持续把新的变动写到内存的buff和原来的aof中</li><li>主进程获取子进程重写aof的完成信号，往新的aof同步增量变动</li><li>使用新的aof文件替换掉旧的aof文件</li></ul></li><li>RDB和AOF的对比<ul><li>RDB：全量数据快照，文件小，恢复快；但无法保存最近一次快照之后的数据</li><li>AOF：可读性高，适合保存增量数据，不易丢失；但文件体积大，恢复时间长</li></ul></li><li>RDB-AOF混合持久化方式（新版默认）<ul><li>先RDB (BGSAVE) 做全量数据持久化，再AOF做增量持久化</li></ul></li></ul></li><li>4-8：Pipeline及主从同步<ul><li>Pipeline类似Linux的管道<ul><li>Redis基于请求/相应模型，单个请求处理需要一一应答</li><li>Pipeline批量执行指令，节省多次IO往返的时间（前提：指令没有依赖相关性）</li></ul></li><li>Redis的同步机制（全量、增量同步）<ul><li>全同步过程<ul><li>Slave发送sync命令到Master</li><li>Master启动一个后台进程，将Redis中的数据快照保存到文件中（BGSAVE）</li><li>Master将保存数据快照期间接收到的写命令缓存起来</li><li>Master完成写文件操作后，将该文件发送给Slave</li><li>使用新的aof文件替换旧的aof文件</li><li>Master将这期间收集的增量写命令发送到Slave端</li></ul></li><li>增量同步过程<ul><li>Master接收到用户的操作指令，判断是否需要传播到Slave</li><li>将操作记录追加到aof文件</li><li>将操作传播到其他Slave：1.对其主从库，2.向相应缓存写入指令</li><li>将缓存中的数据发送到Slave</li></ul></li></ul></li><li>Redis Sentinel（哨兵）：解决主从同步Master宕机后主从切换问题<ul><li>监控：检查主从服务器是否运行正常</li><li>提醒：通过API向管理员或者其他应用程序发送故障通知</li><li>自动故障迁移：主从切换</li></ul></li><li>流言协议Gossip：Redis哨兵采用的通信协议<ul><li>在杂乱无章中寻求一致（区块链的通信协议）</li><li>每个节点都随机的与对方通信，最终所有节点的状态达成一致</li><li>种子节点定期随机向其他节点发送节点列表以及需要传播的消息</li><li>不保证信息一定会传递给所有节点，但最终会趋于一致</li></ul></li></ul></li><li>4-9：Redis集群<ul><li>Redis的数据分布存储<ul><li>Redis Cluster采用无中心节点，每个节点之间使用Gossip流言协议通信</li><li>分片：按照某种规则划分数据，将key分散存储在多个节点上</li></ul></li><li>在集群中寻找某一个key在哪台服务器上<ul><li>常规按照哈希划分无法实现节点的动态增减</li><li>一致性哈希算法的概念<ul><li>对2^32取模，将哈希值空间组织成虚拟的圆环</li><li>将数据key使用相同的哈希函数计算出哈希值</li></ul></li><li>一致性哈希算法的理解<ul><li>好处：如果某一个node宕机，按环的顺时针存到下一个node</li><li>问题：node少时，会有Hash环的数据倾斜问题</li><li>解决：引入虚拟节点解决数据倾斜问题</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统：概述-编程必备</title>
      <link href="2019/10/16/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-%E7%BC%96%E7%A8%8B%E5%BF%85%E5%A4%87/"/>
      <url>2019/10/16/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0-%E7%BC%96%E7%A8%8B%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Ch6-操作系统之基础篇"><a href="#Ch6-操作系统之基础篇" class="headerlink" title="Ch6-操作系统之基础篇"></a>Ch6-操作系统之基础篇</h1><h2 id="os简介"><a href="#os简介" class="headerlink" title="os简介"></a>os简介</h2><ul><li>6-1：章节导学<ul><li>操作系统的演进<ul><li>无操作系统：资源利用率很低</li><li>批处理系统：资源利用率提升、多道程序设计</li><li>分时系统：及时调试程序、资源利用率提升</li></ul></li><li>多道程序设计：在计算机内存中同时存放多个程序<ul><li>早期批处理系统只能一次处理一个任务，多道程序设计使得批处理系统可以一次处理多个任务</li><li>批处理输入，多道程序在计算机的管理程序之下相互穿插运行</li><li>对多道程序的管理是操作系统的重要功能</li></ul></li><li>操作系统的五大功能<ul><li>进程管理、存储管理、作业管理、文件管理、设备管理</li></ul></li></ul></li><li>6-2：操作系统概览<ul><li>什么是操作系统<ul><li>操作系统是管理计算机硬件和软件资源的<strong>计算机程序</strong>（管理硬件、提供用户交互的软件系统）</li><li>管理配置内存、决定资源供需顺序、控制输入输出设备等</li><li>操作系统提供让用户和系统交互的操作界面</li></ul></li><li>操作系统的基本功能<ul><li>统一管理着计算机资源，如处理器、存储器、IO设备、文件资源</li><li>实现了对计算机资源的抽象，用户无需面向硬件接口编程</li><li>提供了用户与计算机之间的接口</li></ul></li><li>操作系统的相关概念<ul><li>并发性：在同一时间间隔发生，有别于并行（同一时刻发生）</li><li>共享性：互斥共享形式、同时访问形式</li><li>虚拟性：时分复用技术（虚拟处理器、虚拟设备）、空分复用技术（虚拟磁盘、虚拟内存）</li><li>异步性：多道程序环境下，允许多个进程并发执行</li></ul></li></ul></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li>6-3：进程管理之进程实体<ul><li>为什么需要进程<ul><li>进程是系统进行资源分配和调度的基本单位</li><li>进程作为程序独立运行的载体保障程序正常执行</li><li>进程的存在使得操作系统资源的利用率大幅提升</li></ul></li><li>主存中的进程形态（进程的实体）<ul><li>进程控制块（PCB）：用于描述和控制进程运行的通用数据结构<ul><li>四类：进程标识符、处理机状态、进程调度信息、进程控制信息</li><li>包括：标识符、状态、程序计数器、内存指针、上下文数据、IO状态信息、记账信息</li></ul></li></ul></li><li>进程与线程<ul><li>进程（Process）：操作系统进行资源分配和调度的<strong>基本单位</strong></li><li>线程（Thread）：操作系统进行运行调度的<strong>最小单位</strong></li><li>一个进程可以并发多个线程（多线程）</li><li>线程共享进程的资源</li></ul></li></ul></li><li>6-4：进程管理之五状态模型<ul><li>五状态<ul><li>创建：创建进程时拥有PCB但其他资源未就绪（<code>fork</code>函数接口创建进程）</li><li>就绪：其他资源都准备好，只差CPU资源的状态（就绪队列）</li><li>阻塞：进程因某种原因放弃CPU的状态（阻塞队列）</li><li>执行：进程获得其他资源，也获得CPU执行的状态</li><li>终止：系统结束由系统清理或者归还PCB的状态</li></ul></li><li>状态的转换<ul><li>创建 -&gt; 就绪：创建完成</li><li>就绪 &lt;-&gt; 执行：进程调度、时间片完</li><li>执行 -&gt; 终止：执行完成</li><li>执行 -&gt; 阻塞：IO请求</li><li>阻塞 -&gt; 就绪：IO完成</li></ul></li></ul></li><li>6-5：进程管理之进程同步<ul><li>两个经典问题<ul><li>生产者-消费者问题：生产者程序和消费者程序并发执行时出错（mutex_lock_demo.cpp）</li><li>哲学家进餐问题：死锁</li><li>根源问题：彼此间没有通信，需要进程间的同步</li></ul></li><li>为什么需要进程间同步<ul><li>对竞争资源在多进程间进行使用次序的协调</li><li>使得并发执行的多个进程之间可以有效使用资源和相互合作</li></ul></li><li>进程间同步的原则<ul><li>临界资源：无法同时被多个线程共享访问</li><li>四个原则：空闲让进、忙则等待、有限等待、让权等待</li><li>同步方法：消息队列、共享存储、信号量</li></ul></li><li>线程同步（进程内多个线程也需要同步）<ul><li>四个同步方法：互斥量、读写锁、自旋锁、条件变量</li></ul></li></ul></li><li>6-6：Linux的进程管理<ul><li>进程的类型：前台进程、后台进程、守护进程<ul><li>前台进程：具有终端，可以和用户交互的进程</li><li>后台进程：不和用户进程交互，优先级比前台进程低（以<code>&amp;</code>结尾：<code>python test.py &amp;</code>）  </li><li>守护进程：守护（Daemon）进程是特殊的后台进程，在系统引导时启动，一直运行到系统关闭（进程名字以“d”结尾的：httpd, sshd, mysqld）<ul><li><a href="https://www.nowcoder.com/profile/1972414/myFollowings/detail/10704601" target="_blank" rel="noopener">https://www.nowcoder.com/profile/1972414/myFollowings/detail/10704601</a></li></ul></li></ul></li><li>进程的ID<ul><li>进程的ID（pid）表现为一个非负整数，最大值由操作系统规定</li><li>父子进程关系：父进程调用fork函数创建子进程（<code>pstree</code>查看）</li><li>ID为0：idle进程，是系统创建的第一个进程</li><li>ID为1：init进程，是0号进程的子进程，完成系统初始化，是所有用户进程的祖先进程</li></ul></li><li>进程的状态标记（<code>man ps</code>查看解释）<ul><li><strong>R：TASK_RUNNING，进程正处于运行状态</strong></li><li><strong>S：TASK_INTERRUPTIBLE，睡眠状态</strong></li><li>D：TASK_UNINTERRUPTIBLE，IO等待的睡眠状态</li><li>T：TASK_STOP，暂停状态</li><li>Z：TASK_DEAD or EXIT_ZOMBIE，退出或僵尸状态</li></ul></li><li>操作Linux进程的相关命令<ul><li><code>ps</code>：列出进程列表 （+<code>-aux</code>详细信息，<code>-u</code>用户）</li><li><code>ps -aux | grep [pid]</code>：查看进程状态</li><li><code>ps -ef --forest</code>：查看进程树</li><li><code>ps -aux --sort=-pcpu</code>：按CPU使用频率排序</li><li><code>ps -aux --sort=-pmem</code>：按内存使用大小排序</li><li><code>top</code>：查看进程的所有状态</li><li><code>kill -9 [pid]</code>：9表示无条件终止进程</li></ul></li></ul></li></ul><h2 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h2><ul><li>6-7：作业管理之进程调度<ul><li>进程调度：指计算机通过决策决定哪个就绪进程可以获得CPU使用权</li><li>进程调度的三个机制<ul><li>就绪队列的排队机制：将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程</li><li>选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将CPU资源分配给它</li><li>新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文</li></ul></li><li>进程调度的两个方式（分类依据，老进程执行完与否）<ul><li>非抢占式的调度</li><li>抢占式的调度<br><img src="/images/basic/os/1.png" alt="抢占、非抢占式调度"></li></ul></li><li>进程调度算法<ul><li>先来先服务调度算法 </li><li>短进程优先调度算法 </li><li>高优先权优先调度算法 </li><li>时间片轮转调度算法</li></ul></li></ul></li><li>6-8：作业管理之死锁<ul><li>死锁的概念<ul><li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</li></ul></li><li>死锁的产生<ul><li>竞争资源 </li><li>进程调度顺序不当</li></ul></li><li>死锁的四个必要条件（四个都要满足）<ul><li>互斥条件 </li><li>请求保持条件 </li><li>不可剥夺条件 </li><li>环路等待条件</li></ul></li><li>预防死锁的方法<ul><li>摒弃请求保持条件</li><li>摒弃不可剥夺条件</li><li>摒弃环路等待条件</li></ul></li><li>避免死锁：银行家算法<ul><li>以银行借贷系统分配策略为基础的算法</li><li>客户申请的贷款是有限的，每次申请需声明最大资金量</li><li>客户在使用贷款后，能够及时归还贷款</li><li>算法流程：所需资源表-已分配资源表=还需分配资源表<br><img src="/images/basic/os/2.png" alt="银行家算法"></li></ul></li></ul></li></ul><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul><li>6-9：存储管理之内存分配与回收<ul><li>存储管理所解决的三个问题<ul><li>确保计算机有足够的内存处理数据 </li><li>确保程序可以从可用内存中获取一部分内存使用 </li><li>确保程序可以归还使用后的内存以供其他程序使用</li></ul></li><li>内存分配的过程<ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li>动态分区分配<ul><li>动态分区数据结构<ul><li>动态分区空闲表数据结构</li><li>动态分区空闲链数据结构 </li></ul></li><li>动态分区分配算法<ul><li>首次适应算法</li><li>最佳适应算法</li><li>快速适应算法 </li></ul></li></ul></li><li>内存回收的过程<ul><li>回收区在空闲区之后：扩容</li><li>回收区在空闲区之前：合并</li><li>回收区在两个空闲区中间：合并</li><li>只有回收区：在回收区创建新的空闲节点</li></ul></li></ul></li><li>6-10：存储管理之段页式存储管理<ul><li>疑问：<ul><li>操作系统如何管理进程的空间？</li></ul></li><li>页式存储管理<ul><li>页面：将进程逻辑空间等分成若干大小的页面</li><li>页表：页表记录进程逻辑空间与物理空间的映射</li></ul></li><li>段式存储管理<ul><li>段：将进程逻辑空间划分成若干段（非等分）</li><li>段表：段号、基址、段长</li></ul></li><li>段页式存储管理<ul><li>分页可以有效提高内存利用率， 分段可以更好满足用户需求，两者结合形成段页式存储管理</li><li>先将逻辑空间按段式管理分成若干段，再把段内空间按页式管理等分成若干页<br><img src="/images/basic/os/3.png" alt="页、段、段页式"></li></ul></li><li>页和段的对比（段式存储和页式存储都离散地管理了进程的逻辑空间）<ul><li>页是物理单位，段是逻辑单位</li><li>分页是为了合理利用空间，分段是满足用户要求 </li><li>页大小由硬件固定，段长度可动态变化 </li><li>页表信息是一维的，段表信息是二维的</li></ul></li></ul></li><li>6-11：存储管理之虚拟内存<ul><li>疑问：<ul><li>一个游戏10几G，物理内存只有4G，游戏怎么运行的？</li></ul></li><li>虚拟内存概述<ul><li>把程序使用内存划分，将部分暂时不使用的内存放置在辅存</li></ul></li><li>程序的局部性原理<ul><li>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中</li><li>如果访问页不在内存，则发出缺页中断，发起页面置换</li><li>虚拟内存实际是对物理内存的补充，速度接近于内存，成本接近于辅存</li></ul></li><li>虚拟内存的置换算法<ul><li>先进先出算法(FIFO) </li><li>最不经常使用算法(LFU) </li><li>最近最少使用算法(LRU)</li></ul></li><li>虚拟内存置换<ul><li>替换策略发生在Cache-主存层次、主存-辅存层次 </li><li>Cache-主存层次的替换策略主要是为了解决<strong>速度问题</strong></li><li>主存-辅存层次主要是为了解决<strong>容量问题</strong></li></ul></li></ul></li><li>6-12：Linux的存储管理<ul><li>Buddy内存管理算法<ul><li>算法主要是为了解决内存外碎片的问题</li><li>将页外碎片问题 -&gt; 页内碎片问题：120k的分给128k的空间</li><li>努力让内存分配与相邻内存合并能快速进行</li><li>向上取整为2的幂大小</li><li>Buddy内存回收<br><img src="/images/basic/os/4.png" alt="Buddy内存管理算法"></li></ul></li><li>Linux的交换空间<ul><li>交换空间(Swap)是磁盘的一个分区</li><li>解决的问题<ul><li>冷启动内存依赖</li><li>系统睡眠依赖 </li><li>大进程空间依赖</li></ul></li><li>交换空间和虚拟内存的对比</li></ul></li></ul></li></ul><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul><li><p>6-13：操作系统的文件管理</p><ul><li>逻辑结构的文件类型<ul><li>有结构文件：文本文件、文档、媒体文件</li><li>无结构文件：二进制文件、链接库</li></ul></li><li>文件的逻辑结构<ul><li>顺序文件：按顺序存放在存储介质中的文件（增删改不方便）</li><li>索引文件：为了解决可变长文件存储而发明的一种文件格式（配合索引表）</li></ul></li><li>辅存的分配方式<ul><li>连续分配：对存储要求高，要求满足容量的连续存储空间</li><li>链接分配<ul><li>隐式链接：可靠性差，任何一个链接出问题都影响整个文件</li><li>显式链接：使用k-v（物理块：下一盘块存储）<ul><li>FAT（File Allocation Table）文件系统</li></ul></li></ul></li><li>索引分配： 把文件的所有盘块集中存储（索引）</li></ul></li><li>存储空间管理<ul><li>空闲表</li><li>空闲链表</li><li>位示图</li></ul></li><li>目录管理<ul><li>目录树：任何文件或目录都只有唯一路径</li></ul></li></ul></li><li><p>6-14：Linux文件的基本操作</p><ul><li><p>Linux的目录</p><ul><li>Linux设计哲学：一切皆文件</li><li>相对路径（../path）、绝对路径</li></ul></li><li><p>Linux文件常用操作</p><ul><li><code>touch</code>：创建文件，<code>mkdir</code>创建文件夹</li><li><code>rm</code>：删除文件，<code>rm -r</code>删除文件夹（递归删除）</li><li><code>cat</code>：查看文件</li></ul></li><li><p>Linux的文件类型</p><ul><li>命令：<code>ls -al</code></li><li>普通文件<code>-</code>，目录文件<code>d</code>，符号链接<code>l</code>，套接字<code>s</code>，设备文件<code>b、c</code>，FIFO<code>p</code></li></ul></li></ul></li><li><p>6-15：Linux的文件系统</p><ul><li>文件系统概览<ul><li>FAT：File Allocation Table，早期Dos/Windows使用</li><li>NTFS：New Technology File System，现在Win使用</li><li>EXT2/3/4：Extended File System，Linux使用</li></ul></li><li>Ext文件系统<ul><li>Boot Sector：启动扇区，安装开机管理程序</li><li>Block Group：块组，存储数据的实际位置<ul><li>Inode</li><li>Inode bitmap</li><li>Data block<ul><li>Block bitmap</li></ul></li><li>Superblock</li></ul></li></ul></li><li>Ext文件系统实操<ul><li><code>df -T</code>：查看挂载的磁盘</li><li><code>sudo dumpe2fs /dev/sda2 &gt; dumpe2fs.log</code>：导入信息到文本中</li><li><code>:set nu</code>：vim中设置行号</li><li><code>stat dumpe2fs.log</code>：查看具体文件（Inode、Blocks）</li></ul></li></ul></li></ul><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><ul><li>6-16：操作系统的设备管理<ul><li>广义的IO设备<ul><li>广义IO设备的概念：对CPU而言，数据的输入/输出，也就是输入/输出设备</li><li>广义IO设备的分类：按使用特性、信息交换的单位（b块设备、c字符设备）、设备的共享属性、传输速率</li></ul></li><li>IO设备的缓冲区<ul><li>缓冲区：CPU与IO设备的速率不匹配</li><li>缓冲池：操作系统划出可供多个进程使用的公共缓冲区</li></ul></li><li>SPOOLing技术（虚拟设备技术）<ul><li>概念： 是关于慢速字符设备如何与计算机主机交换信息的一种技术</li><li>SPOOLing技术把同步调用低速设备改为异步调用<ul><li>在输入、输出之间增加了排队转储环节（输入井、输出井）</li><li>SPOOLing负责输入（出）井与低速设备之间的调度 </li><li>逻辑上，进程直接与高速设备交互，减少了进程的等待时间            </li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络：概述-剑指Java</title>
      <link href="2019/10/13/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0-%E5%89%91%E6%8C%87Java/"/>
      <url>2019/10/13/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0-%E5%89%91%E6%8C%87Java/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Ch2-计算机网络"><a href="#Ch2-计算机网络" class="headerlink" title="Ch2-计算机网络"></a>Ch2-计算机网络</h1><h2 id="计网简介"><a href="#计网简介" class="headerlink" title="计网简介"></a>计网简介</h2><ul><li>2-1：网络基础知识讲解<ul><li>OSI开放式互联参考模型<ul><li>应用层：规定收发方必须使用固定长度的消息头 HTTP</li><li>表示层：解决不同系统之间的通信语法问题</li><li>会话层：自动收发包，自动寻址，不同机器上的用户之间建立和管理会话</li><li>传输层：接受上一层的数据，必要时进行分割，并将这些数据交给网络层，保证这些数据段有效到达 TCP、UDP</li><li>网络层：将网络地址翻译成对应的物理地址，如何将数据从发送方路由到接收方，路由器在这一层（数据报）IP</li><li>数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路，交换机在这一层</li><li>物理层：解决两台物理机之间的通信需求，传输比特流，定义了设备的物理标准，网卡在这一层</li></ul></li><li>TCP/IP：OSI七层模型概念的实现<ul><li>先自上而下，后自下而上处理数据头部</li><li>五层模型：物理层、数据链路层、网络层、传输层、应用层</li></ul></li></ul></li></ul><h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><ul><li>2-2~3：TCP的三次握手<ul><li>传输控制协议TCP简介</li><li>TCP报文头<ul><li>端口（协议端口）：进程通信标识</li><li>TCP Flags：URG、ACK、PSH、RST、SYN、FIN</li></ul></li><li>TCP的三次握手<ul><li><img src="/images/basic/network/1.jpg" alt="TCP的三次握手"> </li></ul></li><li>关于三次握手的问题<ul><li>为什么要进行三次握手才能建立起连接？<ul><li>为了初始化Sequence Number的初始值</li></ul></li><li>首次握手的隐患：SYN超时问题<ul><li>针对SYN Flood的防护措施</li></ul></li><li>建立连接后，Client出现故障怎么办？<ul><li>保活机制</li></ul></li></ul></li></ul></li><li>2-4：TCP的四次挥手<ul><li>TCP的四次挥手<ul><li><img src="/images/basic/network/2.jpg" alt="TCP的四次挥手"> </li></ul></li><li>关于四次挥手的问题<ul><li>为什么需要四次握手才能断开连接？<ul><li>因为全双工，收发方手续要FIN报文和ACK报文</li></ul></li><li>为什么会有TIME_WAIT状态？（等待2MSL）<ul><li>确保有足够的时间让对方收到ACK包</li><li>避免新旧连接混淆</li></ul></li><li>服务端出现大量CLOSE_WAIT状态的原因？</li></ul></li></ul></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>2-5：TCP和UDP的区别<ul><li>UDP报文结构<ul><li>Source Port、Destination Port、Length、Checksum、data octets</li></ul></li><li>UDP的特点<ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul></li><li>TCP和UDP的区别<ul><li>面向连接 vs 无连接</li><li>可靠性</li><li>有序性</li><li>速度</li><li>量级</li></ul></li></ul></li><li>2-6：TCP的滑窗<ul><li>TCP的两个概念：RTT和RTO<ul><li>RTT：发送一个数据包到收到对应的ACK，所花费的时间</li><li>RTO：重传时间间隔</li></ul></li><li>TCP使用滑动窗口做流量控制和乱序重排<ul><li>两个作用：保证TCP的可靠性和流控特性</li></ul></li></ul></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>2-7~8：HTTP相关<ul><li>超文本传输协议HTTP特点<ul><li>支持客户/服务器模式</li><li>简单快速</li><li>灵活</li><li>无连接</li><li>无状态</li></ul></li><li>HTTP请求结构<ul><li>HTTP请求报文</li></ul></li><li>HTTP响应结构<ul><li>协议版本、状态码、状态码描述（200：OK）</li></ul></li><li>请求/响应步骤<ul><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接收请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端浏览器解析HTML内容</li></ul></li><li>状态码<ul><li>五种可能的取值</li><li>1xx：指示信息—表示请求已接收，继续处理</li><li>2xx：成功—表示请求已被成功接收、理解、接受（200 OK）</li><li>3xx：重定向—要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误—请求有语法错误或请求无法实现<ul><li>（400 Bad Request、 401 Unauthorized、403 Forbidden、404 Not Found）</li></ul></li><li>5xx：服务器错误—服务器未能实现合法的请求（500 Internal Server Error、503 Server Unavaliable）</li></ul></li><li>浏览器键入URL按下回车后经历的流程<ul><li>浏览器根据URL进行DNS解析</li><li>找到IP地址后，进行TCP连接（三次握手）</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul></li><li>GET和POST的区别<ul><li>Http报文层面：GET将请求信息放在URL，POST放在报文体中</li><li>数据库层面：GET符合幂等性和安全性，POST不符合</li><li>其他层面：GET可以被缓存、被存储，而POST不行</li></ul></li><li>Cookie和Session的区别<ul><li>Cookie：是由服务器发给客户端的特殊信息，以文本形式存放在客户端，在HTTP响应头中</li><li>Session：服务器端的机制，在服务器上保存的信息</li><li>Cookie数据存放在客户的浏览器上，Session数据在服务器上</li><li>Session相对于Cookie更安全</li><li>若考虑减轻服务器负担，应当使用Cookie</li></ul></li></ul></li><li>2-9：HTTP和HTTPS的区别<ul><li>HTTPS（HyperText Transfer Protocol Secure，超文本传输安全协议）<ul><li>SSL（Security Sockets Layer，安全套接层），HTTP明文传输</li><li>加密方式：对称加密、非对称加密、哈希算法（MD5）、数字签名</li><li>数据传输流程</li></ul></li><li>HTTP和HTTPS 的区别<ul><li>HTTPS需要到CA申请证书，HTTP不需要</li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口<ul><li>HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全</li></ul></li></ul></li><li>HTTPS真的安全吗？<ul><li>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</li><li>可以使用HSTS（HTTP Strict Transport Security）优化 </li></ul></li></ul></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li>2-10：socket相关<ul><li>Socket：是TCP/IP协议的抽象，是操作系统对外开放的接口<ul><li><img src="/images/basic/network/3.jpg" alt="Socket"> </li></ul></li><li>Socket通信<ul><li><img src="/images/basic/network/4.jpg" alt="Socket通信"> </li></ul></li><li>Socket相关面试题<ul><li>TCP实现客户端和服务器的通信</li><li>UDP实现客户端和服务器的通信</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-imooc</title>
      <link href="2019/09/22/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-imooc/"/>
      <url>2019/09/22/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-imooc/</url>
      
        <content type="html"><![CDATA[<h1 id="一、常用数据结构"><a href="#一、常用数据结构" class="headerlink" title="一、常用数据结构"></a>一、常用数据结构</h1><p>常见的三种结构：线性结构（数组、栈、队列、链表、哈希表），树结构（二叉树、堆、线段树、Trie、并查集、AVL、红黑树），图结构</p><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/linear/ArrayList.java" target="_blank" rel="noopener">code</a></p><ul><li>添加：<code>list.add(e)</code>，O(n)<ul><li><code>list.addFirst(e)</code>，O(n)</li><li><code>list.addLast(e)</code>，<strong>O(1)</strong></li></ul></li><li>删除：<code>list.remove(index)、list.remove(e)</code>，O(n)<ul><li><code>list.removeFirst()</code>，O(n)</li><li><code>list.removeLast()</code>，<strong>O(1)</strong></li></ul></li><li>查找：<code>list.get(index)</code>，<strong>O(1)</strong></li><li>修改：<code>list.set(index, e)</code>，O(n)</li><li>包含：<code>list.contains(e)</code>，O(n)</li><li>扩容：<code>grow()</code><ul><li>add时<code>grow(2*data.length)</code></li><li>remove时<code>grow(data.length/2)</code>（但size==data.length/4）</li></ul></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/linear/Stack.java" target="_blank" rel="noopener">code</a></p><ul><li>入栈：<code>stack.push(e)</code>，O(1)</li><li>出栈：<code>stack.pop()</code>，O(1)</li><li>查看栈顶：<code>stack.peek()</code>，O(1)</li><li>判断是否为空：<code>stack.empty()</code></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Pair&lt;Integer, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt;();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/linear/Queue.java" target="_blank" rel="noopener">code</a></p><ul><li>入队：<code>queue.add(e)</code>，O(logn)</li><li>出队：<code>queue.poll()</code>，O(logn)</li><li>查看队首：<code>queue.peek()</code>，O(1)</li><li>判定是否为空：<code>queue.isEmpty()</code></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/linear/LinkedList.java" target="_blank" rel="noopener">code</a></p><ul><li>添加：<code>list.add(e)</code>，O(n)<ul><li><code>list.addFirst(e)</code>，<strong>O(1)</strong></li><li><code>list.addLast(e)</code>，O(n)</li></ul></li><li>删除：<code>list.remove(index)、list.remove(e)</code>，O(n)<ul><li><code>list.removeFirst()</code>，<strong>O(1)</strong></li><li><code>list.removeLast()</code>，O(n)</li></ul></li><li>查找：<code>list.getFirst()</code>，<strong>O(1)</strong>、<code>list.getLast()</code>，O(n)</li><li>修改：<code>list.set(index, e)</code>，O(n)</li><li>包含：<code>list.contains(e)</code>，O(n)</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line">TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;Integer, Integer&gt;();</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/tree/BST.java" target="_blank" rel="noopener">code</a></p><ul><li>添加：<code>bst.add(e)</code>，O(logn)</li><li>删除：<code>bst.remove(e)</code>，O(logn)</li><li>包含：<code>bst.contains(e)</code>，O(logn)</li><li>遍历<ul><li>前序遍历：<code>bst.preOrder()</code>，O(n)，可借助Stack</li><li>中序遍历：<code>bst.inOrder()</code>，O(n)</li><li>后序遍历：<code>bst.postOrder()</code>，O(n)</li><li>层序遍历：<code>bst.levelOrder()</code>，O(n)，可借助Queue</li></ul></li><li>最值：<ul><li>最大值：<code>bst.maximum()</code>，O(logn)</li><li>最小值：<code>bst.minimum()</code>，O(logn)</li></ul></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt;(new PairComparator());</span><br></pre></td></tr></table></figure><p><a href="https://github.com/louisgry/Algorithm/tree/master/data-structure/src/tree/Heap.java" target="_blank" rel="noopener">code</a></p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h3 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="图的基础"><a href="#图的基础" class="headerlink" title="图的基础"></a>图的基础</h3><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h1 id="二、排序查找算法"><a href="#二、排序查找算法" class="headerlink" title="二、排序查找算法"></a>二、排序查找算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>插入排序思想：两层for循环，if后面(arr[j])比前面(arr[j-1)小则swap，否则break</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li>迭代版：O(logn)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// l==r时，[l, r]区间依然有效</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>递归版：O(logn)，递归深度是logn（每次减少一半）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, l, mid-<span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, mid+<span class="number">1</span>, r, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、算法分析"><a href="#三、算法分析" class="headerlink" title="三、算法分析"></a>三、算法分析</h1><h2 id="如何解题"><a href="#如何解题" class="headerlink" title="如何解题"></a>如何解题</h2><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li>注意题目的条件：有序、10^7规模、logn…</li><li>正确是相对的：“对一组数据进行排序？”<ul><li>有大量重复元素：三路快排</li><li>近乎有序：插入排序</li><li>取值范围有限 (学生成绩)：计数排序</li><li>稳定排序：归并排序</li><li>链表存储、内存：外排序</li></ul></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>没有思路时：简单用例、暴力解法</li><li>常规思路<ul><li>遍历常见的数据结构</li><li>遍历常见的算法思路</li><li>用空间换时间（哈希表）</li><li>数据预处理（排序）</li></ul></li></ul><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><ul><li><code>O(f(n))</code>：表示运行算法所需要执行的指令数，和f(n)成正比（表示算法执行的最低上界，最好能这么好）</li><li>量级不同不能省略：O(AlogA+B)<ul><li>如，邻接表图遍历：O(V+E)</li></ul></li><li>一个时间复杂度问题<ul><li>字符串数组先将每一个字符串排序，再对数组进行字典序排序</li><li>不是：O(n*nlogn+nlogn)=O(n^2logn)</li><li>而是：O(n<em>slogs+s</em>nlogn)，s字符串最长长度，n数组长度</li></ul></li><li>算法复杂度在某些情况下是用例相关的，但一般关于平均情况</li></ul><h3 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h3><ul><li>要想在1s内解决问题<ul><li>O(n^2) -&gt; 10^4</li><li>O(n) -&gt; 10^8</li><li>O(nlogn) -&gt; 10^7</li></ul></li><li>对比：O(n)、O(n^2)、O(logn)、O(nlogn)<ul><li>O(n) ==&gt; 规模增加两倍，时间翻一倍（findMax）</li><li>O(n^2) ==&gt; 规模增加两倍，时间翻四倍（selectionSort）</li><li>O(logn) ==&gt; 规模增加两倍，2亿数据规模时间也不到1ms（binarySearch）</li><li>O(nlogn) ==&gt; 规模增加两倍，时间差不多翻一倍 （mergeSort）</li></ul></li></ul><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>logn：二分查找：n经过几次除以2操作后等于1（log2n）、intToString（log10n）</li><li>2^n：斐波那契数列，f(n) = f(n-1) + f(n-2)（每次乘以2）</li><li>sqrt(n)：判定是否为素数，<code>for(int i=2; i*i&lt;=n; i++)</code></li></ul><h3 id="递归复杂度分析"><a href="#递归复杂度分析" class="headerlink" title="递归复杂度分析"></a>递归复杂度分析</h3><ul><li>递归的空间复杂度：递归深度多少，空间复杂度就是多少（系统栈存储的状态个数）</li><li>递归方程及复杂度分析：公式法/主定理<ul><li>$T(n)=aT(n/b)+f(n)$</li><li>若$O(n^{log_ba}) &gt; f(n)$：$O(n^{log_ba})$</li><li>若$O(n^{log_ba}) &lt; f(n)$：$f(n)$</li><li>若$O(n^{log_ba}) = f(n)$：$O(n^{log_ba})*logn$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ebbinghaus </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data-imooc</title>
      <link href="2019/08/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Spring/Spring%20Data-imooc/"/>
      <url>2019/08/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Spring/Spring%20Data-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="轻松愉快之玩转SpringData"><a href="#轻松愉快之玩转SpringData" class="headerlink" title="轻松愉快之玩转SpringData"></a>轻松愉快之玩转SpringData</h2><p><a href="https://github.com/louisgry/Programming/tree/master/Spring/springdata" target="_blank" rel="noopener">https://github.com/louisgry/Programming/tree/master/Spring/springdata</a></p><ul><li>Ch1：课程介绍<ul><li>Spring Data：简化数据库的访问方式</li><li>包含多个子项目：Spring Data JPA、MongoDB、Redis、Solr</li></ul></li><li>Ch2：使用传统方式访问数据库<ul><li>学习新技术之前，先学习为什么要用这个技术</li><li>传统方式：JDBC、Spring JdbcTemplate</li><li>JDBC：<code>Connection、Statement、ResultSet</code>、Test Case（单元测试）</li><li>Maven：GAV（GroupId、ArtifactId、Version）</li><li>使用JDBC<ol><li>新建Maven项目，配置db.properties</li><li>创建数据库和表（spring_data库：student表）</li><li>开发JDBCUtil工具类：util下编写JDBCUtil类</li><li>建立对象模型和DAO层开发：StudentDAO、StudentDAOImpl</li></ol></li><li>使用Spring JdbcTemplate<ol><li>Maven依赖</li><li>配置beans.xml（DataSource &amp; JdbcTemplate注入）</li><li>编写接口实现类StudentDAOSpringJdbcImpl</li><li>Test Case：DataSourceTest、StudentDAOSpringJdbcImplTest</li></ol></li><li>弊端分析<ul><li>DAO很多代码</li><li>DAOImpl很多重复代码</li><li>开发分页功能还需重新封装</li></ul></li></ul></li><li>Ch3：Spring Data快速入门<ul><li>使用Spring Data<ol><li>Maven依赖（spring-data-jpa、hibernate-entitymanager）</li><li>配置beans-new.xml（一共5个步骤）</li><li>domain中添加Employee实体类</li><li>编写SpringDataTest测试类（testEntityManagerFactory方法）</li><li>repository中添加EmployeeRepository接口</li><li>编写EmployeeRepositoryTest测试类（testFindByName方法）</li></ol></li><li>Spring Data优点<ul><li>只需要写Interface，不用写实现类（findByName）</li></ul></li></ul></li><li>Ch4：Spring Data JPA进阶<ul><li>Repository接口讲解<ul><li>Repository接口（标记接口，里面是空的）是Spring Data的核心接口，不提供任何方法</li><li>1.继承：<code>public interface Repository&lt;T, ID extends Serializable&gt;{}</code></li><li>2.注解：<code>@RepositoryDefinition(domainClass=Employee.class, idClass=Integer.class)</code></li></ul></li><li>Repository子接口<ul><li>CrudRepository</li><li>PageAndSortingRepository</li><li>JpaRepository</li></ul></li><li>Repository查询方法定义规则和使用<ul><li>命名规则：findByNameInOrAgeLessThan</li></ul></li><li>Query注解<ul><li>方式一：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name=?1 and o.age=?2"</span>)</span><br></pre></td></tr></table></figure></li><li>方式二：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select o from Employee o where o.name=:name and o.age=:age"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">queryParams2</span><span class="params">(@Param(<span class="string">"name"</span>)</span>String name, @<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span>Integer age)</span>;</span><br></pre></td></tr></table></figure></li><li>方式三：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(nativeQuery = <span class="keyword">true</span>, value = <span class="string">"select count(1) from employee"</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li>更新操作整合事务使用<ul><li><code>@Modifying</code>注解</li><li>事务一般是在Service层</li><li><code>@Transactional</code>添加事务</li></ul></li></ul></li><li>Ch5：Spring Data JPA高级<ul><li>CrudRepository<ul><li>repository下新建EmployeeCrudRepository接口</li><li>service下编写save方法</li><li>test下测试save方法 </li></ul></li><li>PageAndSortingRepository<ul><li>repository下新建EmployeePageAndSortingRepository接口</li><li>test下测试testPage方法 </li><li>test下测试testPageAndSort方法 </li></ul></li><li>JpaRepository<ul><li>repository下新建EmployeeJpaRepositoryRepository接口</li><li>test下测试testFindOne方法 </li></ul></li><li>JpaSpecificationExecutor<ul><li>repository下新建EmployeeJpaSpecificationExecutorRepository接口（继承JpaRepository和JpaSpecificationExecutor）</li><li>test下测试testQuery方法（age&gt;50，id降序，分页） </li></ul></li></ul></li><li>Ch6：课程总结<ul><li>SpringData支持关系型和非关系型数据库</li><li>传统方式访问数据库</li><li>Spring Data入门及高阶</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot-imooc</title>
      <link href="2019/08/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Spring/Spring%20Boot-imooc/"/>
      <url>2019/08/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Spring/Spring%20Boot-imooc/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h2><p><a href="https://github.com/louisgry/Programming/tree/master/Spring/springboot" target="_blank" rel="noopener">https://github.com/louisgry/Programming/tree/master/Spring/springboot</a></p><ul><li>Ch1：课程引导<ul><li>Spring Boot：编码、配置、部署、监控（作基础架构）<ul><li>1.化繁为简、简化配置</li><li>2.是下一代框架</li></ul></li><li>SpringBoot是SpringMVC的升级版</li><li>微服务：SpringCloud是基于SpringBoot构建的</li></ul></li><li>Ch3：第一个Spring Boot应用<ul><li><code>Spring Boot 2.1.3</code>：sping-boot-starter-web</li><li>localhost:8080/hello</li><li>本地使用maven运行服务<ul><li>方法一：项目目录下，<code>mvn spring-boot:run</code></li><li>方法二：先项目打包<code>mvn clean package</code>，然后启动java程序<code>java -jar target/springboot-0.0.1-SNAPSHOT.jar</code></li></ul></li></ul></li><li>Ch4：项目属性配置<ul><li>配置推荐使用application.yml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /springboot</span><br></pre></td></tr></table></figure></li><li>配置变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minMoney: 1</span><br><span class="line">description: &quot;最小金额$&#123;minMoney&#125;元&quot;</span><br></pre></td></tr></table></figure></li><li>注解使用<ul><li><code>@Value</code></li><li><code>@Component、@ConfigurationProperties</code></li></ul></li><li>使用对象配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit:</span><br><span class="line">  minMoney: 2</span><br><span class="line">  description: &quot;最小金额$&#123;limit.minMoney&#125;元&quot;</span><br></pre></td></tr></table></figure></li><li>多环境配置：划分配置为开发dev、生产pro<ul><li>application-dev.yml、application-pro.yml</li><li>application.yml中配置使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure></li><li>项目发布使用pro：<code>java -jar -Dspring.profiles.active=pro target/springboot-0.0.1-SNAPSHOT.jar</code></li></ul></li></ul></li><li>Ch5：Controller<ul><li><code>@Controller</code>：处理http请求<ul><li>返回数据需要使用模板：<code>spring-boot-starter-thymeleaf</code></li></ul></li><li><code>@RestController</code>：Spring4之前返回原来json需要@ResponseBody配合@Controller<ul><li><code>@GetMapping</code>：返回json</li><li><code>ctrl+p</code>：显示提示</li><li><code>@PostMapping</code>：使用POST请求</li><li>需要使用工具：PostMan    </li></ul></li><li><code>@RequestMapping</code>：配置url映射<ul><li><code>@RequestMapping</code>：既支持GET又支持POST（不推荐）</li><li><code>@PathVariable</code>：say/100 （@GetMapping(“/say/{id}”)）</li><li><code>@RequestParam</code>：say/?id=100<ul><li>PostMan通过Body传参：<code>x-www-form-urlencoded</code></li></ul></li></ul></li></ul></li><li>Ch6：数据库操作<ul><li>JPA（Java Persistence API）：对象持久化标准，Hibernate实现<ul><li>配置文件application.yml：注意<code>username、url、serverTimezone、MySQL5Dialect</code></li></ul></li><li>RESTful API设计<ul><li>GET  /luckymoneys/list 获取红包列表</li><li>POST /luckymoneys/send 创建一个红包（发红包）</li><li>GET  /luckymoneys/find 通过id查询红包</li><li>POST  /luckymoneys/receive  通过id更新红包（领红包）</li></ul></li><li>dataobject<ul><li>Luckymoney类：<code>@Entity</code></li></ul></li><li>repository<ul><li>LuckymoneyRepository接口：<code>extends JpaRepository&lt;Luckymoney, Integer&gt;</code></li></ul></li><li>controller<ul><li>LuckymoneyController类</li><li><code>@RestController</code>：开发REST服务</li><li><code>@Autowired</code>：自动装配</li><li><code>@GetMapping</code>：返回json</li><li>error：found Optional（后面加<code>.orElse(null)</code>）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Luckymoney&gt; optional = luckymoneyRepository.findById(id);</span><br><span class="line">    <span class="keyword">if</span>(optional.isPresent())&#123;</span><br><span class="line">        Luckymoney luckymoney = optional.get();</span><br><span class="line">        luckymoney.setId(id);</span><br><span class="line">        luckymoney.setConsumer(consumer);</span><br><span class="line">        <span class="keyword">return</span> luckymoneyRepository.save(luckymoney);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>url：<code>yml里的端口+context-path+RequestMapping+GetMapping路径</code> </li><li>hibernate_sequence：用来存id，管理数据库的</li></ul></li><li>Ch7：事务<ul><li>service<ul><li>LuckymoneyService类：<code>@Service</code></li><li>事务：<code>@Transacational</code> （只有都成功才会插入到数据库中）</li><li>MySQL只有InnoDB引擎支持事务</li></ul></li></ul></li></ul><h2 id="SpringBoot进阶"><a href="#SpringBoot进阶" class="headerlink" title="SpringBoot进阶"></a>SpringBoot进阶</h2><p><a href="https://github.com/louisgry/Programming/tree/master/Spring/springboot" target="_blank" rel="noopener">https://github.com/louisgry/Programming/tree/master/Spring/springboot</a></p><ul><li>Ch1：课程介绍<ul><li>Web进阶<ol><li><code>@Valid</code>表单验证</li><li>AOP处理请求</li><li>统一异常处理</li><li>单元测试</li></ol></li></ul></li><li>Ch2：表单验证<ul><li>Girl对象： <code>@min</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Min</span>(value = <span class="number">18</span>, message = <span class="string">"未成年少女禁止进入"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure></li><li>GirlController：<code>@Valid</code>、传对象Girl girl<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">girlAdd</span><span class="params">(@Valid Girl girl, BindingResult bindingResult)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        System.out.println(bindingResult.getFieldError().getDefaultMessage());&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Ch2：AOP处理请求<ul><li>AOP是一种编程范式<ul><li>与语言无关，是一种编程思想，还有OOP和面向过程</li><li>不只是Java有，还有C#等也有AOP</li><li>切面：相同的功能封装成为一个通用的模块（将通用逻辑从业务中分离出来）</li><li>spring不会初始化controller的构造方法</li></ul></li><li>aspect<ul><li>添加依赖<code>spring-boot-starter-aop</code></li><li>新建HttpAspect类：<code>@Aspect</code>、<code>@Component</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.imooc.springboot.controller.GirlController.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"log()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>Ch2：日志框架<ul><li><code>org.slf4j.Logger</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(HttpAspect.class);</span><br></pre></td></tr></table></figure></li></ul></li><li>Ch2：统一异常处理<ul><li>exception<ul><li>新建GirlException类：<code>extends RuntimeException</code>（Spring只对RuntimeException作事务回滚）</li></ul></li><li>handle<ul><li>新建ExceptionHandle类：<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code>、<code>@ResponseBody</code></li></ul></li><li>enums<ul><li>ResultEnum枚举类：构造方法和Getter方法</li></ul></li></ul></li><li>Ch3：单元测试<ul><li>对controller做单元测试：<code>@AutoConfigureMockMvc</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">girlList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 测试status</span></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/girls"</span>))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.status().isOk());</span><br><span class="line">    <span class="comment">//测试content</span></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/girls"</span>))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.content().string(<span class="string">"abc"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Maven打包时跳过单元测试：<code>mvc clean package -Dmaven.test.skip=true</code></li></ul></li></ul><h2 id="SpringBoot2-0"><a href="#SpringBoot2-0" class="headerlink" title="SpringBoot2.0"></a>SpringBoot2.0</h2><ul><li>Ch1：<ul><li>Spring Boot 2.0 新特性<ul><li>编程语言：Java8+、Kotlin</li><li>底层框架：Spring Framework  5.0x</li><li>全新特性：Web Flux</li></ul></li><li>Web Flux<ul><li>函数式编程：Java 8 Lambda</li><li>响应式编程：Reactive Streams</li><li>异步编程：Servlet 3.1或Asyc NIO</li></ul></li></ul></li><li>Ch2：Spring Boot 项目<ul><li>场景说明<ul><li>定义用户模型，属性：用户Id、名称</li><li>客户端发送POST请求，创建用户（Web MVC）</li><li>客户端发送GET请求，获取所有用户（Web Flux）</li></ul></li><li>Web Flux<ul><li>项目：<code>Reactive Web</code></li><li>依赖：<code>spring-boot-starter-webflux</code></li><li>Console：PID、Netty、RequestMappingHandlerMapping</li></ul></li><li>domian<ul><li>新建User类</li><li><code>int id;</code></li><li><code>String name;</code></li><li><code>toString()</code></li></ul></li><li>repository<ul><li>UserRepository</li><li><code>@Repository</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用内存型的存储方式 -&gt; Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer, User&gt; repository = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Id 自增长</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger idGenerator = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 保存用户对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    Integer id = idGenerator.incrementAndGet(); <span class="comment">// 从1开始</span></span><br><span class="line">    user.setId(id);</span><br><span class="line">    <span class="keyword">return</span> repository.put(id, user) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>controller<ul><li>新建UserController：<code>@RestController</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserRepository userRepository)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/person/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="keyword">if</span>(userRepository.save(user))&#123;</span><br><span class="line">        <span class="comment">// 格式化输出System.out.printf</span></span><br><span class="line">        System.out.printf(<span class="string">"用户对象：%s 保存成功！\n"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>Ch2：Web Flux<ul><li>Reactive<ul><li>Reactor是异步NIO，是Reactive的一种实现</li></ul></li><li>两个概念<ul><li>Flux：0-N个对象集合</li><li>Mono：0-1个对象集合，类似Optional避免对象为空（但是flux和mono异步处理）</li><li>Flux和Mono都是Publisher</li></ul></li><li>config<ul><li>新建RouterFunctionConfiguratioin：<code>@Configuration</code></li><li>RouterFunction、ServerResponse</li><li>Servlet<ul><li>请求接口：ServletRequest 或 HttpServletRequest</li><li>响应接口：ServletResponse 或 HttpServletResponse</li></ul></li><li>Spring 5.0 重新定义了接口<ul><li>请求接口：ServerRequest</li><li>响应接口：ServerResponse</li><li>即可支持Servlet规范，也支持自定义规范：如Netty Web Server</li></ul></li><li>注入方式<ul><li>setter注入</li><li>注解注入</li><li>构造器注入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">personFindAll</span><span class="params">(UserRepository userRepository)</span></span>&#123;</span><br><span class="line">    Collection&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">    <span class="keyword">return</span> RouterFunctions.route(RequestPredicates.GET(<span class="string">"/persion/list-webflux"</span>),</span><br><span class="line">            request -&gt; &#123;</span><br><span class="line">                <span class="comment">// 返回所有的用户对象</span></span><br><span class="line">                Mono&lt;ServerResponse&gt; responseMono = <span class="keyword">null</span>;</span><br><span class="line">                Flux&lt;User&gt; userFlux = Flux.fromIterable(users);</span><br><span class="line">                <span class="keyword">return</span> ServerResponse.ok().body(userFlux, User.class);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>Ch3：多模块<ul><li>项目下新建module</li><li>子模块的pom的<code>parent</code>修改为父模块的<ul><li>模型层：model（domain：User）</li><li>持久层：persistence（repository：UserRepository）</li><li>表示层：view（controller：UserController）</li></ul></li><li>依赖关系：web -&gt; persistence -&gt; model</li></ul></li><li>Ch4：Spring Boot三大特性<ul><li>自动装配</li><li>嵌入式容器</li><li>DevOps</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门第三季-imooc</title>
      <link href="2019/06/14/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%89%E5%AD%A3-imooc/"/>
      <url>2019/06/14/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%89%E5%AD%A3-imooc/</url>
      
        <content type="html"><![CDATA[<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>概念<ul><li>Throwable是父类，下有Error和Exception两个子类</li><li>Error：VirtualMachineError（虚拟机错误），ThreadDeath（线程死锁）</li><li>Exception：RuntimeException（非检查异常），CheckedException 检查异常<ul><li>非检查异常：NullPointerException, ArrayIndexOutOfBoundsException, ClassCatException, ArithmeticException</li><li>检查异常：IOException, SQLException</li></ul></li></ul></li><li>异常处理<ul><li><code>try...catch</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"输入年龄："</span>);</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> age = in.nextInt();</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InputMismatchException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"请输入整数！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多重catch块（先子类后父类）及<code>try...catch...finally</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> one = in.nextInt();</span><br><span class="line">    <span class="keyword">int</span> two = in.nextInt();</span><br><span class="line">    System.out.println(one/two);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InputMismatchException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"请输入整数！"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"除数不能为零！"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">"程序发生异常！"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"finally执行！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>异常抛出<ul><li>throw关键字：throws声明将要抛出何种类型的异常，throw抛出异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>自定义异常<ul><li>class 自定义异常类 extends 异常类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrunkException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrunkException</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrunkException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>异常链<ul><li>示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> DrunkException</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DrunkException(<span class="string">"喝酒不开车！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DrunkException e) &#123;</span><br><span class="line">        RuntimeException newExc = <span class="keyword">new</span> RuntimeException(<span class="string">"禁止开车"</span>);</span><br><span class="line">        newExc.initCause(e);</span><br><span class="line">        <span class="comment">// RuntimeException newExc = new RuntimeException(e);</span></span><br><span class="line">        <span class="keyword">throw</span> newExc;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    exception hello = <span class="keyword">new</span> exception();</span><br><span class="line">    <span class="comment">// 异常链</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul><li><p>字符串</p><ul><li>字符串的不变性<ul><li><code>String s1 = &quot;imooc&quot;</code>不等于<code>String s2 = new String(&quot;imooc&quot;)</code></li><li>每次new一个字符串会产生一个新的对象，即使内容相同对于==运算是fasle（比较内容用equals）</li></ul></li><li>String类的常用方法<ul><li><code>length()，indexOf(), substring()</code></li><li>字符串索引不能用s[i]，要用<code>s.charAt(i)</code></li></ul></li><li>文件名和邮箱格式验证<ul><li>练习<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String fileName = <span class="string">"immoc.com.java"</span>;</span><br><span class="line">String email = <span class="string">"louis@imooc.com"</span>;</span><br><span class="line"><span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">'.'</span>); <span class="comment">// 最后一次出现"."的位置</span></span><br><span class="line">String prefix = fileName.substring(index+<span class="number">1</span>); <span class="comment">// 获取文件后缀名</span></span><br><span class="line"><span class="keyword">int</span> index2 = email.indexOf(<span class="string">'@'</span>);</span><br><span class="line"><span class="keyword">int</span> index3 = email.indexOf(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span> &amp;&amp; index !=<span class="number">0</span> &amp;&amp; prefix.equals(<span class="string">"java"</span>))&#123;</span><br><span class="line">    <span class="comment">// "."存在，且不能在首位，文件后缀名是java</span></span><br><span class="line">    System.out.println(<span class="string">"文件名正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(index2 != -<span class="number">1</span> &amp;&amp; index2 &lt; index3)&#123;</span><br><span class="line">    <span class="comment">// "@"存在，且在"."之前</span></span><br><span class="line">    System.out.println(<span class="string">"邮件格式正确"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>StringBuilder与StringBuffer类<ul><li>为什么：String类具有不可变性，频繁操作字符串时会产生很多额外的临时变量，可以用StringBuilder与StringBuffer类</li><li>区别：StringBuffer是线程安全的，StringBuilder无，故性能较好<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"imooc"</span>);</span><br><span class="line">str1.append(<span class="string">" hello"</span>);</span><br><span class="line">str1.insert(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(str1);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>包装类</p><ul><li>作用：为了让基本数据类型也具备对象的特性</li><li>举例：Integer，Float，Double</li><li>自动装箱和拆箱机制（JDK1.5）<ul><li>装箱（把基本类型转换成包装类）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">5</span>); <span class="comment">// 手动</span></span><br><span class="line">Integer y = <span class="number">5</span>; <span class="comment">// 自动</span></span><br></pre></td></tr></table></figure></li><li>拆箱（包装类 -&gt; 基本类型）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = x.intValue(); <span class="comment">// 手动</span></span><br><span class="line"><span class="keyword">int</span> n = x; <span class="comment">// 自动</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>基本类型与字符串的转换</p><ul><li>基本类型 -&gt; 字符串：<ol><li>包装类的toString()</li><li>String类的valueOf()</li><li>空字符串””+基本类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">String str1 = Integer.toString(a);</span><br><span class="line">String str2 = String.valueOf(a);</span><br><span class="line">String str3 = <span class="string">""</span>+a;</span><br></pre></td></tr></table></figure></li></ol></li><li>字符串 -&gt; 基本类型：<ol><li>包装类的parseXXX方法</li><li>包装类的valueOf()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = Integer.parseInt(str);</span><br><span class="line"><span class="keyword">int</span> c = Integer.valueOf(str);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>Date类</p><ul><li>导入：<code>java.util.Date</code></li><li>格式化输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String today = sdf.format(d);</span><br></pre></td></tr></table></figure></li><li>文本转时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String day = <span class="string">"2014年6月1日 21:05:36"</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">Date d = sdf.parse(day);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Calendar类</p><ul><li>示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">// MONTH, DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, SECOND</span></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR); </span><br><span class="line">Date d = c.getTime();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Math类</p><ul><li>取整：<code>round()，floor()，ceil()</code></li><li><code>random()</code>：返回[0,1)之间的随机浮点数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) Math.random()*<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><ul><li>概念：Collection和Map<ul><li>Collection：List (ArrayList)、Queue (LinkedList)、Set (HashSet)</li><li>Map：HashMap</li><li>重要的接口和类：Collection接口、Map接口、Collections工具类、Comparable接口、Comparator接口</li></ul></li><li>List接口方法<ul><li>初始化：<code>List coursesList = new ArrayList()</code></li><li><code>add()</code>：<code>coursesList.add(new Course(&quot;1&quot;,&quot;Java&quot;)</code></li><li><code>get()</code>：<code>Course tmp = (Course) coursesList.get(0)</code></li><li><code>addAll()</code>：<code>coursesList.addAll(Arrays.asList({new Course(&quot;2&quot;,&quot;Python&quot;), new Course(&quot;3&quot;,&quot;C++&quot;}))</code></li><li><code>set()</code>：<code>coursesList.set(0, new Course(&quot;4&quot;,&quot;Algorithm&quot;))</code></li><li><code>remove()</code>：<code>coursesList.remove(coursesList.get(0)) //.remove(0)</code></li></ul></li><li>Set接口方法<ul><li>同List的方法</li><li>初始化：<code>Set&lt;Course&gt; courses = new HashSet&lt;Course&gt;()</code></li><li><code>add()</code>：<code>student.courses.add(new Course(&quot;1&quot;,&quot;Java&quot;))</code></li></ul></li><li>Map接口方法<ul><li>初始化：<code>Map&lt;String, Student&gt; students = new HashMap&lt;String, Student&gt;()</code></li><li><code>put()</code>：<code>students.put(ID, newStu)</code>（同时可以修改）</li><li><code>remove()</code>：<code>students.remove(id)</code></li><li>keySet<ul><li><code>keySet()</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = students.keySet();</span><br><span class="line">System.out.println(<span class="string">"size: "</span>+students.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String id: keySet)&#123;</span><br><span class="line">    Student stu = students.get(id);</span><br><span class="line">    <span class="keyword">if</span>(stu != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student "</span>+stu.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>entrySet<ul><li><code>getKey()</code> 和<code>getValue()</code> 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;String, Student&gt;&gt; entrySet = students.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Student&gt; entry: entrySet)&#123;</span><br><span class="line">    System.out.println(<span class="string">"key: "</span>+entry.getKey() + <span class="string">", value: "</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>集合框架的查询<ul><li><code>contains()</code>：测试List是否存在某课程（但是不同对象就有不同值）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Course c = (Course) coursesList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(coursesList.contains(c)); <span class="comment">// true</span></span><br><span class="line">Course c2 = <span class="keyword">new</span> Course(c.id, c.name);</span><br><span class="line">System.out.println(coursesList.contains(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>解决方法：重写<code>equals()</code>方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Course))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Course c = (Course) obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.name == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(c.name))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```    </span><br><span class="line">    - `contains()`：判断Set中课程是否存在</span><br><span class="line">        - 存在跟List相同的问题，需重写`equals()`和`hashCode()`</span><br><span class="line">        - 但是，有bug！写完还是输出<span class="keyword">false</span></span><br><span class="line">    - `indexOf()`：查询位置</span><br><span class="line">        - `coursesList.indexOf(c3)`</span><br><span class="line">    - `contains()`：判断Map中课程是否存在</span><br><span class="line">        - `students.containsKey(id)`</span><br><span class="line">        - `students.containsValue(name)`</span><br><span class="line">- Comparable 和 Comparator 接口</span><br><span class="line">    - `Collections.sort()`：可对基本类型进行排序</span><br><span class="line">    ```java</span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collections.sort(integerList);</span><br><span class="line">    Collections.sort(stringList);</span><br><span class="line">    <span class="comment">// 问题：不能对Student这样的自定义类排序</span></span><br><span class="line">    Collections.sort(studentList); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li>Comparable接口：默认比较规则（<code>compareTo()</code>）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 重写Student类的compareTo方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id.compareTo(o.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Collections.sort(studentList);</span><br></pre></td></tr></table></figure></li><li>Comparator接口：临时比较规则（<code>compare()</code>）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建StudentComparator类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Collections.sort(studentList, <span class="keyword">new</span> StudentComparator());</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门第二季-imooc</title>
      <link href="2019/06/05/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%AD%A3-imooc/"/>
      <url>2019/06/05/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%AD%A3-imooc/</url>
      
        <content type="html"><![CDATA[<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><a id="more"></a><ul><li>概念<ul><li>类是模子，确定对象将会拥有的属性和方法</li></ul></li><li>构造方法<ul><li><code>new</code>关键字后面跟的就是<strong>构造方法</strong>（构造方法与类名相同，没有返回值）</li><li>若自己定义有参的构造方法，系统不会自动创建无参的构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Telphone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Telphone</span><span class="params">(<span class="keyword">float</span> newCpu)</span></span>&#123;</span><br><span class="line">        cpu = newCpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>static关键字<ul><li>static静态变量<ul><li><code>static String name = &quot;Java&quot;;</code></li><li>调用：<code>hello.name</code>（静态变量属于整个类所有）</li></ul></li><li>static静态方法<ul><li>静态方法中可以直接调用静态变量，非静态变量需先实例化，非静态方法也需实例化。</li><li>普通方法可以直接调用静态和非静态变量</li></ul></li></ul></li><li>静态初始化块<ul><li>初始化块(Initialization Block)：<a href="https://blog.csdn.net/p106786860/article/details/18838435" target="_blank" rel="noopener">Java：初始化块</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    num2 = <span class="number">74</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态初始化块：最先执行（且只加载一次，再次创建对象时不会被再次执行），然后是初始化块，最后是构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    num3 = <span class="number">83</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3></li></ul></li><li>概念<ul><li>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</li><li>实现步骤：1.修改属性可见性；2.Getter和Setter方法</li></ul></li><li>Java中的包<ul><li>包的作用：1.管理Java文件；2.解决同名文件冲突</li><li>定义包：<code>package com.imooc</code>（全小写）</li><li>调用包：<code>import com.imooc.Telphone</code></li></ul></li><li>访问修饰符<ul><li>private：本类</li><li>默认：本类+同包</li><li>protected：本类+同包+子类</li><li>public：本类+同包+子类+其他</li></ul></li><li>this关键字<ul><li>this关键字代表当前对象（this.属性、this.方法）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(<span class="keyword">float</span> screen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.screen = screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Java中的内部类<ul><li>四种内部类（Inner Class）：成员内部类、静态内部类、方法内部类、匿名内部类</li><li>成员内部类：使用类名+this访问同名的外部类变量；使用外部类对象创建内部类对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"imooc"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"爱慕课"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"外部类中的name："</span> + HelloWorld.<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">"内部类中的name："</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorld hello = <span class="keyword">new</span> HelloWorld (); </span><br><span class="line">        Inner inn = hello.new Inner() ;</span><br><span class="line">        inn.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态内部类（static修饰）<ul><li>不能直接访问外部类的非静态成员</li><li>外部类静态成员与内部类成员名称相同时：可用类名.静态成员调用 </li><li>创建对象不需要通过外部类对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> score = <span class="number">84</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">91</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"访问外部类中的score："</span> + HelloWorld.score);</span><br><span class="line">            System.out.println(<span class="string">"访问内部类中的score："</span> + score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SInner si = <span class="keyword">new</span> SInner();</span><br><span class="line">        si.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>方法内部类（定义在外部类的方法中）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"爱慕课"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MInner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">83</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> score + <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MInner mi = <span class="keyword">new</span> MInner();</span><br><span class="line">        <span class="keyword">int</span> newScore = mi.getScore();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + name + <span class="string">"\n加分后的成绩："</span> + newScore);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorld mo = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        mo.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>概念<ul><li>继承是类与类的一种关系（Java是单继承）</li><li>子类拥有父类的所有属性和方法（private除外）</li><li>继承的初始化顺序：先父类初始化（先属性，再构造方法）、再子类</li></ul></li><li>extends关键字<ul><li>class 子类 extends 父类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>方法重写<ul><li>要求：名称、参数、返回值都相同</li></ul></li><li>final关键字<ul><li>final修饰：类、方法、属性</li><li>final+类：不能被继承</li></ul></li><li>super关键字<ul><li>在对象内部使用，代表父类对象（super.age，super.eat()）</li><li>子类的构造过程中会调用父类的构造方法（显式调用：<code>super();</code>）</li></ul></li><li>Object类<ul><li>Object类是所有类的父类（两个重要方法：toString()和equals()）</li><li>toString()：方法重写，实现输出对象的属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dog [age="</span>+age+<span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dog); <span class="comment">// Dog [age=10]</span></span><br></pre></td></tr></table></figure></li><li>equals()：比较对象的引用是否指向同一块内存地址<ul><li>hashCode()：返回对象的哈希码（对象地址字符串）</li><li>方法重写：比较两个对象值是否相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(getClass() != obj.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Dog other = (Dog) obj;</span><br><span class="line">    <span class="keyword">if</span>(age != other.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dog1.equals(dog2)) <span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li><li>类对象（类型：属性、方法） vs. 类的对象（值）</li></ul></li></ul></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>概念<ul><li>对象的多种形态（继承是多态的基础）</li><li>两种类型<ul><li>引用多态：父类的引用可以指向本类/子类的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal obj1 = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal obj2 = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">// Dog obj3 = new Animal(); // 错误</span></span><br></pre></td></tr></table></figure></li><li>方法多态：创建本类对象时，调用本类方法；创建子类对象时，调用子类的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.eat(); <span class="comment">// 两个都是父类引用创建的对象，但是方法不同</span></span><br><span class="line">obj2.eat();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>引用类型转换<ul><li>隐式/自动类型转换：小类型到大类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal obj = dog;</span><br></pre></td></tr></table></figure></li><li>强制类型转换：大类型到小类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog) obj;</span><br></pre></td></tr></table></figure></li><li>instanceof 避免类型转换的安全性问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">    Cat cat = (Cat) obj; <span class="comment">// obj此时指向Dog    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Java中的抽象类<ul><li>语法定义：<code>abstract</code>关键字修饰</li><li>作用（应用场景）：限制规定子类必须实现某些方法，但不关注实现细节</li><li>使用规则：<ul><li>abstract定义抽象类；</li><li>定义抽象方法只有声明；</li><li>包含抽象方法的类是抽象类；</li><li>抽象类中可以有普通方法，也可以没有抽象方法；</li><li>抽象类不能直接创建，但可以定义引用变量</li></ul></li><li>实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstract</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Telphone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellPhone</span> <span class="keyword">extends</span> <span class="title">Telphone</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Call by cellphone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Telphone</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Call by smart phone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Telphone cp = <span class="keyword">new</span> CellPhone();</span><br><span class="line">    Telphone sp = <span class="keyword">new</span> SmartPhone();</span><br><span class="line">    cp.call();</span><br><span class="line">    sp.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>接口<ul><li>接口可以理解为一种特殊的类，由全局常量和公共的抽象方法组成（接口定义了类的规范，是多继承的）</li><li>定义：<code>interface</code>关键字，不是class（一般使用public修饰，以及abstract，接口名一般以I开头）<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract interface 接口名 [extends 父类1, 父类2...]</span><br></pre></td></tr></table></figure></li><li>使用接口：<code>implements</code>关键字<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1,接口2...</span></span><br></pre></td></tr></table></figure></li><li>匿名内部类（没有名字的内部类）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPlayGame ip3 = <span class="keyword">new</span> IPlayGame()&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Play games"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> ip3.playGame();</span><br></pre></td></tr></table></figure></li><li>实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPlayGame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Telphone</span> <span class="keyword">implements</span> <span class="title">IPlayGame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Play games"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PSP</span> <span class="keyword">implements</span> <span class="title">IPlayGame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Play games"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    IPlayGame ip1 = <span class="keyword">new</span> SmartPhone();</span><br><span class="line">    IPlayGame ip2 = <span class="keyword">new</span> PSP();</span><br><span class="line">    ip1.playGame();</span><br><span class="line">    ip2.playGame();</span><br><span class="line">    IPlayGame ip3 = <span class="keyword">new</span> IPlayGame()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Play games"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ip3.playGame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>接口和抽象类有什么区别？<a href="https://snailclimb.top/JavaGuide/" target="_blank" rel="noopener">JavaGuide</a><ol><li>接口的方法默认是public，所有方法在接口中不能有实现，而抽象类可以有非抽象方法</li><li>接口中除了public static final修饰的变量，不能有其他变量，而抽象类可以</li><li>一个类可以实现多个接口，但只能实现一个抽象类</li><li>接口默认是public修饰，抽象方法只是不能被private修饰</li><li>从设计层面说，抽象是类的抽象（是一种模板设计），接口是对行为的抽象（是一种行为的规范）</li></ol></li><li>UML<ul><li>统一建模语言（Unified Modeling Language）</li><li>常用UML图<ul><li>用例图（The Use Case Diagram）</li><li>类图（The Class Diagram）</li></ul></li><li>建模工具：Viso、PowerDesigner</li></ul></li><li>Demo<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">British</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"English"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    People zh = <span class="keyword">new</span> Chinese();</span><br><span class="line">    People en = <span class="keyword">new</span> British();</span><br><span class="line">    zh.say();</span><br><span class="line">    en.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门第一季-imooc</title>
      <link href="2019/05/30/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%AD%A3-imooc/"/>
      <url>2019/05/30/Java/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%AD%A3-imooc/</url>
      
        <content type="html"><![CDATA[<h3 id="Java初体验"><a href="#Java初体验" class="headerlink" title="Java初体验"></a>Java初体验</h3><a id="more"></a><ul><li>简介<ul><li>诞生：1995（Sun）</li><li>收购：2009（Oracle）</li><li>Java 8：2014</li></ul></li><li>版本（J2EE，2005年Java6前）<ul><li>Java SE（面向对象、API、JVM）</li><li>Java EE（JSP、EJB、服务）</li><li>Java ME（移动设备、游戏通信）</li></ul></li><li>核心概念<ul><li>JVM：Java Virtual Machine（源文件<code>.java</code> 编译-&gt; 字节码文件<code>.class</code> 解释-&gt; 程序）</li><li>JRE：Java Runtime Environment 运行时环境</li><li>JDK：Java Development Kit 开发工具包</li></ul></li><li>安装<ul><li>第一步：装JDK（也就有了JRE和JVM，JDK&gt;JRE&gt;JVM）</li><li>第二步：配置环境变量<ul><li>JAVA_HOME：JDK路径 <code>jdk根目录</code></li><li>PATH：JDK命令文件位置 <code>...\bin</code></li><li>CLASSPATH：类库文件位置 <code>.; ...\lib</code>（.表示当前路径）</li></ul></li><li>第三步：验证（CMD:<code>java -version</code>）</li></ul></li><li>Hello world（记事本写 <code>javac HelloWorld.java</code> -&gt; <code>java HelloWorld</code>）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">// Small(main), Capital(String)</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>); <span class="comment">// "" not ''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用IntellJ IDEA开发Java程序<ol><li>创建Java项目</li><li>创建程序包（Package、Class）</li><li>编写Java源程序</li><li>运行Java程序</li></ol></li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ul><li>变量和常量<ul><li>标识符：可<code>$</code>开头，不能以数字开头</li><li>数据类型：<ul><li>基本数据类型（数值型、字符型、布尔型）</li><li>引用数据类型（类、接口、数组）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">0.5f</span>; <span class="comment">// 要加f</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'男'</span>; <span class="comment">// 单引号</span></span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>; <span class="comment">// 关键字boolean，true开头小写</span></span><br><span class="line"><span class="comment">//String是引用类型</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>运算符<ul><li>异或：<code>^</code>，与或非：<code>&amp;&amp; || !</code></li><li>条件运算符：<code>? :</code></li><li>整数除法（向下取整）：<code>40/9=4, 60/9=6</code></li><li>字符串比较：<code>a==&quot;abc&quot;</code>/<code>a.equals(&quot;abc&quot;)</code></li><li>多个条件：<code>switch(today){case &#39;一&#39;: ... default: ....}</code></li></ul></li><li>流程控制语句<ul><li>计算整数的位数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num !=<span class="number">0</span> );        </span><br><span class="line">        System.out.println(<span class="string">"它是个"</span>+count+<span class="string">"位的数！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>数组<ul><li>整数数组：<code>int[] scores = {1,2,3,4,5};</code></li><li>声明数组并分配空间：<code>String[] abc = new String[5];</code></li><li>Arrays类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">Arrays.toString(nums);</span><br></pre></td></tr></table></figure></li><li>foreach操作数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> score : scores)&#123;</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二维数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] nums = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums[i].length; j++)&#123;</span><br><span class="line">        System.out.println(nums[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>方法<ul><li>定义：<code>public void print()</code></li><li>调用：<code>HelloWorld hello = new HelloWorld(); hello.print();</code></li><li>重载：<code>public void print(String name)</code></li><li>随机数（Math类）：<code>(int)(Math.random()*100)</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
