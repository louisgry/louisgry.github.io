<!DOCTYPE html>





<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="运行时数据区域、垃圾收集、内存分配与回收策略、类加载机制、其他知识">
<meta name="keywords" content="Ebbinghaus,Java虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机">
<meta property="og:url" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;2020&#x2F;02&#x2F;02&#x2F;Java&#x2F;%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA&#x2F;index.html">
<meta property="og:site_name" content="Louis&#39; Blog">
<meta property="og:description" content="运行时数据区域、垃圾收集、内存分配与回收策略、类加载机制、其他知识">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;3.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;5.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;6.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;7.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;9.png">
<meta property="og:updated_time" content="2020-04-08T07:54:34.912Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;louisgry.github.io&#x2F;images&#x2F;java&#x2F;jvm&#x2F;1.png">
  <link rel="canonical" href="https://louisgry.github.io/2020/02/02/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>深入理解Java虚拟机 | Louis' Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Louis' Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
    
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://louisgry.github.io/2020/02/02/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis' Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            深入理解Java虚拟机
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-02-02 16:24:04" itemprop="dateCreated datePublished" datetime="2020-02-02T16:24:04+08:00">2020-02-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-08 15:54:34" itemprop="dateModified" datetime="2020-04-08T15:54:34+08:00">2020-04-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-description">运行时数据区域、垃圾收集、内存分配与回收策略、类加载机制、其他知识</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>《深入理解Java虚拟机》</p>
</blockquote>
<h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><ul>
<li>Java虚拟机由四部分组成：ClassLoader(类加载器)、Execution Engine(执行引擎)、Native Interface(本地接口)、Runtime Data Area(运行时数据区域)</li>
<li>运行时数据区域：JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域<br>  <img src="/images/java/jvm/1.png" alt=""></li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul>
<li>程序计数器（Program Counter Register）是一块较小的内存空间，记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><ul>
<li>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息</li>
<li>从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程</li>
<li>可以通过<code>-Xss</code>参数来指定每个线程的Java虚拟机栈内存大小，JDK1.4默认256K，JDK1.5+默认1M<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss2M HackTheJava</span><br></pre></td></tr></table></figure></li>
<li>该区域可能抛出以下异常<ul>
<li>当线程请求的栈深度超过最大值，会抛出StackOverflowError异常</li>
<li>栈进行动态扩展时，如果无法申请到足够内存，会抛出OutOfMemoryError异常<br><img src="/images/java/jvm/2.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>本地方法栈：与虚拟机栈类似，区别是本地方法栈为本地方法服务</li>
<li>本地方法一般是使用其他语言编写的，并且被编译为基于本机硬件和操作系统的程序，对这些方法需特别处理<ul>
<li>JNI：Java本地接口（Java Native Interface）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地库，也可以被其他程序调用<br><img src="/images/java/jvm/3.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><ul>
<li>Java堆：所有的对象都在堆中分配内存，是垃圾收集的主要区域（GC堆）</li>
<li>主要采用分代收集算法，其主要思想是针对不同类型的对象采取不同的垃圾回收算法<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
</li>
<li>堆不需要连续内存，并且可以动态增加内存，增加失败会抛出OutOfMemoryError异常</li>
<li>可以通过<code>-Xms</code>和<code>-Xmx</code>参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个设置最大值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1M -Xmx2M HackTheJava</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器（JIT编译器）编译后的代码等数据</li>
<li>和堆一样不需要连续的内存，并且可以动态扩展，扩展失败也会抛出OutOfMemoryError异常</li>
<li>对方法区的垃圾回收主要目标是：常量池的回收、对类的卸载，但是比较难实现</li>
<li>永久代<ul>
<li>HotSpot虚拟机把方法区当作永久代进行垃圾回收，但很难确定永久代的大小，因为有很多因素的影响，并且每次Full GC后永久代的大小都会改变，所以经常抛出OOM异常</li>
<li>为了更容易管理方法区，从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中</li>
</ul>
</li>
<li>方法区是一个JVM规范，永久代与元空间都是方法区的实现方式。JDK1.8后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，堆存储静态变量和常量池</li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul>
<li>运行时常量池：是方法区的一部分。Class文件中的常量池会在类加载后被放入运行时常量池</li>
<li>除了在编译期生成的常量，也允许动态生成，如String类的intern()方法</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ul>
<li>JDK1.4中引入了NIO（New Input/Output）类，它可以使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作</li>
<li>好处：能在某些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据</li>
</ul>
<h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><ul>
<li>垃圾收集针对Java堆和方法区进行。程序计数器、虚拟机栈、本地方法栈属于线程私有的，只存在于线程的生命周期内，线程结束后就会消失，不需要进行垃圾回收</li>
</ul>
<h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><ul>
<li>为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1，回收引用计数为0的对象</li>
<li>缺点：循环引用（引用计数器永远不为0）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环引用，无法回收</span></span><br><span class="line">        ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        </span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul>
<li>以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收</li>
<li>Java虚拟机使用该算法来判断对象是否可被回收</li>
<li>可作为GC Roots的对象<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈JNI中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象<br><img src="/images/java/jvm/4.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><ul>
<li>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类（常量池的回收和对类的卸载）</li>
<li>废弃常量：与回收堆中的对象类似。如字符串”abc”进入常量池，却没有String对象引用，则被回收</li>
<li>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能</li>
<li>无用的类：需同时满足以下3个条件<ul>
<li>该类所有的实例都已经被回收，此时Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类的方法</li>
</ul>
</li>
</ul>
<h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><ul>
<li>类似C++的析构函数，用于关闭外部资源</li>
<li>当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救</li>
<li>自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>判断对象是否可被回收都与引用有关</li>
</ul>
<h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><ul>
<li>强引用：被强引用关联的对象不会被回收，可以通过将对象设置为null来弱化引用，使其被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><ul>
<li>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; a = <span class="keyword">new</span> SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><ul>
<li>弱引用：被弱引用关联的对象一定会被回收，即只能存活到下一次垃圾回收发生之前<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; b = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><ul>
<li>虚引用：一个对象是否有虚引用，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li>
<li>目的：能在这个对象被回收前收到一个系统通知<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">PhantomReference ref = <span class="keyword">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><ul>
<li>标记-清除（Mark-Sweep），分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象，标记过程使用标记方法判定</li>
<li>回收对象就是把对象分块，连接到被称为“空间链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块</li>
<li>缺点<ul>
<li>效率问题：标记和清除过程效率不高</li>
<li>空间问题：会产生大量不连续的内存碎片，导致无法给大对象分配内存</li>
</ul>
</li>
</ul>
<h3 id="2-标记-整理算法"><a href="#2-标记-整理算法" class="headerlink" title="2. 标记-整理算法"></a>2. 标记-整理算法</h3><ul>
<li>标记-整理（Mark-Compact），让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存</li>
<li>优点：不会产生内存碎片</li>
<li>缺点：需要移动大量对象，处理效率比较低</li>
</ul>
<h3 id="3-复制算法"><a href="#3-复制算法" class="headerlink" title="3. 复制算法"></a>3. 复制算法</h3><ul>
<li>复制（Copying），将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后把使用过的内存空间进行清理</li>
<li>现代虚拟机用复制算法回收新生代，但不是划分为相等的两块，而是Eden:Survivor默认为8:1，每次只使用Eden和其中一块Survivor（From、To是变化的），回收时将Eden和From中还存活的对象复制到To区，然后清理Eden和From区</li>
<li>缺点：只使用了内存的一半，需要额外的空间进行分配担保。且对象存活率高的场景就要进行较多的复制，效率会变低，所以不适用于老年代<br>  <img src="/images/java/jvm/5.png" alt=""></li>
</ul>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><ul>
<li>分代收集（Generational Collection），现代虚拟机所采用，它根据对象存活周期的不同将内存划分为块，不同块采用不同的收集算法</li>
<li>新生代：使用复制算法</li>
<li>老年代：使用标记-清除算法，或标记-整理算法</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul>
<li>HotSpot虚拟机中的7个垃圾收集器，连线表示可以配合使用<ul>
<li>单线程与多线程：ParNew、Parallel Scavenge、Parallel Old是多线程的</li>
<li>串行与并行：垃圾收集器与用户程序是交替执行或同时执行，只有CMS和G1是并行的<br><img src="/images/java/jvm/6.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="1-Serial"><a href="#1-Serial" class="headerlink" title="1. Serial"></a>1. Serial</h3><ul>
<li>Serial的意思是串行，即以串行的方式执行，Serial是单线程的收集器，只会使用一个线程进行垃圾收集</li>
<li>Client下默认的新生代收集器，因为该场景下内存一般不会很大</li>
<li>优点：简单高效，在单CPU下，由于没有线程交互的开销，因此有最高的单线程收集效率</li>
</ul>
<h3 id="2-ParNew"><a href="#2-ParNew" class="headerlink" title="2. ParNew"></a>2. ParNew</h3><ul>
<li>ParNew是Serial收集器的多线程版本</li>
<li>Server下默认的新生代收集器，除了性能外，主要是因为除了Serial，只有ParNew能与CMS收集器配合使用</li>
</ul>
<h3 id="3-Parallel-Scavenge"><a href="#3-Parallel-Scavenge" class="headerlink" title="3. Parallel Scavenge"></a>3. Parallel Scavenge</h3><ul>
<li>Parallel Scavenge也是多线程收集器，其收集目标是吞吐量优先（适用于后台运行程序），不同于其他的目标是尽可能缩短垃圾收集时用户线程的停顿时间。缩短停顿时间是以牺牲吞吐量和新生代空间换取的：新生代空间变小，垃圾回收变频繁，导致吞吐量下降</li>
<li>系统吞吐量=运行用户程序时间/(运行用户程序时间+GC时间)</li>
<li>可以通过开关参数<code>-XX:+UseAdaptiveSizePolicy</code>打开GC自适应的调节策略（GC Ergonomics），就不用手动设置新生代大小、Eden和Survivor比例、晋升老年代对象年龄等参数</li>
</ul>
<h3 id="4-Serial-Old"><a href="#4-Serial-Old" class="headerlink" title="4. Serial Old"></a>4. Serial Old</h3><ul>
<li>Serial Old是Serial收集器的老年代版本，Client下的老年代收集器</li>
<li>如果用在Server场景下，有两大用途<ul>
<li>在JDK1.5及以前，与Parallel Scavenge配合使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
</li>
</ul>
<h3 id="5-Parallel-Old"><a href="#5-Parallel-Old" class="headerlink" title="5. Parallel Old"></a>5. Parallel Old</h3><ul>
<li>Parallel Old是Parallel Scavenge的老年代版本</li>
<li>在注重吞吐量和CPU资源敏感的场景，可以优先考虑Parallel Scavenge和Parallel Old收集器</li>
</ul>
<h3 id="6-CMS"><a href="#6-CMS" class="headerlink" title="6. CMS"></a>6. CMS</h3><ul>
<li>CMS（Concurrent Mark Sweep），基于标记-清除算法，是一种以获取最短回收停顿时间为目标，适用于服务端应用（重视服务的响应速度，希望系统停顿时间最短，有更好的用户体验）。使用CMS来收集老年代时，新生代的收集只能选Serial或ParNew<ul>
<li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿（Stop The World）</li>
<li>并发标记：进行GC Roots Tracing的过程，在整个回收过程中耗时最长，不需要停顿</li>
<li>重新标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需用停顿（Stop The World）</li>
<li>并发清除：不需要停顿</li>
</ul>
</li>
<li>优点：并发收集、低停顿</li>
<li>缺点<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高</li>
<li>无法处理浮动垃圾，可能会出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC才被回收。由于浮动垃圾的存在，因此需要预留出一部分内存，此时CMS不能像其他收集器那样等待老年代快满了才回收。如果预留的内存不够存放，就会出下Concurrent Mode Failure，这时会触发Full GC，使用Serial old临时替换CMS，停顿时间变长</li>
<li>空间问题：标记-清除算法导致的空间碎片，会出现老年代空间剩余，但无法找到足够大的连续空间来分配当前对象，要提前触发一次Full GC</li>
</ul>
</li>
</ul>
<h3 id="7-G1"><a href="#7-G1" class="headerlink" title="7. G1"></a>7. G1</h3><ul>
<li>G1（Garbage First），是一款面向服务端应用的垃圾收集器，在多CPU和大内存场景下有很好的性能</li>
<li>G1可以直接对新生代和老年代一起回收，它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离</li>
<li>每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region，通过使用该Set在可达性分析时可以避免全堆扫描<ul>
<li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象</li>
<li>并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活的对象，耗时长，但可并行</li>
<li>最终标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，虚拟机将对象变化记录在Remembered Set Logs里面，并合并数据到Set中，需要停顿，但可并行</li>
<li>筛选回收：首先对Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可并行</li>
</ul>
</li>
<li>特点<ul>
<li>空间整合：整体是标记-整理算法，局部（两Region之间）是复制算法，不会有内存碎片</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间内，消耗在GC上的时间不超过N毫秒<br><img src="/images/java/jvm/7.png" alt=""></li>
</ul>
</li>
</ul>
<h1 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h1><h2 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h2><ul>
<li>Minor GC：回收新生代，新生代对象存活时间短，Minor GC执行频繁，速度也较快。Eden空间满时触发一次Minor GC</li>
<li>Full GC：回收新生代和老年代，老年代对象存活时间长，Full GC执行较少，速度较慢</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul>
<li>大多数情况下，对象在新生代Eden区分配，当其空间不足时，发起Minor GC</li>
</ul>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><ul>
<li>大对象：指需要连续内存空间的对象，如很长的字符串或数组</li>
<li>经常出现大对象容易导致内存还有不少空间，就提前触发垃圾收集以获取足够的连续空间来分配给大对象</li>
<li><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在Eden和Survivor间大量内存复制</li>
</ul>
<h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul>
<li>为对象定义年龄计数器，对象在Eden出生并经过Minor GC依然存活，将移动至Survivor中，年龄增加1岁，增加到一定年龄则移动到老年代中</li>
<li><code>-XX:MaxTenuringThreshold</code>定义年龄的阈值</li>
</ul>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul>
<li>除了达到年龄阈值外，如果在Survivor中相同年龄的所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代</li>
</ul>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul>
<li>使用复制算法的Minor GC需要老年代的内存空间作担保</li>
<li>在Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，成立则Minor GC是安全的。如果不成立，虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行Minor GC，否则进行Full GC</li>
</ul>
<h2 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h2><h3 id="1-调用System-gc"><a href="#1-调用System-gc" class="headerlink" title="1. 调用System.gc()"></a>1. 调用System.gc()</h3><ul>
<li>只是建议虚拟机执行Full GC，但不一定真正执行</li>
</ul>
<h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><ul>
<li>老年代不足：大对象、长期存活的对象进入老年代</li>
<li>可以通过<code>-Xmn</code>参数调大新生代的大小，让对象尽量在新生代被回收。还可以通过<code>-XX:MaxTenuringThreshold</code>调大晋升老年代的年龄，让对象在新生代存活久一点</li>
</ul>
<h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><ul>
<li>使用复制算法的Minor GC需要老年代的内存空间作担保，如果失败会进行Full GC</li>
</ul>
<h3 id="4-JDK1-7及以前的永久代空间不足"><a href="#4-JDK1-7及以前的永久代空间不足" class="headerlink" title="4. JDK1.7及以前的永久代空间不足"></a>4. JDK1.7及以前的永久代空间不足</h3><ul>
<li>当系统中要加载的类、反射的类和调用的方法较多时，永久代空间可能会不足，在未采用CMS时会执行Full GC，如果回收不了则抛出OOM异常</li>
</ul>
<h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><ul>
<li>执行CMS GC的同时有对象要放入老年代，而此时老年代空间不足（如浮动垃圾导致），会报Concurrent Mode Failure错误，并触发Full GC</li>
</ul>
<h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><ul>
<li>类是在运行期间第一次使用时动态加载的，而不是一次性全部加载，因为它会占用很多的内存</li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul>
<li>类的生命周期有7个阶段<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）<br><img src="/images/java/jvm/8.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><ul>
<li>类加载的5阶段：加载、验证、准备、解析、初始化</li>
</ul>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><ul>
<li>加载是类加载（Class Loading）过程的一个阶段，注意不要混淆</li>
<li>加载过程完成以下三件事<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构</li>
<li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li>
</ul>
</li>
<li>其中二进制字节流可以从以下方式中获取<ul>
<li>从ZIP包读取，成为JAR、EAR、WAR格式的基础</li>
<li>从网络中获取，最经典的应用是Applet</li>
<li>运行时计算生成，例如动态代理技术，java.lang.reflect.Proxy使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li>
<li>由其他文件生成，例如由JSP文件生成对应的Class类</li>
</ul>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><ul>
<li>验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>
</ul>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><ul>
<li>准备阶段为类变量分配内存并设置初始值，使用方法区的内存（类变量是被static修饰的变量）</li>
<li>不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中</li>
<li>类变量初始值一般为0，如以下变量初始化为0而不是123<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><ul>
<li>解析：将常量池的符号引用替换为直接引用的过程。为了支持Java的动态绑定，解析可在初始化阶段之后在开始<ul>
<li>符号引用：以一组符号来描述所引用的目标，如CONSTANT_Class_info</li>
<li>直接引用：可以是直接指向目标的指针、相对偏移量、一个能间接定位到目标的句柄</li>
</ul>
</li>
</ul>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><ul>
<li>初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段是虚拟机执行类构造器<code>&lt;client&gt;()</code>方法的过程。在准备阶段，类变量根据系统要求赋初值，而在初始化阶段，根据程序制定的主观计划去初始化类变量和其他资源</li>
<li><code>&lt;client&gt;()</code>是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并的，编译器收集的顺序由语句在源文件中出现的顺序决定<ul>
<li>父类的<code>&lt;client&gt;()</code>方法先执行，故父类中定义的静态语句块先于子类。</li>
<li>接口中不可以使用静态语句块，但有类变量初始化的赋值操作，因此接口也会生成<code>&lt;client&gt;()</code>方法。但接口不需要先执行父接口的<code>&lt;client&gt;()</code>方法，只有当父接口中定义的变量被使用时才会初始化。同样，接口的实现类在初始化时也不会执行接口的<code>&lt;client&gt;()</code>方法</li>
<li>虚拟机会保证一个类的<code>&lt;client&gt;()</code>方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行该类的<code>&lt;client&gt;()</code></li>
<li>特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Initial</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                  <span class="comment">// 编译正常通过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// Error：非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><ul>
<li>虚拟机没有强制约束何时加载，但以下五种情况必须对类进行初始化（加载、验证、准备在此之前开始）<ul>
<li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化（场景：使用new关键字实例化对象时、读取或设置一个类的静态字段时、调用一个类的静态方法时）</li>
<li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ul>
</li>
</ul>
<h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><ul>
<li>除以上五种主动引用外，所有引用类的方式都不会触发初始化，称为被动引用。常见例子有<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化</li>
<li>通过数组定义来引用类，不会触发该类的初始化。该过程会对数组类进行初始化（数组类是由虚拟机自动生成、直接继承自Object的子类，包含数组的属性和方法）</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会触发定义常量类的初始化</li>
</ul>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li>类加载器不仅限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</li>
<li>也就是说，两个类相等，需要类本身相等，还要使用同一个类加载器进行加载，因为每一个类加载器都拥有一个独立的类名称空间。这里的相等，包括类的Class对象的equals()、isAssignableFrom()、isInstance()方法的返回结果为true，也包括使用instanceof关键字做对象所属关系判定为true</li>
</ul>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ul>
<li>从Java虚拟机的角度，只有两种类加载器<ul>
<li>启动类加载器（Bootstrap ClassLoader）：使用C++实现，是虚拟机自身的一部分</li>
<li>所有其他类的加载器：使用Java实现，独立于虚拟机，继承自抽象类java.lang.ClassLoader</li>
</ul>
</li>
<li>从Java开发人员的角度，有以下三种加载器<ul>
<li>启动类加载器（Bootstrap ClassLoader）：负责将存放在<code>&lt;JRE_HOME&gt;\lib</code>目录中的，或被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可</li>
<li>扩展类加载器（Extension ClassLoader）：由ExtClassLoader实现，它负责将<code>&lt;JAVA_HOME&gt;\lib\ext</code>或者被java.ext.dir系统变量所指定路径中的类库加载到内存中，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器（Application ClassLoader）：由AppClassLoader实现，由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径CLASSPATH上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下默认就是Application ClassLoader</li>
</ul>
</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>双亲委派模型（Parents Delegation Model）：要求除了顶层的启动类加载器外，其他的类加载器都要有自己的父类加载器。父子关系一般通过组合关系实现，而不是继承<br>  <img src="/images/java/jvm/9.png" alt=""></li>
</ul>
<h3 id="1-工作过程"><a href="#1-工作过程" class="headerlink" title="1. 工作过程"></a>1. 工作过程</h3><ul>
<li>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</li>
</ul>
<h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h3><ul>
<li>使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</li>
<li>例如，java.lang.Object放在rt.jar中，如果另写一个Object放到CLASSPATH中，程序编译通过。因为双亲委派模型，在rt.jar中的Object优先级更高，其使用的是启动类加载器，而CLASSPATH中的Object使用应用程序类加载器</li>
</ul>
<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><ul>
<li><code>loadClass()</code>方法运行过程：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出ClassNotFoundException，此时尝试自己加载<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自定义类加载器实现"><a href="#自定义类加载器实现" class="headerlink" title="自定义类加载器实现"></a>自定义类加载器实现</h3><ul>
<li>应用程序是由三种类加载器相互配合从而实现类加载，此外还可以自定义类加载器</li>
<li>例如，自定义类加载器FileSystemClassLoader，继承自ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class文件），然后读取该文件内容，最后通过defineClass()方法把字节码转换成Class类的实例。自定义类加载器不需要重写loadClass()方法，但需要重写findClass()方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">        + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五、Java虚拟机的其他知识"><a href="#五、Java虚拟机的其他知识" class="headerlink" title="五、Java虚拟机的其他知识"></a>五、Java虚拟机的其他知识</h1><h2 id="JVM组成结构"><a href="#JVM组成结构" class="headerlink" title="JVM组成结构"></a>JVM组成结构</h2><ul>
<li>JVM基本结构，有别于JVM内存结构（也有别于JVM内存模型）<ul>
<li>ClassLoader(类加载器)：根据特定格式，加载class文件到内存</li>
<li>Execution Engine(执行引擎)：对命令进行解析</li>
<li>Native Interface(本地接口)：融合不同语言的原生库为Java所用</li>
<li>Runtime Data Area(运行时数据区域)：JVM内存结构</li>
</ul>
</li>
</ul>
<h2 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h2><h3 id="1-JDK的命令行工具"><a href="#1-JDK的命令行工具" class="headerlink" title="1. JDK的命令行工具"></a>1. JDK的命令行工具</h3><ul>
<li><code>jps</code>: 虚拟机进程状态工具，显示指定系统内所有的HotSpot虚拟机进程</li>
<li><code>jstat</code>: 虚拟机统计信息监视工具，用于收集HotSpot虚拟机各方面的允许数据</li>
<li><code>jinfo</code>: Java配置信息工具，显示虚拟机配置信息</li>
<li><code>jmap</code>: Java内存映像工具，生成虚拟机的内存转储快照（heapdump文件）</li>
<li><code>jhat</code>: 虚拟机堆转储快照分析工具，用于分析heapdump文件</li>
<li><code>jstack</code>: Java堆栈跟踪工具，显示虚拟机的线程快照</li>
</ul>
<h3 id="2-JDK的可视化工具"><a href="#2-JDK的可视化工具" class="headerlink" title="2. JDK的可视化工具"></a>2. JDK的可视化工具</h3><ul>
<li>JConsole: Java监视与管理控制台</li>
<li>Visual VM: 多合一故障处理工具</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Ebbinghaus/" rel="tag"># Ebbinghaus</a>
            
              <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"># Java虚拟机</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/01/11/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer-%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/" rel="next" title="剑指Offer-分类汇总">
                  <i class="fa fa-chevron-left"></i> 剑指Offer-分类汇总
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/03/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="prev" title="大型网站架构演变过程-系统设计">
                  大型网站架构演变过程-系统设计 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、运行时数据区域"><span class="nav-number">1.</span> <span class="nav-text">一、运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java堆"><span class="nav-number">1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存"><span class="nav-number">1.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、垃圾收集"><span class="nav-number">2.</span> <span class="nav-text">二、垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断一个对象是否可被回收"><span class="nav-number">2.1.</span> <span class="nav-text">判断一个对象是否可被回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-引用计数算法"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-可达性分析算法"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. 可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方法区的回收"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. 方法区的回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-finalize"><span class="nav-number">2.1.4.</span> <span class="nav-text">4. finalize()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用类型"><span class="nav-number">2.2.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-强引用"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-软引用"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 软引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-弱引用"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-虚引用"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 虚引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-标记-清除算法"><span class="nav-number">2.3.1.</span> <span class="nav-text">1. 标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-标记-整理算法"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-复制算法"><span class="nav-number">2.3.3.</span> <span class="nav-text">3. 复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-分代收集算法"><span class="nav-number">2.3.4.</span> <span class="nav-text">4. 分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Serial"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. Serial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ParNew"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. ParNew</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Parallel-Scavenge"><span class="nav-number">2.4.3.</span> <span class="nav-text">3. Parallel Scavenge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Serial-Old"><span class="nav-number">2.4.4.</span> <span class="nav-text">4. Serial Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Parallel-Old"><span class="nav-number">2.4.5.</span> <span class="nav-text">5. Parallel Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-CMS"><span class="nav-number">2.4.6.</span> <span class="nav-text">6. CMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-G1"><span class="nav-number">2.4.7.</span> <span class="nav-text">7. G1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、内存分配与回收策略"><span class="nav-number">3.</span> <span class="nav-text">三、内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Minor-GC-和-Full-GC"><span class="nav-number">3.1.</span> <span class="nav-text">Minor GC 和 Full GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配策略"><span class="nav-number">3.2.</span> <span class="nav-text">内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-对象优先在Eden分配"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 对象优先在Eden分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-大对象直接进入老年代"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-长期存活的对象将进入老年代"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-动态对象年龄判定"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 动态对象年龄判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-空间分配担保"><span class="nav-number">3.2.5.</span> <span class="nav-text">5. 空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Full-GC的触发条件"><span class="nav-number">3.3.</span> <span class="nav-text">Full GC的触发条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-调用System-gc"><span class="nav-number">3.3.1.</span> <span class="nav-text">1. 调用System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-老年代空间不足"><span class="nav-number">3.3.2.</span> <span class="nav-text">2. 老年代空间不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-空间分配担保失败"><span class="nav-number">3.3.3.</span> <span class="nav-text">3. 空间分配担保失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-JDK1-7及以前的永久代空间不足"><span class="nav-number">3.3.4.</span> <span class="nav-text">4. JDK1.7及以前的永久代空间不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Concurrent-Mode-Failure"><span class="nav-number">3.3.5.</span> <span class="nav-text">5. Concurrent Mode Failure</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、类加载机制"><span class="nav-number">4.</span> <span class="nav-text">四、类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类的生命周期"><span class="nav-number">4.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的过程"><span class="nav-number">4.2.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-加载"><span class="nav-number">4.2.1.</span> <span class="nav-text">1.加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-验证"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-准备"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-解析"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-初始化"><span class="nav-number">4.2.5.</span> <span class="nav-text">5.初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类初始化时机"><span class="nav-number">4.3.</span> <span class="nav-text">类初始化时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-主动引用"><span class="nav-number">4.3.1.</span> <span class="nav-text">1. 主动引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-被动引用"><span class="nav-number">4.3.2.</span> <span class="nav-text">2. 被动引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">4.4.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器分类"><span class="nav-number">4.4.1.</span> <span class="nav-text">类加载器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">4.4.2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-工作过程"><span class="nav-number">4.4.3.</span> <span class="nav-text">1. 工作过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-好处"><span class="nav-number">4.4.4.</span> <span class="nav-text">2. 好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-实现"><span class="nav-number">4.4.5.</span> <span class="nav-text">3. 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类加载器实现"><span class="nav-number">4.4.6.</span> <span class="nav-text">自定义类加载器实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、Java虚拟机的其他知识"><span class="nav-number">5.</span> <span class="nav-text">五、Java虚拟机的其他知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM组成结构"><span class="nav-number">5.1.</span> <span class="nav-text">JVM组成结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机性能监控与故障处理工具"><span class="nav-number">5.2.</span> <span class="nav-text">虚拟机性能监控与故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JDK的命令行工具"><span class="nav-number">5.2.1.</span> <span class="nav-text">1. JDK的命令行工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JDK的可视化工具"><span class="nav-number">5.2.2.</span> <span class="nav-text">2. JDK的可视化工具</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Louis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Louis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/muse.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  





















  

  

  

</body>
</html>
