---
title: 算法：300分钟搞定算法面试-力扣x拉勾
date: 2019-xx-xx 12:31:50
categories: 算法
tags: 
- 拉勾
description: 常用数构（数组和字符串、链、栈、队列、双端队列、树）<br>高级数构（优先队列、图、前缀树 、线段树、树状数组）<br>算法思想（）
---
<!-- more -->
# 第01讲：常用的数据结构
- 常用数据结构
    - 数组和字符串、链、栈、队列、双端队列、树
- 数组、字符串
    - 优缺点：根据index查询O(1)，但根据值查询O(n)
    - 转换为字符数组
        - 翻转字符串：[344. Reverse String](https://leetcode.com/problems/reverse-string/)
    - 双指针
        - 有效的字母异位词：[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- 链表
    - 优缺点：添加删除元素O(1)，但查询O(n)
    - 快慢指针（或三指针）
        - 链表的翻转：[24. ]()
        - K个一组翻转链表：[25. ]()
        - 寻找倒数第 k 个元素
        - 寻找链表中间位置的元素
        - 判断链表是否有环
    - 虚拟头节点（dummyHead）
        - 给定两个排好序的链表，要求将它们整合在一起并排好序
        - 将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数
- 栈
    - 实现：单链表，操作头节点
    - 只关心最近一次操作
        - 有效的括号：[20. ]()
        - 每日温度：[739. ]()
        - 求解算术表达式的结果（LeetCode 224、227、772、770)
        - 求解直方图里最大的矩形区域（LeetCode 84）
- 队列
    - 实现：双链表
    - 广度优先搜索（BFS）
- 双端队列
    - 优点：在两端添加删除都是O(1)
    - 滑动窗口（队头max，队尾min）
        - 滑动窗口的最大值：[239. ]()
- 树（非常重要）
    - 常考结构：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树、多叉树
    - 递归
        - 二叉树中第K小的元素：[230. ]()
    - 前序：[根，左，右]（树中搜索、新建树）
    - 中序：[左，根，右]（二叉搜索树）
    - 后序：[左，右，根]（修剪叶子节点）
        - 统计同值子树：[250. ]()

# 第02讲：高级数据结构
- 高级数据结构
    - 优秀的算法往往取决于你采用哪种数据结构
    - 优先队列、图、前缀树 (Trie)、线段树、树状数组
- 优先队列
    - 实现：二叉树（本质是数组；shift up、shift down）
        - 添加和删除操作都是O(logk)
        - 初始化一个大小为n的堆，复杂度是O(n)
    - 按顺序组织的数据结构，不需要预先排序
        - 前K个高频元素：[347. ]()
- 图
    - 必须掌握的知识点
        - 图的存储和表达方式：邻接矩阵、邻接表
        - 图的遍历：深度优先 (DFS)、广度优先 (BFS)
        - 二部图的检测 (Bipartite)、树的检测、环的检测（有向图 无向图）
        - 拓扑排序
        - 并查集 (Union-Find)
        - 最短路径：Dijkstra、Bellman-Ford
    - 判断二分图：[785. ]()
- 前缀树（Trie）
    - 前缀树被广泛运用于字典查找，也叫字典树
    - 应用：搜索提醒、输入法联想
    - 性质：
    - 基本操作：创建和搜索
        - 单词搜索II：[212. ]()
- 线段树（Segment Tree）
    - 能在O(logn)时间里更新数组元素及求和
        - 计算右侧小于当前元素的个数：[315. ]()
- 树状数组（Binary Index Tree）
    - 特性：利用数组表示多叉树的结构
    - 实现：第一个元素是空节点，y是x的节点 y=x-(x&(-x))
        - 二维区域和检索-可变：[308. ]()

# 第03讲：排序
- 学习算法的用处
    - 提高思维能力，培养分析和处理问题的能力
- 排序算法
    - 冒泡、插入、归并、快排、拓扑
- 冒泡排序
- 插入排序
    - 插入排序思想：两层for循环，if后面(arr[j])比前面(arr[j-1)小则swap，否则break
- 归并排序
- 快速排序
- 拓扑排序


# 第04讲：递归与回溯
- 递归
    - 递归：函数调用本身（把大规模的问题不断变小，再进行推导）
    - 例子：汉诺塔（把第n个盘放到C，把其他n-1个盘放到B）
    - 递归方程及复杂度分析（公式法）
        - $T(n)=aT(n/b)+f(n)$
        - 若$O(n^{log_ba}) > f(n)$：$O(n^{log_ba})$
        - 若$O(n^{log_ba}) < f(n)$：$f(n)$
        - 若$O(n^{log_ba}) = f(n)$：$O(n^{log_ba})*logn$
    - 算法步骤：完整性检查 -> 递归终止条件 -> 缩小问题规模 -> 根据小问题整合题解
        - 解码的方法：[91. ]()
        - 找到所有长度为 n 的中心对称数：[247. ]()
- 回溯
    - 回溯：利用递归的性质（从问题的起始点出发，不算搜索，如果没有则返回一步或多步再搜索，直至终点） 
    - 算法步骤：完整性检查 -> 递归终止条件 -> 遍历所有可能 -> 尝试下一步可能的解 -> 回溯到上一步
        - 组合总和：[39. ]()
        - n皇后II：[52. ]()

# 第05讲：深度与广度优先搜索
- DFS
    - DFS解决连通性问题，判断是否有一个路径能从起点连接到终点
    - 算法思想：从起点出发，选择一个可选方向不断向前，直至无法继续为止，然后选择另一个方向，直到终点
    - DFS的实现：递归实现、借助栈实现DFS，栈（后进先出）
        - 迷宫：[490. ]()
- BFS
    - BFS解决最短路问题
    - 双端BFS：同时从起点和终点开始BFS的搜索
        - 应用：社交网络中判断两个人需要经过多少个朋友的介绍才能认识
    - BFS的实现：借助队列实现BFS，队列（先进先出）
        -  迷宫：[490. ]()
        - advance：迷宫+打墙