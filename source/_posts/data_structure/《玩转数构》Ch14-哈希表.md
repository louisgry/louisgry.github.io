---
title: 《玩转数构》Ch14-哈希表
date: 2019-10-15 21:50:36
categories: 数据结构
tags: 
- 数构
- Hash
description: Hash：哈希函数、hashCode、链地址法、基于TreeMap实现、动态扩容
---

# Ch14-哈希表
<!-- more -->
https://github.com/liuyubobobo/Play-with-Data-Structures/tree/master/14-Hash-Table
- 14-1：哈希表基础
    - 哈希表：每个字符都和一个索引对应，用空间换时间
        - 哈希函数：将“键”转换为“索引”，如f(ch) = ch - 'a'
        - 哈希表的操作：O(1)，解决哈希冲突
        - 哈希冲突：不同键对应到了相同的索引
    - 387 First Unique Character in a String：https://leetcode.com/problems/first-unique-character-in-a-string/
        
- 14-2：哈希函数的设计
    - 要求
        - “键”通过哈希函数得到的“索引”分布越均匀越好
    - 整型
        - 身份证模1000000：前两位是日期不会超过31，分布不均匀
        - 一个简单的方法：模一个素数
        - https://planetmath.org/goodhashtableprimes
    - 浮点型、字符串、复合类型
        - 转成整型处理
    - 原则
        - 一致性
        - 高效性
        - 均匀性
- 14-3：Java中的 hashCode 方法
    - 整型：hashCode返回的值是本身
    - 浮点型、字符串
    - 自定义类型
    - `@Override`覆盖hashCode和equals方法（解决哈希冲突）
- 14-4：链地址法 Separate Chaining
    - 去符号的方法&（按位与）：`hashCode(k1) & 0x7fffffff`（后一个数第一位是0后面都是1，与之后抹掉了符号位）
    - 解决哈希冲突：相同哈希值的地方存成链表，也可以是TreeMap
    - Java8的处理（HashMap）
        - Java8之前：每一个位置对应一个链表
        - Java8之后：当哈希冲突达到一定程度时，每个位置从链表变成红黑树
- 14-5：实现属于我们自己的哈希表
    - 基于TreeMap实现
- 14-6：哈希表的动态空间处理与复杂度分析
    - resize操作
        - 扩容：平均每个地址承载的元素多于一定程度（N/M >= upperTol）
        - 缩容：少于一定程度
    - 哈希表的复杂度分析
        - 均摊分析：平均复杂度O(1)
- 14-7：哈希表更复杂的动态空间处理方法
    - 扩容 M -> 2*M（问题：2*M不是素数）
    - 使用goodhashtableprimes
    - 哈希表牺牲了顺序性（无序集合、无序映射：基于HashTable的实现）
    - 实现的哈希表有bug
        - HashTable的K不要求Comparable，但用TreeMap实现K要求Comparable，矛盾！
- 14-8：更多哈希冲突的处理方法
    - 红黑树添加新元素：左旋转、右旋转、颜色翻转
    - 使用红黑树做动态空间处理
    - 树的对比
        - 红黑树对数据规模大的效率更好
        - 对于完全随机的数据，普通的二分搜索树很好用
        - 对于查询较多的情况，AVL树很好用
        - 红黑树统计性能更优化
