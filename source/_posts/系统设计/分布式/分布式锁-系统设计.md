---
title: 分布式锁-系统设计
date: 2020-1-23 21:51:01
categories: 系统设计
tags: 
- 技术要点
description: what -> why -> how
---

## What
什么是分布式锁？

### 本地锁
- 最常见的本地锁有两种，用于多线程环境中控制对资源的并发访问
    - synchronized：基于JVM实现
    - ReentrantLock：基于JDK实现

### 分布式锁
- 分布式锁是控制分布式系统之间同步访问共享资源的一种方式，有如下特点
    - 互斥性：分布式锁需要保证在不同节点的不同线程的互斥
    - 可重入性：同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁
    - 锁超时：和本地锁一样支持锁超时，防止死锁
    - 高效、高可用：加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级
    - 支持阻塞和非阻塞：和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)
    - 支持公平锁和非公平锁：公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的

### 分布式锁实现方式
- 基于数据库实现
    - 加行级锁，其他事务就不能操作了。如`select * from order_table where id = 'xxx' for update`
    - 优点：理解容易，不需要第三方中间件
    - 缺点：实现较为繁琐，需要自己考虑锁超时，加事务等；性能局限于数据库，对高并发场景不适合
- 基于Zookeeper实现
    - ZooKeeper是以Paxos算法为基础分布式应用程序协调服务
    - zk的数据节点和文件目录类似，以某个资源为目录，该目录下面的节点就是需要获取锁的客户端，未获取到锁的客户端需要注册Watcher到上一个客户端
    - 优点：ZK可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用ZK集群进行保证。
    - 缺点：ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么
- 基于缓存实现（Redis）
    - setNx：set if not exist，2.6.12后SET组合了setnx和expire
    - Redission：Redission通过Netty支持非阻塞I/O，封装了锁的实现并继承了J.U.C的Lock的接口，可以像操作本地Lock一样去操作Redission的Lock
    - 优点：Redis实现简单，性能对比ZK和Mysql较好。如果不需要特别复杂的要求，那么可以利用setNx进行实现，如果需求复杂可以利用或者借鉴Redission。对于一些要求比较严格的场景来说的话可以使用RedLock
    - 缺点：需要维护Redis集群，如果要实现RedLock那么需要维护更多的集群

## Why
为什么需要分布式锁？
- 效率：使用分布式锁可以避免不同节点重复相同的工作，比如用户付钱后有不同节点发重复的短信
- 正确性：加分布式锁保证正确性，如果两个节点操作同一条数据，可能会发生错误

## How
如何应用分布式锁？

### Redission分布式锁
```java
RedissionClient redis = Redission.create();
RLock rLock = redis.getLock("resourcename");
// 加锁
rLock.lock();
// 尝试加锁5秒，锁过期10秒
rLock.tryLock(5, 10, TimeUnit.SECONDS);
// 支持非阻塞异步加锁
RFuture<Boolean> rFuture = rLock.tryLockAsync(5, 10, TimeUnit.SECONDS);
rFuture.whenCompleteAsync((result, throwable) -> {
    System.out.println("当前加锁情况：" + result + throwable);    
}
// 解锁
rLock.unlock(); 
```