---
title: 《深入理解Java虚拟机》一、运行时数据区域
date: 2019-11-19 16:24:04
categories: Java
tags: 
- Ebbinghaus
- Java虚拟机
description: 1. 程序计数器、2. Java虚拟机栈、3. 本地方法栈、4. Java堆、5. 方法区、6. 运行时常量池、7. 直接内存
---
> 《深入理解Java虚拟机》


# 一、运行时数据区域
- Java虚拟机由四部分组成：ClassLoader(类加载器)、Execution Engine(执行引擎)、Native Interface(本地接口)、Runtime Data Area(运行时数据区域)
- 运行时数据区域：JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
    ![](/images/java/jvm/1.png)

## 程序计数器
- 程序计数器（Program Counter Register）是一块较小的内存空间，记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）

## Java虚拟机栈
- Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息
- 从方法调用直至执行完成的过程，对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程
- 可以通过`-Xss`参数来指定每个线程的Java虚拟机栈内存大小，JDK1.4默认256K，JDK1.5+默认1M
```java
java -Xss2M HackTheJava
```
- 该区域可能抛出以下异常
    - 当线程请求的栈深度超过最大值，会抛出StackOverflowError异常
    - 栈进行动态扩展时，如果无法申请到足够内存，会抛出OutOfMemoryError异常
    ![](/images/java/jvm/2.png)

## 本地方法栈
- 本地方法栈：与虚拟机栈类似，区别是本地方法栈为本地方法服务
- 本地方法一般是使用其他语言编写的，并且被编译为基于本机硬件和操作系统的程序，对这些方法需特别处理
    - JNI：Java本地接口（Java Native Interface）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地库，也可以被其他程序调用
    ![](/images/java/jvm/3.png)

## Java堆
- Java堆：所有的对象都在堆中分配内存，是垃圾收集的主要区域（GC堆）
- 主要采用分代收集算法，其主要思想是针对不同类型的对象采取不同的垃圾回收算法
    - 新生代（Young Generation）
    - 老年代（Old Generation）
- 堆不需要连续内存，并且可以动态增加内存，增加失败会抛出OutOfMemoryError异常
- 可以通过`-Xms`和`-Xmx`参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个设置最大值
```java
java -Xms1M -Xmx2M HackTheJava
```

## 方法区
- 方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器（JIT编译器）编译后的代码等数据
- 和堆一样不需要连续的内存，并且可以动态扩展，扩展失败也会抛出OutOfMemoryError异常
- 对方法区的垃圾回收主要目标是：常量池的回收、对类的卸载，但是比较难实现
- 永久代
    - HotSpot虚拟机把方法区当作永久代进行垃圾回收，但很难确定永久代的大小，因为有很多因素的影响，并且每次Full GC后永久代的大小都会改变，所以经常抛出OOM异常
    - 为了更容易管理方法区，从JDK1.8开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中
- 方法区是一个JVM规范，永久代与元空间都是方法区的实现方式。JDK1.8后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，堆存储静态变量和常量池

## 运行时常量池
- 运行时常量池：是方法区的一部分。Class文件中的常量池会在类加载后被放入运行时常量池
- 除了在编译期生成的常量，也允许动态生成，如String类的intern()方法

## 直接内存
- JDK1.4中引入了NIO（New Input/Output）类，它可以使用Native函数库直接分配堆外内存，然后通过Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作
- 好处：能在某些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据
