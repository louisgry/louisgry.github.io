---
title: 《深入理解Java虚拟机》二、垃圾收集
date: 2019-11-20 16:24:04
categories: Java
tags: 
- Ebbinghaus
- Java虚拟机
description: 1. 判断一个对象是否可被回收、2. 引用类型、3. 垃圾收集算法、4. 垃圾收集器
---
> 《深入理解Java虚拟机》


# 二、垃圾收集
- 垃圾收集针对Java堆和方法区进行。程序计数器、虚拟机栈、本地方法栈属于线程私有的，只存在于线程的生命周期内，线程结束后就会消失，不需要进行垃圾回收

## 判断一个对象是否可被回收
### 1. 引用计数算法
- 为对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1，回收引用计数为0的对象
- 缺点：循环引用（引用计数器永远不为0）
```java
public class ReferenceCountingGC {

    public Object instance = null;
    
    public static void main(String[] args) {
        // 循环引用，无法回收
        ReferenceCountingGC a = new ReferenceCountingGC();
        ReferenceCountingGC b = new ReferenceCountingGC();
        a.instance = b;
        b.instance = a;
        
        a = null;
        b = null;
    }
}
```

### 2. 可达性分析算法
- 以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收
- Java虚拟机使用该算法来判断对象是否可被回收
- 可作为GC Roots的对象
    - 虚拟机栈中局部变量表中引用的对象
    - 本地方法栈JNI中引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量引用的对象
    ![](/images/java/jvm/4.png)

### 3. 方法区的回收
- 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类（常量池的回收和对类的卸载）
- 废弃常量：与回收堆中的对象类似。如字符串"abc"进入常量池，却没有String对象引用，则被回收
- 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能
- 无用的类：需同时满足以下3个条件
    - 该类所有的实例都已经被回收，此时Java堆中不存在该类的任何实例
    - 加载该类的ClassLoader已经被回收
    - 该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类的方法

### 4. finalize()
- 类似C++的析构函数，用于关闭外部资源
- 当一个对象可被回收时，如果需要执行该对象的finalize()方法，那么就有可能在该方法中让对象重新被引用，从而实现自救
- 自救只能进行一次，如果回收的对象之前调用了finalize()方法自救，后面回收时不会再调用该方法


## 引用类型
- 判断对象是否可被回收都与引用有关

### 1. 强引用
- 强引用：被强引用关联的对象不会被回收，可以通过将对象设置为null来弱化引用，使其被回收
```java
String str = new String("abc");
```

### 2. 软引用
- 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收
```java
SoftReference<String> a = new SoftReference<String>(str);
```

### 3. 弱引用
- 弱引用：被弱引用关联的对象一定会被回收，即只能存活到下一次垃圾回收发生之前
```java
WeakReference<String> b = new WeakReference<String>(str);
```

### 4. 虚引用
- 虚引用：一个对象是否有虚引用，不会对其生存时间造成影响，也无法通过虚引用得到一个对象
- 目的：能在这个对象被回收前收到一个系统通知
```java
ReferenceQueue queue = new ReferenceQueue();
String str = new String("abc");
PhantomReference ref = new PhantomReference(str, queue);
```

## 垃圾收集算法
### 1. 标记-清除算法
- 标记-清除（Mark-Sweep），分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象，标记过程使用标记方法判定
- 回收对象就是把对象分块，连接到被称为“空间链表”的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块
- 缺点
    - 效率问题：标记和清除过程效率不高
    - 空间问题：会产生大量不连续的内存碎片，导致无法给大对象分配内存

### 2. 标记-整理算法
- 标记-整理（Mark-Compact），让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存
- 优点：不会产生内存碎片
- 缺点：需要移动大量对象，处理效率比较低

### 3. 复制算法
- 复制（Copying），将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后把使用过的内存空间进行清理
- 现代虚拟机用复制算法回收新生代，但不是划分为相等的两块，而是Eden:Survivor默认为8:1，每次只使用Eden和其中一块Survivor（From、To是变化的），回收时将Eden和From中还存活的对象复制到To区，然后清理Eden和From区
- 缺点：只使用了内存的一半，需要额外的空间进行分配担保。且对象存活率高的场景就要进行较多的复制，效率会变低，所以不适用于老年代
    ![](/images/java/jvm/5.png)

### 4. 分代收集算法
- 分代收集（Generational Collection），现代虚拟机所采用，它根据对象存活周期的不同将内存划分为块，不同块采用不同的收集算法
- 新生代：使用复制算法
- 老年代：使用标记-清除算法，或标记-整理算法

## 垃圾收集器
- HotSpot虚拟机中的7个垃圾收集器，连线表示可以配合使用
    - 单线程与多线程：ParNew、Parallel Scavenge、Parallel Old是多线程的
    - 串行与并行：垃圾收集器与用户程序是交替执行或同时执行，只有CMS和G1是并行的
    ![](/images/java/jvm/6.png)

### 1. Serial
- Serial的意思是串行，即以串行的方式执行，Serial是单线程的收集器，只会使用一个线程进行垃圾收集
- Client下默认的新生代收集器，因为该场景下内存一般不会很大
- 优点：简单高效，在单CPU下，由于没有线程交互的开销，因此有最高的单线程收集效率

### 2. ParNew
- ParNew是Serial收集器的多线程版本
- Server下默认的新生代收集器，除了性能外，主要是因为除了Serial，只有ParNew能与CMS收集器配合使用

### 3. Parallel Scavenge
- Parallel Scavenge也是多线程收集器，其收集目标是吞吐量优先（适用于后台运行程序），不同于其他的目标是尽可能缩短垃圾收集时用户线程的停顿时间。缩短停顿时间是以牺牲吞吐量和新生代空间换取的：新生代空间变小，垃圾回收变频繁，导致吞吐量下降
- 系统吞吐量=运行用户程序时间/(运行用户程序时间+GC时间)
- 可以通过开关参数`-XX:+UseAdaptiveSizePolicy`打开GC自适应的调节策略（GC Ergonomics），就不用手动设置新生代大小、Eden和Survivor比例、晋升老年代对象年龄等参数

### 4. Serial Old
- Serial Old是Serial收集器的老年代版本，Client下的老年代收集器
- 如果用在Server场景下，有两大用途
    - 在JDK1.5及以前，与Parallel Scavenge配合使用
    - 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

### 5. Parallel Old
- Parallel Old是Parallel Scavenge的老年代版本
- 在注重吞吐量和CPU资源敏感的场景，可以优先考虑Parallel Scavenge和Parallel Old收集器

### 6. CMS
- CMS（Concurrent Mark Sweep），基于标记-清除算法，是一种以获取最短回收停顿时间为目标，适用于服务端应用（重视服务的响应速度，希望系统停顿时间最短，有更好的用户体验）。使用CMS来收集老年代时，新生代的收集只能选Serial或ParNew
    - 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要停顿（Stop The World）
    - 并发标记：进行GC Roots Tracing的过程，在整个回收过程中耗时最长，不需要停顿
    - 重新标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需用停顿（Stop The World）
    - 并发清除：不需要停顿
- 优点：并发收集、低停顿
- 缺点
    - 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高
    - 无法处理浮动垃圾，可能会出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC才被回收。由于浮动垃圾的存在，因此需要预留出一部分内存，此时CMS不能像其他收集器那样等待老年代快满了才回收。如果预留的内存不够存放，就会出下Concurrent Mode Failure，这时会触发Full GC，使用Serial old临时替换CMS，停顿时间变长
    - 空间问题：标记-清除算法导致的空间碎片，会出现老年代空间剩余，但无法找到足够大的连续空间来分配当前对象，要提前触发一次Full GC

### 7. G1
- G1（Garbage First），是一款面向服务端应用的垃圾收集器，在多CPU和大内存场景下有很好的性能
- G1可以直接对新生代和老年代一起回收，它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离
- 每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region，通过使用该Set在可达性分析时可以避免全堆扫描
    - 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象
    - 并发标记：从GC Root开始对堆中对象进行可达性分析，找出存活的对象，耗时长，但可并行
    - 最终标记：为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，虚拟机将对象变化记录在Remembered Set Logs里面，并合并数据到Set中，需要停顿，但可并行
    - 筛选回收：首先对Region中的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可并行
- 特点
    - 空间整合：整体是标记-整理算法，局部（两Region之间）是复制算法，不会有内存碎片
    - 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间内，消耗在GC上的时间不超过N毫秒
    ![](/images/java/jvm/7.png)


