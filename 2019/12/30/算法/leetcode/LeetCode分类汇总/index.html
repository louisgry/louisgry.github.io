<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="数据结构（栈、队列、链表、二叉树）、算法思想（游标、Partition、双指针、滑动窗口、动态规划、贪心、回溯）">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode分类汇总">
<meta property="og:url" content="https://louisgry.github.io/2019/12/30/%E7%AE%97%E6%B3%95/leetcode/LeetCode%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Louis&#39; Blog">
<meta property="og:description" content="数据结构（栈、队列、链表、二叉树）、算法思想（游标、Partition、双指针、滑动窗口、动态规划、贪心、回溯）">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-12-30T06:26:51.000Z">
<meta property="article:modified_time" content="2020-03-01T12:17:50.258Z">
<meta property="article:author" content="Louis">
<meta property="article:tag" content="Ebbinghaus">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
  <link rel="canonical" href="https://louisgry.github.io/2019/12/30/%E7%AE%97%E6%B3%95/leetcode/LeetCode%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>LeetCode分类汇总 | Louis' Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Louis' Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
          <i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://louisgry.github.io/2019/12/30/%E7%AE%97%E6%B3%95/leetcode/LeetCode%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Louis">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Louis' Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            LeetCode分类汇总
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-30 14:26:51" itemprop="dateCreated datePublished" datetime="2019-12-30T14:26:51+08:00">2019-12-30</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-description">数据结构（栈、队列、链表、二叉树）、算法思想（游标、Partition、双指针、滑动窗口、动态规划、贪心、回溯）</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><ul>
<li>栈<ul>
<li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. Valid Parentheses</a>：<a href="#20题解">【20题解】</a> </li>
<li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a>：<a href="#144题解">【144题解】</a></li>
</ul>
</li>
</ul>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><ul>
<li>队列<ul>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a>：<a href="#102题解">【102题解】</a></li>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. Top K Frequent Elements</a>：<a href="#347题解">【347题解】</a></li>
<li><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a>：<a href="#279题解-Queue">【279题解-Queue】</a></li>
</ul>
</li>
</ul>
<h2 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h2><ul>
<li>链表<ul>
<li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a>：<a href="#206题解">【206题解】</a></li>
<li><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements</a>：<a href="#203题解">【203题解】</a></li>
<li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs</a>：<a href="#24题解">【24题解】</a></li>
<li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List</a>：<a href="#237题解">【237题解】</a></li>
<li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a>：<a href="#19题解">【19题解】</a></li>
<li><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a>：<a href="#234题解">【234题解】</a></li>
</ul>
</li>
</ul>
<h2 id="binarytree"><a href="#binarytree" class="headerlink" title="binarytree"></a>binarytree</h2><ul>
<li>二叉树<ul>
<li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a>：<a href="#104题解">【104题解】</a></li>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a>：<a href="#111题解">【11题解】</a></li>
<li><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert Binary Tree</a>：<a href="#226题解">【226题解】</a></li>
<li><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a>：<a href="#100题解">【100题解】</a></li>
<li><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a>：<a href="#101题解">【101题解】</a></li>
<li><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. Count Complete Tree Nodes</a>：<a href="#222题解">【222题解】</a></li>
<li><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. Balanced Binary Tree</a>：<a href="#110题解">【110题解】</a></li>
<li><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a>：<a href="#112题解">【112题解】</a></li>
<li><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. Sum of Left Leaves</a>：<a href="#404题解">【404题解】</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths</a>：<a href="#257题解">【257题解】</a></li>
<li><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a>：<a href="#113题解">【113题解】</a></li>
<li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a>：<a href="#129题解">【129题解】</a></li>
<li><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a>：<a href="#437题解">【437题解】</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a>：<a href="#235题解">【235题解】</a></li>
</ul>
</li>
</ul>
<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><ul>
<li>查找表<ul>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. Intersection of Two Arrays</a>：<a href="#349题解">【349题解】</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. Intersection of Two Arrays II</a>：<a href="#350题解">【350题解】</a></li>
<li><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram</a>：<a href="#242题解">【242题解】</a></li>
<li><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">202. Happy Number</a>：<a href="#202题解">【202题解】</a></li>
<li><a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">290. Word Pattern</a>：<a href="#290题解">【290题解】</a></li>
<li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum</a>：<a href="#1题解">【1题解】</a></li>
<li><a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 4Sum II</a>：<a href="#454题解">【454题解】</a></li>
<li><a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. Number of Boomerangs</a>：<a href="#447题解">【447题解】</a></li>
<li><a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">804. Unique Morse Code Words</a>：<a href="#804题解">【804题解】</a></li>
<li><a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. Contains Duplicate II</a>：<a href="#219题解">【219题解】</a></li>
<li><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contain Duplicate III</a>：<a href="#220题解">【220题解】</a></li>
</ul>
</li>
</ul>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h2><ul>
<li>游标<ul>
<li><a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">283. Move Zeroes</a>：<a href="#283题解">【283题解】</a></li>
<li><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">27. Remove Element</a>：<a href="#27题解">【27题解】</a></li>
</ul>
</li>
</ul>
<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><ul>
<li>Partition<ul>
<li><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">75. Sort Colors</a>：<a href="#75题解">【75题解】</a></li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a>：<a href="#215题解">【215题解】</a></li>
</ul>
</li>
</ul>
<h2 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h2><ul>
<li>双指针<ul>
<li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted</a>：<a href="#167题解">【167题解】</a></li>
<li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a>：<a href="#11题解">【11题解】</a></li>
<li><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. Valid Palindrome</a>：<a href="#125题解">【125题解】</a></li>
<li><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a>：<a href="#345题解">【345题解】</a></li>
</ul>
</li>
</ul>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul>
<li>滑动窗口<ul>
<li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a>：<a href="#209题解">【209题解】</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a>：<a href="#3题解">【3题解】</a></li>
<li><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String</a>：<a href="#438题解">【438题解】</a></li>
<li><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring</a>：<a href="#76题解">【76题解】</a></li>
<li><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. Permutation in String</a>：<a href="#567题解">【567题解】</a></li>
<li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. Longest Repeating Character Replacement</a>：<a href="#424题解">【424题解】</a></li>
</ul>
</li>
</ul>
<h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul>
<li>动态规划<ul>
<li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing Stairs</a>：<a href="#70题解">【70题解】</a></li>
<li><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break</a>：<a href="#343题解">【343题解】</a></li>
<li><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a>：<a href="#198题解">【198题解】</a></li>
<li><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a>：<a href="#279题解">【279题解】</a></li>
<li><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways</a>：<a href="#91题解">91题解</a></li>
<li><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a>：<a href="#416题解">【416题解】</a></li>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a>：<a href="#300题解">【300题解】</a></li>
<li><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence</a>：<a href="#1143题解">【1143题解】</a></li>
</ul>
</li>
</ul>
<h2 id="greedy"><a href="#greedy" class="headerlink" title="greedy"></a>greedy</h2><ul>
<li>贪心<ul>
<li><a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">455. Assign Cookies</a>：<a href="#455题解">【455题解】</a></li>
<li><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. Non-overlapping Intervals</a>：<a href="#435题解">【435题解】</a></li>
</ul>
</li>
</ul>
<h2 id="backtracking"><a href="#backtracking" class="headerlink" title="backtracking"></a>backtracking</h2><ul>
<li>回溯<ul>
<li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number</a>：<a href="#17题解">【17题解】</a></li>
<li><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations</a>：<a href="#46题解">【46题解】</a></li>
<li><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. Combinations</a>：<a href="#77题解">【77题解】</a></li>
<li><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search</a>：<a href="#79题解">【79题解】</a></li>
<li><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands</a>：<a href="#200题解">【200题解】</a></li>
<li><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">51. N Queens</a>：<a href="#51题解">【51题解】</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>stack</strong></p>
<h3 id="20题解"><a href="#20题解" class="headerlink" title="20题解"></a>20题解</h3><ul>
<li>stack<ul>
<li>20 Valid Parentheses：<a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a><ul>
<li>判断括号是否匹配</li>
<li>Input: “()[]{}”</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：使用栈</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">    for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">        // 注意是单引号，char</span><br><span class="line">        if(s.charAt(i)==&apos;(&apos; || s.charAt(i)==&apos;&#123;&apos; || s.charAt(i)==&apos;[&apos;) &#123;</span><br><span class="line">            stack.push(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(stack.size() == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            char c = stack.pop();</span><br><span class="line">            char match;</span><br><span class="line">            if(s.charAt(i)==&apos;)&apos;) &#123;</span><br><span class="line">                match = &apos;(&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s.charAt(i)==&apos;&#125;&apos;) &#123;</span><br><span class="line">                match = &apos;&#123;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                assert s.charAt(i)==&apos;]&apos;;</span><br><span class="line">                match = &apos;[&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(match != c)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stack.size() != 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="144题解"><a href="#144题解" class="headerlink" title="144题解"></a>144题解</h3><ul>
<li>stack<ul>
<li>144 Binary Tree Preorder Traversal：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-preorder-traversal/</a><ul>
<li>二叉树的前序遍历</li>
<li>Input: binary tree [1,2,3]</li>
<li>Output: [1,2,3]</li>
</ul>
</li>
<li>思路1：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    preorderTraversal(root, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void preorderTraversal(TreeNode node, List&lt;Integer&gt; list) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    preorderTraversal(node.left, list);</span><br><span class="line">    preorderTraversal(node.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：非递归（使用栈）</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Command &#123;</span><br><span class="line">    String s;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    Command(String s, TreeNode node)&#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">        this.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(root == null)&#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Command&gt; stack = new Stack&lt;Command&gt;();</span><br><span class="line">    stack.push(new Command(&quot;go&quot;, root));</span><br><span class="line">    while(!stack.empty()) &#123;</span><br><span class="line">        Command command = stack.pop();</span><br><span class="line">        if(command.s == &quot;print&quot;)&#123;</span><br><span class="line">            res.add(command.node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            assert command.s.equals(&quot;go&quot;);</span><br><span class="line">            // 因为栈的先进后出，所以要反过来</span><br><span class="line">            if(command.node.right != null)&#123;</span><br><span class="line">                stack.push(new Command(&quot;go&quot;, command.node.right));</span><br><span class="line">            &#125;</span><br><span class="line">            if(command.node.left != null)&#123;</span><br><span class="line">                stack.push(new Command(&quot;go&quot;, command.node.left));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(new Command(&quot;print&quot;, command.node));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>queue</strong></p>
<h3 id="102题解"><a href="#102题解" class="headerlink" title="102题解"></a>102题解</h3><ul>
<li>queue<ul>
<li>102 Binary Tree Level Order Traversal：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a><ul>
<li>二叉树的层序遍历</li>
<li>Input: binary tree [3,9,20,null,null,15,7]</li>
<li>Output: [[3], [9,20], [15,7]]</li>
</ul>
</li>
<li>思路：队列</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // LinkedList实现Queue</span><br><span class="line">    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt;();</span><br><span class="line">    queue.addLast(new Pair&lt;TreeNode, Integer&gt;(root, 0));</span><br><span class="line">    while(!queue.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;TreeNode, Integer&gt; front = queue.removeFirst();</span><br><span class="line">        TreeNode node = front.getKey();</span><br><span class="line">        int level = front.getValue();</span><br><span class="line">        // 等于表示在新的一层中</span><br><span class="line">        if(level == res.size())&#123;</span><br><span class="line">            res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        // 需用get方法，不能直接使用下标索引</span><br><span class="line">        res.get(level).add(node.val);</span><br><span class="line">        if(node.left != null)&#123;</span><br><span class="line">            queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.left, level+1));</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right != null)&#123;</span><br><span class="line">            queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.right, level+1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="347题解"><a href="#347题解" class="headerlink" title="347题解"></a>347题解</h3><ul>
<li>queue<ul>
<li>347 Top K Frequent Elements：<a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a><ul>
<li>返回前k个出现频率最高的元素</li>
<li>Input: nums = [1,1,1,2,2,3], k = 2</li>
<li>Output: [1,2]</li>
</ul>
</li>
<li>思路：优先队列</li>
<li>时间复杂度：O(nlogk)</li>
<li>空间复杂度：O(n+k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">    // 统计每个元素出现的频率：map（元素，频率）</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; freq = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(!freq.containsKey(nums[i])) &#123;</span><br><span class="line">            freq.put(nums[i], 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            freq.put(nums[i], freq.get(nums[i])+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 维护出现频率最高的k个元素：优先队列（频率，元素）</span><br><span class="line">    PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt;(new PairComparator());</span><br><span class="line">    for(Integer num : freq.keySet()) &#123;</span><br><span class="line">        int numFreq = freq.get(num);</span><br><span class="line">        if(pq.size() == k) &#123;</span><br><span class="line">            if(numFreq &gt; pq.peek().getKey()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(new Pair&lt;Integer, Integer&gt;(numFreq, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            pq.add(new Pair&lt;Integer, Integer&gt;(numFreq, num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    while(!pq.isEmpty()) &#123;</span><br><span class="line">        res.add(pq.poll().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">// 基于Pair的最大堆</span><br><span class="line">private class PairComparator implements Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2) &#123;</span><br><span class="line">        if(p1.getKey() != p2.getKey()) &#123;</span><br><span class="line">            return p1.getKey() - p2.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        return p1.getValue() - p2.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="279题解-Queue"><a href="#279题解-Queue" class="headerlink" title="279题解-Queue"></a>279题解-Queue</h3><ul>
<li>queue<ul>
<li>279 Perfect Squares：<a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a><ul>
<li>给定一个正整数n，求其由最少个完全平方数组成的和等于n的个数</li>
<li>Input: n = 13</li>
<li>Output: 2</li>
<li>Explanation: 13 = 4 + 9.</li>
</ul>
</li>
<li>思路：Queue</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;Integer, Integer&gt;&gt;();</span><br><span class="line">    queue.addLast(new Pair&lt;Integer, Integer&gt;(n, 0));</span><br><span class="line">    </span><br><span class="line">    boolean[] visited = new boolean[n+1];</span><br><span class="line">    visited[n] = true;</span><br><span class="line">    </span><br><span class="line">    while(!queue.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;Integer, Integer&gt; front = queue.removeFirst();</span><br><span class="line">        int num = front.getKey();</span><br><span class="line">        int step = front.getValue();</span><br><span class="line">        </span><br><span class="line">        if(num == 0) &#123;</span><br><span class="line">            res = step;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; num-i*i&gt;=0; i++) &#123;</span><br><span class="line">            if(!visited[num-i*i]) &#123;</span><br><span class="line">                queue.addLast(new Pair&lt;Integer, Integer&gt;(num-i*i, step+1));</span><br><span class="line">                visited[num-i*i] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>linkedlist</strong></p>
<h3 id="206题解"><a href="#206题解" class="headerlink" title="206题解"></a>206题解</h3><ul>
<li>linkedlist<ul>
<li>206 Reverse Linked List：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a><ul>
<li>反转一个链表</li>
<li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li>
<li>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li>
</ul>
</li>
<li>思路1：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：迭代</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="203题解"><a href="#203题解" class="headerlink" title="203题解"></a>203题解</h3><pre><code>- 203 Remove Linked List Elements：https://leetcode.com/problems/remove-linked-list-elements/
    - 删除链表中特定值的所有元素
    - Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
    - Output: 1-&gt;2-&gt;3-&gt;4-&gt;5
- 思路：dummy head
- 时间复杂度：O(n)
- 空间复杂度：O(1)
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="24题解"><a href="#24题解" class="headerlink" title="24题解"></a>24题解</h3><ul>
<li>linkedlist<ul>
<li>24 Swap Nodes in Pairs：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/</a><ul>
<li>链表两两交换节点</li>
<li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;null</li>
<li>Output: 2-&gt;1-&gt;4-&gt;3-&gt;null</li>
</ul>
</li>
<li>思路：dummy head</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyHead.next = head;        </span><br><span class="line">    </span><br><span class="line">    ListNode p = dummyHead;</span><br><span class="line">    <span class="comment">// 注意：边界是p.next和p.next.next</span></span><br><span class="line">    <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode node1 = p.next;</span><br><span class="line">        ListNode node2 = node1.next;</span><br><span class="line">        ListNode next = node2.next;</span><br><span class="line">        </span><br><span class="line">        node2.next = node1;</span><br><span class="line">        node1.next = next;</span><br><span class="line">        p.next = node2;</span><br><span class="line">        p = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="237题解"><a href="#237题解" class="headerlink" title="237题解"></a>237题解</h3><ul>
<li>linkedlist<ul>
<li>237 Delete Node in a Linked List：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a><ul>
<li>给定链表中的一个节点，删除该节点</li>
<li>Input: head = [4,5,1,9], node = 5</li>
<li>Output: [4,1,9]</li>
<li>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</li>
</ul>
</li>
<li>思路：修改链表的值</li>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void deleteNode(ListNode node) &#123;</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.next == null)&#123;</span><br><span class="line">        node = null;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="19题解"><a href="#19题解" class="headerlink" title="19题解"></a>19题解</h3><ul>
<li>linkedlist<ul>
<li>19 Remove Nth Node From End of List：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a><ul>
<li>删除链表的倒数第N个元素</li>
<li>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5, n = 2</li>
<li>Output: 1-&gt;2-&gt;3-&gt;5</li>
</ul>
</li>
<li>思路：双指针，p和q之间的长度是固定的，只遍历一遍</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode p = dummyHead;</span><br><span class="line">    ListNode q = dummyHead;</span><br><span class="line">    for(int i=0; i&lt;n+1; i++)&#123;</span><br><span class="line">        assert q != null;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(q != null) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    </span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>基础解法：遍历两遍，第一遍求链表的size，第二遍使用dummyHead删除第size-n个元素</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">    ListNode dummyHead = new ListNode(0);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = dummyHead.next;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while(cur != null)&#123;</span><br><span class="line">        index ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = dummyHead;</span><br><span class="line">    for(int i=0; i&lt;index-n; i++)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = cur.next.next;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="234题解"><a href="#234题解" class="headerlink" title="234题解"></a>234题解</h3><ul>
<li>linkedlist<ul>
<li>234 Palindrome Linked List：<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a><ul>
<li>判断链表是否是回文的</li>
<li>Input: 1-&gt;2-&gt;2-&gt;1</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：双指针</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode q = head;</span><br><span class="line">    while(q!=null &amp;&amp; q.next!=null) &#123;</span><br><span class="line">        q = q.next.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(q != null)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = reverse(p);</span><br><span class="line"></span><br><span class="line">    q = head;</span><br><span class="line">    while(p != null) &#123;</span><br><span class="line">        if(p.val != q.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">private ListNode reverse(ListNode node) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = node;</span><br><span class="line">    while(cur != null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>binarytree</strong></p>
<h3 id="104题解"><a href="#104题解" class="headerlink" title="104题解"></a>104题解</h3><ul>
<li>104题解<ul>
<li>104 Maximum Depth of Binary Tree：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a><ul>
<li>返回二叉树的最大深度</li>
<li>Input: Given binary tree [3,9,20,null,null,15,7]</li>
<li>Output: 3</li>
</ul>
</li>
<li>知识：深度K=「log2n」+1（向下取整）</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)，n是节点数</li>
<li>空间复杂度：O(h)，h是树深度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="111题解"><a href="#111题解" class="headerlink" title="111题解"></a>111题解</h3><ul>
<li>111题解<ul>
<li>111 Minimum Depth of Binary Tree：<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a><ul>
<li>求二叉树的最低深度</li>
<li>Input: Given binary tree [3,9,20,null,null,15,7]</li>
<li>Output: 2</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int minDepth(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    if (root.left!=null) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.left)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right!=null) &#123;</span><br><span class="line">        min = Math.min(min, minDepth(root.right)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="226题解"><a href="#226题解" class="headerlink" title="226题解"></a>226题解</h3><ul>
<li>226题解<ul>
<li>226 Invert Binary Tree：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a><ul>
<li>反转二叉树，左右子树对调</li>
<li>Input: Given binary tree [4,2,7,1,3,6,9]</li>
<li>Output: return binary tree [4,7,2,9,6,3,1]</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    // swap</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="100题解"><a href="#100题解" class="headerlink" title="100题解"></a>100题解</h3><ul>
<li>100题解<ul>
<li>100 Same Tree：<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/</a><ul>
<li>判断两颗二叉树是否相同</li>
<li>Input: binary tree [1,2,null], [1,null,2]</li>
<li>Output: false</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (p==null &amp;&amp; q==null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p==null || q==null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.val != q.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left = isSameTree(p.left, q.left);</span><br><span class="line">    boolean right = isSameTree(p.right, q.right);</span><br><span class="line">    return left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="101题解"><a href="#101题解" class="headerlink" title="101题解"></a>101题解</h3><ul>
<li>101题解<ul>
<li>101 Symmetric Tree：<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a><ul>
<li>判断二叉树是否对称</li>
<li>Input: binary tree [1,2,2,null,3,null,3]</li>
<li>Output: false</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return isMirror(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line">private boolean isMirror(TreeNode p, TreeNode q) &#123;</span><br><span class="line">    if (p==null &amp;&amp; q==null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p==null || q==null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.val != q.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="222题解"><a href="#222题解" class="headerlink" title="222题解"></a>222题解</h3><ul>
<li>222题解<ul>
<li>222 Count Complete Tree Nodes：<a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-complete-tree-nodes/</a><ul>
<li>计算完全二叉树节点个数</li>
<li>Input: binary tree [1,2,3,4,5,6,null]</li>
<li>Output: 6</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int countNodes(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root==null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归过程</span><br><span class="line">    return 1+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="110题解"><a href="#110题解" class="headerlink" title="110题解"></a>110题解</h3><ul>
<li>110题解<ul>
<li>110 Balanced Binary Tree：<a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/balanced-binary-tree/</a><ul>
<li>判断是否为平衡二叉树（每个节点的左右子树高度差不超过1）</li>
<li>Input: binary tree [1,2,2,3,3,null,null,4,4]</li>
<li>Output: false</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Math.abs(getDepth(root.left)-getDepth(root.right))&gt;1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归过程</span><br><span class="line">    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line">private int getDepth(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1 + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="112题解"><a href="#112题解" class="headerlink" title="112题解"></a>112题解</h3><ul>
<li>112题解<ul>
<li>112 Path Sum：<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/</a><ul>
<li>找出二叉树路径中的是否有一条和等于sum</li>
<li>Input: binary tree [5,4,8,11,null,13,4,7,2]</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return root.val == sum;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    return hasPathSum(root.left, sum-root.val) ||</span><br><span class="line">            hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="404题解"><a href="#404题解" class="headerlink" title="404题解"></a>404题解</h3><ul>
<li>404题解<ul>
<li>404 Sum of Left Leaves：<a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-left-leaves/</a><ul>
<li>求左叶子节点的和</li>
<li>Input: binary tree [3,9,20,null,null,15,7]</li>
<li>Output: 24</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left!=null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null) &#123;</span><br><span class="line">        sum += root.left.val;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    sum += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="257题解"><a href="#257题解" class="headerlink" title="257题解"></a>257题解</h3><ul>
<li>257题解<ul>
<li>257 Binary Tree Paths：<a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-paths/</a><ul>
<li>返回二叉树所有路径的path</li>
<li>Input: binary tree [1,2,3,null,5]</li>
<li>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span><br><span class="line">    // 递归终止条件</span><br><span class="line">    if (root == null ) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        result.add(Integer.toString(root.val));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归过程</span><br><span class="line">    List&lt;String&gt; leftPath = binaryTreePaths(root.left);</span><br><span class="line">    for (String i : leftPath) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(&quot;-&gt;&quot;);</span><br><span class="line">        sb.append(i);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; rightPath = binaryTreePaths(root.right);</span><br><span class="line">    for (String j : rightPath) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(Integer.toString(root.val));</span><br><span class="line">        sb.append(&quot;-&gt;&quot;);</span><br><span class="line">        sb.append(j);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="113题解"><a href="#113题解" class="headerlink" title="113题解"></a>113题解</h3><ul>
<li>113题解<ul>
<li>113 Path Sum II：<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a><ul>
<li>返回二叉树路径中的所有等于sum的路径</li>
<li>Input: binary tree [5,4,8,11,null,13,4,7,2,null,null,5,1]</li>
<li>Output: [[5,4,11,2],[5,8,4,5]]</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; middle = new ArrayList&lt;&gt;();</span><br><span class="line">    getPathSum(root, sum, middle, result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private void getPathSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; middle, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    middle.add(root.val);</span><br><span class="line">    if(root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        if(root.val == sum) &#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(middle));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    getPathSum(root.left, sum-root.val, middle, result);</span><br><span class="line">    getPathSum(root.right, sum-root.val, middle, result);</span><br><span class="line">    middle.remove(middle.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="129题解"><a href="#129题解" class="headerlink" title="129题解"></a>129题解</h3><ul>
<li>129题解<ul>
<li>129 Sum Root to Leaf Numbers：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a><ul>
<li>求所有路径组成的数字的和</li>
<li>Input: binary tree [1,2,3]</li>
<li>Output: 25</li>
<li>Explanation:<ul>
<li>The root-to-leaf path 1-&gt;2 represents the number 12.</li>
<li>The root-to-leaf path 1-&gt;3 represents the number 13.</li>
<li>Therefore, sum = 12 + 13 = 25.</li>
</ul>
</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">    return getSum(root, 0);</span><br><span class="line">&#125;</span><br><span class="line">private int getSum(TreeNode root, int curSum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    curSum = curSum*10 + root.val;</span><br><span class="line">    if(root.left==null &amp;&amp; root.right==null) &#123;</span><br><span class="line">        return curSum;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    return getSum(root.left, curSum) + getSum(root.right, curSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="437题解"><a href="#437题解" class="headerlink" title="437题解"></a>437题解</h3><ul>
<li>437题解<ul>
<li>437 Path Sum III：<a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/</a><ul>
<li>求二叉树中等于给定sum的路径，路径可以不从根节点开始</li>
<li>Input: binary tree [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</li>
<li>Output: 3</li>
<li>Explanation: three paths [[5,3], [5,2,1], [-3,11]]</li>
</ul>
</li>
<li>思路：递归嵌套递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    return findPath(root, sum)</span><br><span class="line">            + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">&#125;</span><br><span class="line">private int findPath(TreeNode node, int sum) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(node == null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    if(node.val == sum)&#123;</span><br><span class="line">        res += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    res += findPath(node.left, sum-node.val);</span><br><span class="line">    res += findPath(node.right, sum-node.val);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="235题解"><a href="#235题解" class="headerlink" title="235题解"></a>235题解</h3><ul>
<li>235题解<ul>
<li>235 Lowest Common Ancestor of a Binary Search Tree：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a><ul>
<li>寻找两个节点最近的公共祖先</li>
<li>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</li>
<li>Output: 2</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(h)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    // condition</span><br><span class="line">    if(root == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // recursion</span><br><span class="line">    if(p.val&lt;root.val &amp;&amp; q.val&lt;root.val) &#123;</span><br><span class="line">        return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    if(p.val&gt;root.val &amp;&amp; q.val&gt;root.val) &#123;</span><br><span class="line">        return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>collection</strong></p>
<h3 id="349题解"><a href="#349题解" class="headerlink" title="349题解"></a>349题解</h3><ul>
<li>349题解<ul>
<li>349 Intersection of Two Arrays：<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays/</a><ul>
<li>找两个数组的交集</li>
<li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li>
<li>Output: [2]</li>
</ul>
</li>
<li>思路：Set</li>
<li>时间复杂度：O(n+m)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; record = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums1) &#123;</span><br><span class="line">        record.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; result = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums2) &#123;</span><br><span class="line">        if(record.contains(num)) &#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] res = new int[result.size()];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(Integer num : result) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="350题解"><a href="#350题解" class="headerlink" title="350题解"></a>350题解</h3><ul>
<li>350题解<ul>
<li>350 Intersection of Two Arrays II：<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a><ul>
<li>找两个数组的交集（包括重复的）</li>
<li>Input: nums1 = [1,2,2,1], nums2 = [2,2]</li>
<li>Output: [2,2]</li>
</ul>
</li>
<li>思路：Map</li>
<li>时间复杂度：O(n+mlogn)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int num : nums1) &#123;</span><br><span class="line">        if(!map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            map.put(num, map.get(num)+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    for(int num : nums2) &#123;</span><br><span class="line">        if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0) &#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">            map.put(num, map.get(num)-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] res = new int[result.size()];</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(Integer num : result) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="242题解"><a href="#242题解" class="headerlink" title="242题解"></a>242题解</h3><ul>
<li>242题解<ul>
<li>242 Valid Anagram：<a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a><ul>
<li>判断两个字符串是否为回文串</li>
<li>Input: s = “anagram”, t = “nagaram”</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：Hash Table</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(26)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">    if(s.length() != t.length())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // HashTable</span><br><span class="line">    int[] freq = new int[26];</span><br><span class="line">    for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">        freq[s.charAt(i)-&apos;a&apos;]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">        freq[t.charAt(i)-&apos;a&apos;]--;</span><br><span class="line">        if(freq[t.charAt(i)-&apos;a&apos;] &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="202题解"><a href="#202题解" class="headerlink" title="202题解"></a>202题解</h3><ul>
<li>202题解<ul>
<li>202 Happy Number：<a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a><ul>
<li>判断一个数字是否为happy number</li>
<li>Input: 19</li>
<li>Output: true</li>
<li>Explanation: <ul>
<li>1^2 + 9^2 = 82</li>
<li>8^2 + 2^2 = 68</li>
<li>6^2 + 8^2 = 100</li>
<li>1^2 + 0^2 + 0^2 = 1</li>
</ul>
</li>
</ul>
</li>
<li>思路：Set</li>
<li>时间复杂度：O(?)</li>
<li>空间复杂度：O(?)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isHappy(int n) &#123;</span><br><span class="line">     if(n&lt;1) &#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">     int t;</span><br><span class="line">     int newN;</span><br><span class="line">     while(n!=1 &amp;&amp; !set.contains(n)) &#123;</span><br><span class="line">         set.add(n);</span><br><span class="line">         newN = 0;</span><br><span class="line">         while(n&gt;0) &#123;</span><br><span class="line">             t = n%10;</span><br><span class="line">             n /= 10;</span><br><span class="line">             newN += t*t;</span><br><span class="line">         &#125;</span><br><span class="line">         n = newN;</span><br><span class="line">     &#125;</span><br><span class="line">     return n == 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="290题解"><a href="#290题解" class="headerlink" title="290题解"></a>290题解</h3><ul>
<li>290题解<ul>
<li>290 Word Pattern：<a href="https://leetcode.com/problems/word-pattern/" target="_blank" rel="noopener">https://leetcode.com/problems/word-pattern/</a><ul>
<li>判断所给的string是否是pattern的形式</li>
<li>Input: pattern = “abba”, str = “dog cat cat dog”</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：Map</li>
<li>时间复杂度：O(nlogm)</li>
<li>空间复杂度：O(n+m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">    HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;();</span><br><span class="line">    char[] patterns = pattern.toCharArray();</span><br><span class="line">    String[] strs = str.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">    if(patterns.length != strs.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;patterns.length; i++) &#123;</span><br><span class="line">        char c = patterns[i];</span><br><span class="line">        if(!map.containsKey(c)) &#123;</span><br><span class="line">            if(map.containsValue(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            String value = map.get(c);</span><br><span class="line">            if(!value.equals(strs[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="1题解"><a href="#1题解" class="headerlink" title="1题解"></a>1题解</h3><ul>
<li>1题解<ul>
<li>1 Two Sum：<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a><ul>
<li>找出数组中和等于target的数字的下标（注意nums不是有序的）</li>
<li>Input: nums = [2, 7, 11, 15], target = 9</li>
<li>Output: [0,1]</li>
</ul>
</li>
<li>思路：将元素a放入Map中，之后查找target-a是否存在</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if(map.containsKey(complement)) &#123;</span><br><span class="line">            res[0] = i;</span><br><span class="line">            res[1] = map.get(complement);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="454题解"><a href="#454题解" class="headerlink" title="454题解"></a>454题解</h3><ul>
<li>454题解<ul>
<li>454 4Sum II：<a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a><ul>
<li>求四个整型数组的有多少种组合相加等于0</li>
<li>Input: A = [ 1, 2], B = [-2,-1], C = [-1, 2], D = [ 0, 2]</li>
<li>Output: 2</li>
<li>Explanation: The two tuples are:<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
</li>
</ul>
</li>
<li>思路：将C+D的所有组合放入Map中</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;C.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; D.length; j++) &#123;</span><br><span class="line">            int sum = C[i] + D[j];</span><br><span class="line">            if(!map.containsKey(sum)) &#123;</span><br><span class="line">                map.put(sum, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                map.put(sum, map.get(sum)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i=0; i&lt;A.length; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;B.length; j++) &#123;</span><br><span class="line">            if(map.containsKey(0-A[i]-B[j])) &#123;</span><br><span class="line">                res += map.get(0-A[i]-B[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="447题解"><a href="#447题解" class="headerlink" title="447题解"></a>447题解</h3><ul>
<li>447题解<ul>
<li>447 Number of Boomerangs：<a href="https://leetcode.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-boomerangs/</a><ul>
<li>寻找符合Boomerangs定义的三元组的个数</li>
<li>Input: [[0,0],[1,0],[2,0]]</li>
<li>Output: 2</li>
<li>Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]</li>
</ul>
</li>
<li>思路：以i为枢纽点，把其他点跟i的距离放入Map，查找距离相同点的个数的组合</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int numberOfBoomerangs(int[][] points) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    // 遍历枢纽点i</span><br><span class="line">    for(int i=0; i&lt;points.length; i++) &#123;</span><br><span class="line">        // 把其他点的距离放入Map</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for(int j=0; j&lt;points.length; j++) &#123;</span><br><span class="line">            if(j != i) &#123;</span><br><span class="line">                // 对比距离时使用距离的平方，无浮点数误差问题</span><br><span class="line">                int dist = dis(points[i], points[j]);</span><br><span class="line">                if(!map.containsKey(dist))</span><br><span class="line">                    map.put(dist, 1);</span><br><span class="line">                else</span><br><span class="line">                    map.put(dist, map.get(dist)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算相同距离点的个数的组合</span><br><span class="line">        for(Integer dis : map.keySet())</span><br><span class="line">            res += map.get(dis) * (map.get(dis)-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private int dis(int[] a, int[] b) &#123;</span><br><span class="line">    return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="804题解"><a href="#804题解" class="headerlink" title="804题解"></a>804题解</h3><ul>
<li>804题解<ul>
<li>804 Unique Morse Code Words：<a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-morse-code-words/</a><ul>
<li>返回不同摩斯码的个数</li>
<li>Input: words = [“gin”, “zen”, “gig”, “msg”]</li>
<li>Output: 2</li>
<li>Explanation: There are 2 different transformations, “–…-.” and “–…–.”.</li>
</ul>
</li>
<li>思路：使用Set返回不同摩斯码的个数</li>
<li>时间复杂度：O(n+s)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int uniqueMorseRepresentations(String[] words) &#123;</span><br><span class="line">    String[] codes = &#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;</span><br><span class="line">    TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();</span><br><span class="line">    for(String word : words) &#123;</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        for(int i=0; i&lt;word.length(); i++)</span><br><span class="line">            res.append(codes[word.charAt(i)-&apos;a&apos;]);</span><br><span class="line">        set.add(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    return set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="219题解"><a href="#219题解" class="headerlink" title="219题解"></a>219题解</h3><ul>
<li>219题解<ul>
<li>219 Contains Duplicate II：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-ii/</a><ul>
<li>判断数组是否在k长度内有重复元素</li>
<li>Input: nums = [1,2,3,1], k = 3</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：Set+滑动窗口</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyDuplicate(int[] nums, int k) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(set.contains(nums[i]))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        // 保持set中最多有k个元素（边界：i-k）</span><br><span class="line">        if(set.size() == k+1)&#123;</span><br><span class="line">            set.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="220题解"><a href="#220题解" class="headerlink" title="220题解"></a>220题解</h3><ul>
<li>220题解<ul>
<li>220 Contain Duplicate III：<a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-iii/</a><ul>
<li>判断数组是否在k长度内有差值不大于t的两个数</li>
<li>Input: nums = [1,2,3,1], k = 3, t = 0</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：set+滑动窗口</li>
<li>时间复杂度：O(nlogk)</li>
<li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">    // 需要用Long和long，会发生整型溢出</span><br><span class="line">    TreeSet&lt;Long&gt; set = new TreeSet&lt;Long&gt;();</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        if(set.ceiling((long)nums[i]-(long)t) != null &amp;&amp; set.ceiling((long)nums[i]-(long)t)&lt;=(long)nums[i]+(long)t)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add((long)nums[i]);</span><br><span class="line">        if(set.size() == k+1)&#123;</span><br><span class="line">            set.remove((long)nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<hr>
<p><strong>cursor</strong></p>
<h3 id="283题解"><a href="#283题解" class="headerlink" title="283题解"></a>283题解</h3><ul>
<li>283题解<ul>
<li>283 Move Zeroes：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a><ul>
<li>把数组中的零移到后面去</li>
<li>Input: [0,1,0,3,12]</li>
<li>Output: [1,3,12,0,0]</li>
</ul>
</li>
<li>问题：使用了O(n)的空间，可以原地吗？</li>
<li>优化1：用一个k游标去保存非零元素的个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">    // 优化1：原地，不用O(n)的空间</span><br><span class="line">    // 时间复杂度：O(n)</span><br><span class="line">    // 空间复杂度：O(1)</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        if(nums[i]!=0)</span><br><span class="line">            nums[k++] = nums[i];</span><br><span class="line">    for(int i=k; i&lt;nums.length; i++)</span><br><span class="line">        nums[i] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优化2：swap 0和非0（用游标k，就不用再for循环了）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">    // 优化2：swap 0和非0（用游标k，就不用再for循环了）</span><br><span class="line">    // 时间复杂度：O(n)</span><br><span class="line">    // 空间复杂度：O(1)</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        if(nums[i]!=0)&#123;</span><br><span class="line">            // swap(nums[i], nums[k])</span><br><span class="line">            if(i!=k)&#123;</span><br><span class="line">                int t = nums[i];</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k] = t;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            else // i==k</span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="27题解"><a href="#27题解" class="headerlink" title="27题解"></a>27题解</h3><ul>
<li>27题解<ul>
<li>27 Remove Element：<a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-element/</a> <ul>
<li>给定nums，删除指定的值val</li>
<li>Input: nums = [3,2,2,3], val = 3,</li>
<li>Output: Your function should return length = 2, with the first two elements of nums being 2.</li>
</ul>
</li>
<li>思路：cursor</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        if(nums[i] != val)&#123;</span><br><span class="line">            if(i!=k)&#123;</span><br><span class="line">                int t = nums[i];</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k] = t;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>partition</strong></p>
<h3 id="75题解"><a href="#75题解" class="headerlink" title="75题解"></a>75题解</h3><ul>
<li>75题解<ul>
<li>75 Sort Color：<a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a><ul>
<li>对三种颜色进行排序，用0,1,2表示颜色</li>
<li>Input: [2,0,2,1,1,0]</li>
<li>Output: [0,0,1,1,2,2]</li>
</ul>
</li>
<li>思路：使用三路快排：只需一次for循环</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">    int zero = -1;</span><br><span class="line">    int two = nums.length;</span><br><span class="line">    for(int i=0; i&lt;two; )&#123;</span><br><span class="line">        // 1</span><br><span class="line">        if(nums[i]==1)</span><br><span class="line">            i++;</span><br><span class="line">        // 2</span><br><span class="line">        else if(nums[i]==2)&#123;</span><br><span class="line">            two--;</span><br><span class="line">            swap(nums, i, two);</span><br><span class="line">        &#125;</span><br><span class="line">        // 0</span><br><span class="line">        else&#123;</span><br><span class="line">            assert(nums[i]==0);</span><br><span class="line">            zero++;</span><br><span class="line">            swap(nums, i, zero);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="215题解"><a href="#215题解" class="headerlink" title="215题解"></a>215题解</h3><ul>
<li>215题解<ul>
<li>215 Kth Largest Element in an Array：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> <ul>
<li>返回第K大的数</li>
<li>Input: [3,2,1,5,6,4] and k = 2</li>
<li>Output: 5</li>
</ul>
</li>
<li>思路：快排Partition思路</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(logn)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    return findKthLargest(nums, 0, nums.length-1, k-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int findKthLargest(int[] nums, int l, int r, int k)&#123;</span><br><span class="line">    if(l==r)</span><br><span class="line">        return nums[l];</span><br><span class="line">    int p = partition(nums, l, r);</span><br><span class="line"></span><br><span class="line">    if( p == k )</span><br><span class="line">        return nums[p];</span><br><span class="line">    else if( k &lt; p )</span><br><span class="line">        return findKthLargest(nums, l, p-1, k);</span><br><span class="line">    else // k &gt; p</span><br><span class="line">        return findKthLargest(nums, p+1 , r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int partition(int[] nums, int l , int r)&#123;</span><br><span class="line">    int p = (int) (Math.random()%(r-l+1) + l);</span><br><span class="line">    swap(nums, l, p);</span><br><span class="line">    int lt = l + 1;</span><br><span class="line">    for( int i = l + 1 ; i &lt;= r ; i ++ )</span><br><span class="line">        if( nums[i] &gt; nums[l] )</span><br><span class="line">            swap(nums, i, lt++);</span><br><span class="line">    swap(nums, l, lt-1);</span><br><span class="line">    return lt-1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void swap(int[] nums, int i, int j)&#123;</span><br><span class="line">    int t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<hr>
<p><strong>pointers</strong></p>
<h3 id="167题解"><a href="#167题解" class="headerlink" title="167题解"></a>167题解</h3><ul>
<li>167题解<ul>
<li>167 Two Sum II：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</a> <ul>
<li>给定排序好的数组，找出两数和等于target的下标，index1&lt;index2</li>
<li>Input: numbers = [2,7,11,15], target = 9</li>
<li>Output: [1,2]</li>
</ul>
</li>
<li>思路：使用双指针，一个在前，一个在后，指针随sum与target的差距而变化</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">    int index1;</span><br><span class="line">    int index2 = numbers.length-1;</span><br><span class="line">    int[] result = &#123;0, 0&#125;;</span><br><span class="line">    for(index1=0; index1&lt;numbers.length; )&#123;</span><br><span class="line">        if(numbers[index1]+numbers[index2]==target)&#123;</span><br><span class="line">            result[0] = index1+1;</span><br><span class="line">            result[1] = index2+1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(numbers[index1]+numbers[index2]&lt;target)</span><br><span class="line">            index1++;</span><br><span class="line">        else</span><br><span class="line">            index2--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="11题解"><a href="#11题解" class="headerlink" title="11题解"></a>11题解</h3><ul>
<li>11题解<ul>
<li>11 Container With Most Water：<a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a> <ul>
<li>求Container的最大面积</li>
<li>Input: [1,8,6,2,5,4,8,3,7]</li>
<li>Output: 49</li>
</ul>
</li>
<li>思路：双指针</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">    int area = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = height.length-1;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        int t = (j-i)*Math.min(height[i], height[j]);</span><br><span class="line">        if(t&gt;area)</span><br><span class="line">            area = t;</span><br><span class="line">        if(height[i]&lt;height[j])</span><br><span class="line">            i++;</span><br><span class="line">        else</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="125题解"><a href="#125题解" class="headerlink" title="125题解"></a>125题解</h3><ul>
<li>125题解<ul>
<li>125 Valid Palindrome：<a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a><ul>
<li>判断字符串是否为回文串，可跳过符号（空字符串是回文串）</li>
<li>Input: “A man, a plan, a canal: Panama”</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：双指针</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">    if(s==null)</span><br><span class="line">        return true;</span><br><span class="line">    String reg = &quot;[^0-9a-zA-Z]&quot;;</span><br><span class="line">    s = s.replaceAll(reg, &quot;&quot;);</span><br><span class="line">    int i=0, j=s.length()-1;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        char c1 = Character.toLowerCase(s.charAt(i));</span><br><span class="line">        char c2 = Character.toLowerCase(s.charAt(j));</span><br><span class="line">        if(c1 == c2)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="345题解"><a href="#345题解" class="headerlink" title="345题解"></a>345题解</h3><ul>
<li>345题解<ul>
<li>345 Reverse Vowels of a String：<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-vowels-of-a-string/</a><ul>
<li>swap字符串中的元音字母</li>
<li>Input: “hello”</li>
<li>Output: “holle”</li>
</ul>
</li>
<li>思路：双指针</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String reverseVowels(String s) &#123;</span><br><span class="line">    int i=0, j=s.length()-1;</span><br><span class="line">    char[] arr = s.toCharArray();</span><br><span class="line">    String vowels = &quot;aeiouAEIOU&quot;;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        if(!vowels.contains(arr[i]+&quot;&quot;))&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!vowels.contains(arr[j]+&quot;&quot;))&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(vowels.contains(arr[i]+&quot;&quot;)&amp;&amp;vowels.contains(arr[j]+&quot;&quot;))&#123;</span><br><span class="line">            char c = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = c;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>window</strong></p>
<h3 id="209题解"><a href="#209题解" class="headerlink" title="209题解"></a>209题解</h3><ul>
<li>209题解<ul>
<li>209 Minimum Size Subarray Sum：<a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-size-subarray-sum/</a><ul>
<li>求最短子序和sum&lt;=s</li>
<li>Input: s = 7, nums = [2,3,1,2,4,3]</li>
<li>Output: 2</li>
<li>注意：子数组是否连续？没有解怎么办？</li>
</ul>
</li>
<li>思路：滑动窗口（维护nums[i…j]，如果sum比s小 sum += nums[++j]，否则sum -= nums[i++]）</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">    int i = 0, j = -1; // j最开始是-1，不包含任何元素</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int min= nums.length+1; // 设一个最大的数n+1取不到</span><br><span class="line">    while (i&lt;nums.length)&#123; // 遍历[0...n-1]，不是i&lt;j</span><br><span class="line">        if(j+1&lt;nums.length &amp;&amp; sum &lt; s)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(sum&gt;=s)</span><br><span class="line">           min = Math.min(len, j-i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(min==nums.length+1) // 没有判断过不了输出为0的测试用例：[1,1] 3</span><br><span class="line">        return 0;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="3题解"><a href="#3题解" class="headerlink" title="3题解"></a>3题解</h3><ul>
<li>3题解<ul>
<li>3 Longest Substring Without Repeating Characters：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a><ul>
<li>求字符串不重复子串的最长值</li>
<li>Input: “abcabcbb”</li>
<li>Output: 3 </li>
<li>Explanation: The answer is “abc”, with the length of 3.</li>
</ul>
</li>
<li>思路：滑动窗口，使用freq[256]记录重复字符</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    int[] freq = new int[256]; // 记录字母是否重复</span><br><span class="line">    int i=0, j=-1;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while(i&lt;s.length())&#123;</span><br><span class="line">        if(j+1&lt;s.length() &amp;&amp; freq[s.charAt(j+1)]==0)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            freq[s.charAt(j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            freq[s.charAt(i)]--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        len = Math.max(len, j-i+1); // 注意：是最长子串max</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="438题解"><a href="#438题解" class="headerlink" title="438题解"></a>438题解</h3><ul>
<li>438题解<ul>
<li>438 Find All Anagrams in a String：<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-anagrams-in-a-string/</a><ul>
<li>找字符串的Anagram的开始下标</li>
<li>Input: s: “cbaebabacd” p: “abc”</li>
<li>Output: [0, 6]</li>
<li>Explanation:<ul>
<li>The substring with start index = 0 is “cba”, which is an anagram of “abc”.</li>
<li>The substring with start index = 6 is “bac”, which is an anagram of “abc”.</li>
</ul>
</li>
</ul>
</li>
<li>思路：滑动窗口</li>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">    List&lt;Integer&gt; indexList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    int i=0, j=0;</span><br><span class="line">    int count = p.length();</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    for (char c : p.toCharArray())&#123;</span><br><span class="line">        freq[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt; s.length())&#123;</span><br><span class="line">        if (freq[s.charAt(j++)]-- &gt; 0)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            indexList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if (j-i==p.length() &amp;&amp; freq[s.charAt(i++)]++ &gt;= 0)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return indexList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="76题解"><a href="#76题解" class="headerlink" title="76题解"></a>76题解</h3><ul>
<li>76题解<ul>
<li>76 Minimum Window Substring：<a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a><ul>
<li>求字符串s中包含字符串t的最小窗口</li>
<li>Input: S = “ADOBECODEBANC”, T = “ABC”</li>
<li>Output: “BANC”</li>
</ul>
</li>
<li>思路：滑动窗口</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">    int[] sFreq = new int[256];</span><br><span class="line">    int count = 0;</span><br><span class="line">    int[] tFreq = new int[256];</span><br><span class="line">    for (int i=0; i&lt;t.length(); i++)&#123;</span><br><span class="line">        tFreq[t.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int minLen = s.length()+1;</span><br><span class="line">    int startIndex = -1;</span><br><span class="line">    int i=0, j=-1;</span><br><span class="line">    while (i&lt;s.length())&#123;</span><br><span class="line">        if (j+1&lt;s.length() &amp;&amp; count&lt;t.length())&#123;</span><br><span class="line">            sFreq[s.charAt(j+1)]++;</span><br><span class="line">            if (sFreq[s.charAt(j+1)] &lt;= tFreq[s.charAt(j+1)])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            assert count&lt;=t.length();</span><br><span class="line">            if(count==t.length() &amp;&amp; j-i+1&lt;minLen)&#123;</span><br><span class="line">                minLen = j-i+1;</span><br><span class="line">                startIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            sFreq[s.charAt(i)]--;</span><br><span class="line">            if (sFreq[s.charAt(i)] &lt; tFreq[s.charAt(i)])&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (startIndex != -1)&#123;</span><br><span class="line">        return s.substring(startIndex, startIndex+minLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="567题解"><a href="#567题解" class="headerlink" title="567题解"></a>567题解</h3><ul>
<li>567题解<ul>
<li>567 Permutation in String：<a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">https://leetcode.com/problems/permutation-in-string/</a><ul>
<li>在字符串s2里找是否有字符串s1的全排列</li>
<li>Input: s1 = “ab” s2 = “eidbaooo”</li>
<li>Output: True</li>
<li>Explanation: s2 contains one permutation of s1 (“ba”)</li>
</ul>
</li>
<li>思路：滑动窗口</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean checkInclusion(String s1, String s2) &#123;</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    for (char c : s1.toCharArray()) &#123;</span><br><span class="line">        freq[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int i=0, count=0;</span><br><span class="line">    for (int j=0; j&lt;s2.length(); j++) &#123;</span><br><span class="line">        freq[s2.charAt(j)]--;</span><br><span class="line">        if (freq[s2.charAt(j)] &gt;= 0) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j &gt;= s1.length()) &#123;</span><br><span class="line">            freq[s2.charAt(i)]++;</span><br><span class="line">            if (freq[s2.charAt(i)] &gt;= 1) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count==s1.length()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="424题解"><a href="#424题解" class="headerlink" title="424题解"></a>424题解</h3><ul>
<li>424题解<ul>
<li>424 Longest Repeating Character Replacement：<a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-repeating-character-replacement/</a><ul>
<li>如字符串s可以替换k次，求最长的连续重复字符的个数</li>
<li>Input: s = “ABAB”, k = 2    </li>
<li>Output: 4</li>
<li>Explanation: Replace the two ‘A’s with two ‘B’s or vice versa.</li>
</ul>
</li>
<li>思路：滑动窗口</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int characterReplacement(String s, int k) &#123;</span><br><span class="line">    int i=0, j=0;</span><br><span class="line">    int max = 0;</span><br><span class="line">    int maxCount = 0;</span><br><span class="line">    int[] freq = new int[256];</span><br><span class="line">    while (j&lt;s.length()) &#123;</span><br><span class="line">        freq[s.charAt(j)]++;</span><br><span class="line">        maxCount = Math.max(maxCount, freq[s.charAt(j)]);</span><br><span class="line">        j++;</span><br><span class="line">        while(j-i-maxCount &gt; k) &#123;</span><br><span class="line">            freq[s.charAt(i++)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<hr>
<p><strong>dp</strong></p>
<h3 id="70题解"><a href="#70题解" class="headerlink" title="70题解"></a>70题解</h3><ul>
<li>dp<ul>
<li>70 Climbing Stairs：<a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a><ul>
<li>给定n，求step的组合，step仅为1和2</li>
<li>Input: 2</li>
<li>Output: 2</li>
<li>Explanation: There are two ways to climb to the top.<ul>
<li>1 step + 1 step</li>
<li>2 steps</li>
</ul>
</li>
</ul>
</li>
<li>递归解法：StackOverflowError栈溢出（原因没有指定n=1的情况）<ul>
<li>过不了：Time Limit Exceeded </li>
</ul>
</li>
<li>Key：爬上n-1阶台阶再爬1阶，或者爬上n-2阶台阶再爬2阶</li>
<li>记忆化搜索memo：自顶向下的解决问题</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    memo = new int[n+2];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return climbing(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int climbing(int n)&#123;</span><br><span class="line">    if(n==1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(n==2)</span><br><span class="line">        return 2;</span><br><span class="line">    if(memo[n]==-1)</span><br><span class="line">        memo[n] = climbing(n-1) + climbing(n-2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划：自底向上的解决问题</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+2];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    memo[1] = 1;</span><br><span class="line">    memo[2] = 2;</span><br><span class="line">    for(int i=3; i&lt;=n; i++)</span><br><span class="line">       memo[i] = memo[i-1]+memo[i-2];</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="343题解"><a href="#343题解" class="headerlink" title="343题解"></a>343题解</h3><ul>
<li>dp<ul>
<li>343 Integer Break：<a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode.com/problems/integer-break/</a> <ul>
<li>给定正整数n，分割n为至少两个数之和，返回分割后的数字相乘的最大值</li>
<li>Input: 10</li>
<li>Output: 36</li>
<li>Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</li>
</ul>
</li>
<li>Key：f(n) = max(i*f(n-i))</li>
</ul>
</li>
</ul>
<pre><code>- 递归：Time Limit Exceeded（暴力解法：回溯遍历这个数分割的所有可能性 O(2^n)）
- 思路1：记忆化搜索
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int integerBreak(int n) &#123;</span><br><span class="line">    memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return breakInteger(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// break</span><br><span class="line">private int breakInteger(int n)&#123;</span><br><span class="line">    if(n==1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(memo[n] != -1)</span><br><span class="line">        return memo[n];</span><br><span class="line">    int max = -1;</span><br><span class="line">    for(int i=1; i&lt;=n-1; i++)</span><br><span class="line">        max = max3(max, i*(n-i), i*breakInteger(n-i));</span><br><span class="line">    memo[n] = max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// max3</span><br><span class="line">private int max3(int a, int b, int c)&#123;</span><br><span class="line">    return Math.max(a, Math.max(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- 思路2：动态规划
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int integerBreak(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    </span><br><span class="line">    memo[1] = 1;</span><br><span class="line">    for(int i=2; i&lt;=n; i++)</span><br><span class="line">        // 求解memo[i]</span><br><span class="line">        for(int j=1; j&lt;=i-1; j++)</span><br><span class="line">            memo[i] = max3(memo[i], j*(i-j), j*memo[i-j]);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// max3</span><br><span class="line">private int max3(int a, int b, int c)&#123;</span><br><span class="line">    return Math.max(a, Math.max(b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="198题解"><a href="#198题解" class="headerlink" title="198题解"></a>198题解</h3><ul>
<li>dp<ul>
<li>198 House Robber：<a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a> <ul>
<li>给定nums数组代表连续相邻的家庭所有的money，若抢相邻的两家会触发报警，求所能抢的money的最大值</li>
<li>Input: [1,2,3,1]</li>
<li>Output: 4</li>
<li>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<ul>
<li>Total amount you can rob = 1 + 3 = 4.</li>
</ul>
</li>
</ul>
</li>
<li>Key<ul>
<li>状态（函数的定义）：考虑偷取[x…n-1]范围里的房子</li>
<li>状态转移方程：f(0)=max{v(0)+f(2), v(1)+f(3), v(2)+f(4), …, v(n-3)+f(n-1), v(n-2), v(n-1)}</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 思路1：记忆化搜索
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return tryRobber(nums, 0);</span><br><span class="line">&#125;</span><br><span class="line">// 考虑抢劫[x...n-1]</span><br><span class="line">private int tryRobber(int[] nums, int index)&#123;</span><br><span class="line">    if(index &gt;= nums.length)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[index] != -1)</span><br><span class="line">        return memo[index];</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=index; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, nums[i] + tryRobber(nums, i+2));</span><br><span class="line">    memo[index] = max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
- 思路2：动态规划
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[] memo = new int[n];</span><br><span class="line">        Arrays.fill(memo, -1);</span><br><span class="line">        memo[n-1] = nums[n-1];</span><br><span class="line">        for(int i=n-2; i&gt;=0; i--)&#123;</span><br><span class="line">            // memo[i]</span><br><span class="line">            for(int j=i; j&lt;n; j++)</span><br><span class="line">// memo[i] = Math.max(memo[i], nums[j] + memo[j+2]);</span><br><span class="line">                memo[i] = Math.max(memo[i], nums[j] + (j+2&lt;n ? memo[j+2] : 0));</span><br><span class="line">        &#125;</span><br><span class="line">        return memo[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="279题解"><a href="#279题解" class="headerlink" title="279题解"></a>279题解</h3><ul>
<li>dp<ul>
<li>279 Perfect Squares：<a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a><ul>
<li>给定一个正整数n，求其由最少个完全平方数组成的和等于n的个数</li>
<li>Input: n = 13</li>
<li>Output: 2</li>
<li>Explanation: 13 = 4 + 9.</li>
</ul>
</li>
<li>Key：f(n) = min(1+f(n-i^2))</li>
<li>思路1：记忆化搜索</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    return squares(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int squares(int n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[n] != -1)</span><br><span class="line">        return memo[n];</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    for(int i=1; n-i*i&gt;=0; i++)</span><br><span class="line">        min = Math.min(min, 1+squares(n-i*i));</span><br><span class="line">    memo[n] = min;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    Arrays.fill(memo, Integer.MAX_VALUE);</span><br><span class="line">    memo[0] = 0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        for(int j=1; i-j*j&gt;=0; j++)</span><br><span class="line">        memo[i] = Math.min(memo[i], 1+memo[i-j*j]);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="91题解"><a href="#91题解" class="headerlink" title="91题解"></a>91题解</h3><ul>
<li>dp<ul>
<li>91 Decode Ways：<a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a><ul>
<li>求数字解码对应的字母含义的组合个数</li>
<li>Input: “12”</li>
<li>Output: 2</li>
<li>Explanation: It could be decoded as “AB” (1 2) or “L” (12)</li>
</ul>
</li>
<li>思路1：记忆化搜索</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int numDecodings(String s) &#123;</span><br><span class="line">    memo = new int[s.length()+1];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    memo[s.length()] = 1;</span><br><span class="line">    return getNum(s, 0);</span><br><span class="line">&#125;</span><br><span class="line">private int getNum(String s, int i) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    if(n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(memo[i] &gt; -1) &#123;</span><br><span class="line">        return memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(s.charAt(i) == &apos;0&apos;) &#123;</span><br><span class="line">        return memo[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = getNum(s, i+1);</span><br><span class="line">    if(i&lt;s.length()-1 &amp;&amp; Integer.parseInt(s.substring(i, i+2)) &lt;= 26) &#123;</span><br><span class="line">        res += getNum(s, i+2);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int numDecodings(String s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    if(n == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] memo = new int[n+1];</span><br><span class="line">    memo[n] = 1;</span><br><span class="line">    memo[n-1] = s.charAt(n-1)==&apos;0&apos; ? 0 : 1;</span><br><span class="line">    for(int i=n-2; i&gt;=0; i--) &#123;</span><br><span class="line">        if(s.charAt(i) == &apos;0&apos;) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            memo[i] = Integer.parseInt(s.substring(i, i+2)) &lt;= 26 ? memo[i+1] + memo[i+2] : memo[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="416题解"><a href="#416题解" class="headerlink" title="416题解"></a>416题解</h3><ul>
<li>dp<ul>
<li>416 Partition Equal Subset Sum：<a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-equal-subset-sum/</a><ul>
<li>给定数组nums，求其是否可以被分成两个子数组，其和相等（注意：最多有200个数字，每个数字最大为100）</li>
<li>Input: [1, 5, 11, 5]</li>
<li>Output: true</li>
<li>Explanation: The array can be partitioned as [1, 5, 5] and [11].</li>
</ul>
</li>
<li>是背包问题：在n个物品中选一定物品，是否可以完全填满sum/2的背包</li>
<li>Key：状态：F(i,c) = F(i-1,c) || F(i-1, c-w(i))</li>
<li>数据规模 $n<em>sum/2=100</em>100*200/2$：最多有200个数字，每个数字最大为100</li>
<li>思路1：记忆化搜索</li>
<li>时间复杂度：O(n*sum)</li>
<li>空间复杂度：O(n*sum)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int[][] memo; // memo[i][c]: -1是未计算，0是不可填充，1是可以填充</span><br><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">        assert nums[i]&gt;0;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum%2 != 0)</span><br><span class="line">        return false;</span><br><span class="line">    memo = new int[nums.length][sum/2+1]; // 表示0...sum/2，故+1</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        Arrays.fill(memo[i], -1);</span><br><span class="line">    return tryPartition(nums, nums.length-1, sum/2);</span><br><span class="line">&#125;</span><br><span class="line">// 使用nums[0...index]是否可以完全填满sum的背包</span><br><span class="line">private boolean tryPartition(int[] nums, int index, int sum)&#123;</span><br><span class="line">    if(sum==0) // 背包没有空间，即填满了</span><br><span class="line">        return true;</span><br><span class="line">    if(sum&lt;0 || index&lt;0)</span><br><span class="line">        return false;</span><br><span class="line">    if(memo[index][sum] != -1)</span><br><span class="line">        return memo[index][sum] == 1;</span><br><span class="line">    memo[index][sum] = tryPartition(nums, index-1, sum) || tryPartition(nums, index-1, sum-nums[index]) ? 1: 0;</span><br><span class="line">    return memo[index][sum] == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划</li>
<li>时间复杂度：O(n*sum)</li>
<li>空间复杂度：O(sum)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">        assert nums[i]&gt;0;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int C = sum/2;</span><br><span class="line">    if(sum%2 != 0)</span><br><span class="line">        return false;</span><br><span class="line">    boolean[] memo = new boolean[C+1]; // 表示0...sum/2</span><br><span class="line">    for(int j=0; j&lt;=C; j++)</span><br><span class="line">        memo[j] = (nums[0] == j); // j -&gt; c</span><br><span class="line">    for(int i=1; i&lt;n; i++)</span><br><span class="line">        for(int j=C; j&gt;=nums[i]; j--)</span><br><span class="line">            memo[j] = memo[j] || memo[j-nums[i]];</span><br><span class="line">        </span><br><span class="line">    return memo[C];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="300题解"><a href="#300题解" class="headerlink" title="300题解"></a>300题解</h3><ul>
<li>dp<ul>
<li>300 Longest Increasing Subsequence：<a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/</a><ul>
<li>求最长上升子序列的length </li>
<li>Input: [10,9,2,5,3,7,101,18]</li>
<li>Output: 4 </li>
<li>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </li>
</ul>
</li>
<li>Key<ul>
<li>状态：f(i)表示以第i个数字为结尾的最长上升子序列的长度（即[0…i]里选择nums[i]可以获得的最长上升子序列）</li>
<li>转移方程：f(i) = max(1+f(j) if nums[j]&lt;nums[i])</li>
</ul>
</li>
<li>思路1：记忆化搜索</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int[] memo;</span><br><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0)</span><br><span class="line">        return 0;</span><br><span class="line">    memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, -1);</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, getMaxLen(nums, i));</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">private int getMaxLen(int[] nums, int index)&#123;</span><br><span class="line">    if(memo[index] != -1)</span><br><span class="line">        return memo[index];</span><br><span class="line">    int max = 1;</span><br><span class="line">    for(int i=0; i&lt;index; i++)</span><br><span class="line">        if(nums[i] &lt; nums[index])</span><br><span class="line">            max = Math.max(max, 1+getMaxLen(nums, i));</span><br><span class="line">    memo[index] = max;</span><br><span class="line">    return memo[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0)</span><br><span class="line">        return 0;</span><br><span class="line">    int[] memo = new int[nums.length];</span><br><span class="line">    Arrays.fill(memo, 1);</span><br><span class="line">    for(int i=1; i&lt;nums.length; i++)</span><br><span class="line">        for(int j=0; j&lt;i; j++)</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                memo[i] = Math.max(memo[i], 1+memo[j]);</span><br><span class="line">    int max = 0;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++)</span><br><span class="line">        max = Math.max(max, memo[i]);</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="1143题解"><a href="#1143题解" class="headerlink" title="1143题解"></a>1143题解</h3><ul>
<li>dp<ul>
<li>1143 Longest Common Subsequence：<a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-subsequence/</a><ul>
<li>LCS：找两个字符串的最长公共子序列的长度</li>
<li>Input: text1 = “abcde”, text2 = “ace” </li>
<li>Output: 3  </li>
<li>Explanation: The longest common subsequence is “ace” and its length is 3.</li>
</ul>
</li>
<li>Key<ul>
<li>状态：f(m,n)表示两个字符串s1[0…m]，s2[0…n]的LCS长度</li>
<li>状态转移方程：若s1[m]==s2[n] 则f(m,n)=1+f(m-1,n-1)，若s1[m]!=s2[n] 则f(m,n)=max( f(m-1,n), f(m,n-1) )</li>
</ul>
</li>
<li>思路1：记忆化搜索</li>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int[][] memo;</span><br><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    assert text1!=null &amp;&amp; text2!=null;</span><br><span class="line">    if(text1.length()==0 || text2.length()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    memo = new int[text1.length()][text2.length()];</span><br><span class="line">    for(int i=0; i&lt;text1.length(); i++)</span><br><span class="line">        Arrays.fill(memo[i], -1);</span><br><span class="line">    return lcs(text1, text2, text1.length()-1, text2.length()-1);</span><br><span class="line">&#125;</span><br><span class="line">// 求s1[0...m]和s2[0...n]的最长公共子序列的长度</span><br><span class="line">private int lcs(String s1, String s2, int m, int n)&#123;</span><br><span class="line">    if(m&lt;0 || n&lt;0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(memo[m][n] != -1)</span><br><span class="line">        return memo[m][n];</span><br><span class="line">    int max = 0;</span><br><span class="line">    if(s1.charAt(m)==s2.charAt(n))</span><br><span class="line">        max = 1 + lcs(s1, s2, m-1, n-1);</span><br><span class="line">    else</span><br><span class="line">        max = Math.max(lcs(s1, s2, m-1, n), lcs(s1, s2, m, n-1));</span><br><span class="line">    memo[m][n] =max;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划</li>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int m = text1.length();</span><br><span class="line">    int n = text2.length();</span><br><span class="line">    int memo[][] = new int[m][n];</span><br><span class="line">    // init</span><br><span class="line">    for(int i=0; i&lt;m; i++)</span><br><span class="line">        if(text1.charAt(i)==text2.charAt(0))&#123;</span><br><span class="line">            for(int j=i; j&lt;m; j++)</span><br><span class="line">                memo[j][0] = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=0; i&lt;n; i++)</span><br><span class="line">        if(text1.charAt(0)==text2.charAt(i))&#123;</span><br><span class="line">            for(int j=i; j&lt;n; j++)</span><br><span class="line">                memo[0][j] = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    // dp</span><br><span class="line">    for(int i=1; i&lt;m; i++)</span><br><span class="line">        for(int j=1; j&lt;n; j++)</span><br><span class="line">            if(text1.charAt(i) == text2.charAt(j))</span><br><span class="line">                memo[i][j] = 1 + memo[i-1][j-1];</span><br><span class="line">            else</span><br><span class="line">                memo[i][j] = Math.max(memo[i-1][j], memo[i][j-1]);</span><br><span class="line">    return memo[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<p><strong>greedy</strong></p>
<h3 id="455题解"><a href="#455题解" class="headerlink" title="455题解"></a>455题解</h3><ul>
<li>greedy<ul>
<li>455 Assign Cookies：<a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">https://leetcode.com/problems/assign-cookies/</a><ul>
<li>分饼干，s为饼干大小，g为满意的最小值，返回最多可以让几个小朋友开心</li>
<li>Input: g=[1,2,3], s=[1,1]</li>
<li>Output: 1</li>
</ul>
</li>
<li>思路：贪心，最大的饼干满足最贪的小朋友</li>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line"></span><br><span class="line">    int gi = g.length-1, si = s.length-1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    while(gi&gt;=0 &amp;&amp; si&gt;=0) &#123;</span><br><span class="line">        if(s[si] &gt;= g[gi]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            si--;</span><br><span class="line">            gi--;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            gi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="435题解"><a href="#435题解" class="headerlink" title="435题解"></a>435题解</h3><ul>
<li>greedy<ul>
<li>435 Non-overlapping Intervals：<a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/non-overlapping-intervals/</a><ul>
<li>给定一个区间，问最少删除多少个区间，可以让这些区间之间不重叠</li>
<li>Input: [[1,2],[2,3],[3,4],[1,3]]</li>
<li>Output: 1</li>
</ul>
</li>
<li>思路：贪心，选择区间结尾最早的且和前面不重叠</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">    if(intervals.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结尾早的靠前</span><br><span class="line">    Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            if (o1[1] != o2[1]) &#123;</span><br><span class="line">                return o1[1] - o2[1];</span><br><span class="line">            &#125;</span><br><span class="line">            return o1[0] - o2[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int count = 1;</span><br><span class="line">    int pre = 0;</span><br><span class="line">    for(int i=1; i&lt;intervals.length; i++) &#123;</span><br><span class="line">        if(intervals[i][0] &gt;= intervals[pre][1]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路2：动态规划</li>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">    if(intervals.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(int[] o1, int[] o2) &#123;</span><br><span class="line">            if (o1[0] != o2[0]) &#123;</span><br><span class="line">                return o1[0] - o2[0];</span><br><span class="line">            &#125;</span><br><span class="line">            return o1[1] - o2[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // memo[i] 表示使用 intervals[0...i] 的区间能构成的最长不重叠区间序列的长度；</span><br><span class="line">    int[] memo = new int[intervals.length];</span><br><span class="line">    Arrays.fill(memo, 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (intervals[i][0] &gt;= intervals[j][1]) &#123;</span><br><span class="line">                memo[i] = Math.max(memo[i], 1 + memo[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = 0; i &lt; memo.length; i++) &#123;</span><br><span class="line">        count = Math.max(count, memo[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return intervals.length - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<hr>
<p><strong>backtracking</strong></p>
<h3 id="17题解"><a href="#17题解" class="headerlink" title="17题解"></a>17题解</h3><ul>
<li>17题解<ul>
<li>17 Letter Combinations of a Phone Number：<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a><ul>
<li>返回数字字符串的所有字母组合</li>
<li>Input: “23”</li>
<li>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li>
</ul>
</li>
<li>思路：递归</li>
<li>时间复杂度：O(2^n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private String[] letterMap = &#123;</span><br><span class="line">        &quot; &quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;abc&quot;,</span><br><span class="line">        &quot;def&quot;,</span><br><span class="line">        &quot;ghi&quot;,</span><br><span class="line">        &quot;jkl&quot;,</span><br><span class="line">        &quot;mno&quot;,</span><br><span class="line">        &quot;pqrs&quot;,</span><br><span class="line">        &quot;tuv&quot;,</span><br><span class="line">        &quot;wxyz&quot;</span><br><span class="line">&#125;;</span><br><span class="line">private ArrayList&lt;String&gt; resultList;</span><br><span class="line">public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">    resultList = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (digits.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    findCombination(digits, 0, &quot;&quot;);</span><br><span class="line">    return resultList;</span><br><span class="line">&#125;</span><br><span class="line">// s保存从digits[0...index-1]的字符串</span><br><span class="line">private void findCombination(String digits, int index, String s) &#123;</span><br><span class="line">    if (index==digits.length()) &#123;</span><br><span class="line">        resultList.add(s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Character c = digits.charAt(index);</span><br><span class="line">    String letters = letterMap[c-&apos;0&apos;];</span><br><span class="line">    for (int i=0; i&lt;letters.length(); i++) &#123;</span><br><span class="line">        findCombination(digits, index+1, s+letters.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="46题解"><a href="#46题解" class="headerlink" title="46题解"></a>46题解</h3><ul>
<li>backtracking<ul>
<li>46 Permutations：<a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><ul>
<li>求数组的全排列</li>
<li>Input: [1,2,3]</li>
<li>Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>
</ul>
</li>
<li>思路：回溯法，Perms(nums)={取出一个数字}+Perms(nums-这个数字)</li>
<li>时间复杂度：O(n^n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">private boolean[] used;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(nums.length == 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    used = new boolean[nums.length];</span><br><span class="line">    generatePerm(nums, 0, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void generatePerm(int[] nums, int index, LinkedList&lt;Integer&gt; p) &#123;</span><br><span class="line">    if(index == nums.length) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;) p.clone());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0; i&lt;nums.length; i++) &#123;</span><br><span class="line">        // used[i]没有被使用</span><br><span class="line">        if(!used[i]) &#123;</span><br><span class="line">            p.addLast(nums[i]);</span><br><span class="line">            used[i] = true;</span><br><span class="line">            generatePerm(nums, index+1, p);</span><br><span class="line">            p.removeLast();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="77题解"><a href="#77题解" class="headerlink" title="77题解"></a>77题解</h3><ul>
<li>backtracking<ul>
<li>77 Combinations：<a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode.com/problems/combinations/</a><ul>
<li>在n个数字中选出k个数字的所有组合</li>
<li>Input: n = 4, k = 2</li>
<li>Output: [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</li>
</ul>
</li>
<li>思路：回溯法</li>
<li>时间复杂度：O(n^k)</li>
<li>空间复杂度：O(k)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if(n&lt;=0 || k&lt;=0 || k&gt;n) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateCombinations(n, k, 1, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void generateCombinations(int n, int k, int start, LinkedList&lt;Integer&gt; c) &#123;</span><br><span class="line">    if(c.size() == k) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;)c.clone());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=start; i&lt;=n; i++) &#123;</span><br><span class="line">        c.addLast(i);</span><br><span class="line">        generateCombinations(n, k, i+1, c);</span><br><span class="line">        c.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优化：剪枝<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || k&lt;=<span class="number">0</span> || k&gt;n) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    generateCombinations(n, k, <span class="number">1</span>, <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateCombinations</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.size() == k) &#123;</span><br><span class="line">        res.add((List&lt;Integer&gt;)c.clone());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有k-c.size()个空位，所以，[i...n]中至少有k-c.size()个元素</span></span><br><span class="line">    <span class="comment">// i最多为n-(k-c.size())+1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=n-(k-c.size())+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        c.addLast(i);</span><br><span class="line">        generateCombinations(n, k, i+<span class="number">1</span>, c);</span><br><span class="line">        c.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="79题解"><a href="#79题解" class="headerlink" title="79题解"></a>79题解</h3><ul>
<li>backtracking<ul>
<li>79 Word Search：<a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a><ul>
<li>查询二维字符数组中，连起来是否有word</li>
<li>Input: board=[[‘A’,’B’,’C’,’E’],[‘S’,’F’,’C’,’S’],[‘A’,’D’,’E’,’E’]]，word=”ABCCED”</li>
<li>Output: true</li>
</ul>
</li>
<li>思路：回溯法，递归树中搜索上下左右四个方向</li>
<li>时间复杂度：O(m<em>n</em>m*n)</li>
<li>空间复杂度：O(m*n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private boolean[][] visited;</span><br><span class="line">private int[][] d = &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int m, n;</span><br><span class="line">public boolean exist(char[][] board, String word) &#123;</span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[0].length;</span><br><span class="line">    visited = new boolean[m][n];</span><br><span class="line">    for(int i=0; i&lt;m; i++) &#123;</span><br><span class="line">        for(int j=0; j&lt;n; j++) &#123;</span><br><span class="line">            if(searchWord(board, word, 0, i, j) == true) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">private boolean searchWord(char[][] board, String word, int index, int startx, int starty) &#123;</span><br><span class="line">    if(index == word.length()-1) &#123;</span><br><span class="line">        return board[startx][starty] == word.charAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">    if(board[startx][starty] == word.charAt(index)) &#123;</span><br><span class="line">        visited[startx][starty] = true;</span><br><span class="line">        // 向四个方向寻找</span><br><span class="line">        for(int i=0; i&lt;4; i++) &#123;</span><br><span class="line">            int newx = startx + d[i][0];</span><br><span class="line">            int newy = starty + d[i][1];</span><br><span class="line">            if(inArea(newx, newy) &amp;&amp; !visited[newx][newy]) &#123;</span><br><span class="line">                if(searchWord(board, word, index+1, newx, newy) == true) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[startx][starty] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">private boolean inArea(int x, int y) &#123;</span><br><span class="line">    return x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="200题解"><a href="#200题解" class="headerlink" title="200题解"></a>200题解</h3><ul>
<li>backtracking<ul>
<li>200 Number of Islands：<a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a><ul>
<li>二维数组中查找岛屿的个数，值为1</li>
<li>Input: [[11110][11010][11000][00000]]</li>
<li>Output: 1</li>
</ul>
</li>
<li>思路：回溯法，递归树中搜索上下左右四个方向</li>
<li>时间复杂度：O(n*m)</li>
<li>空间复杂度：O(n*m)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private boolean[][] visited;</span><br><span class="line">private int[][] d = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">private int m, n;</span><br><span class="line">public int numIslands(char[][] grid) &#123;</span><br><span class="line">    if(grid.length==0 || grid[0].length==0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[0].length;</span><br><span class="line">    visited = new boolean[m][n];</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i=0; i&lt;m; i++) &#123;</span><br><span class="line">        for(int j=0; j&lt;n; j++) &#123;</span><br><span class="line">            if(grid[i][j]==&apos;1&apos; &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void dfs(char[][] grid, int x, int y) &#123;</span><br><span class="line">    visited[x][y] = true;</span><br><span class="line">    for(int i=0; i&lt;4; i++) &#123;</span><br><span class="line">        int newx = x + d[i][0];</span><br><span class="line">        int newy = y + d[i][1];</span><br><span class="line">        if(inArea(newx, newy) &amp;&amp; grid[newx][newy]==&apos;1&apos; &amp;&amp;!visited[newx][newy]) &#123;</span><br><span class="line">            dfs(grid, newx, newy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean inArea(int x, int y)&#123;</span><br><span class="line">    return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="51题解"><a href="#51题解" class="headerlink" title="51题解"></a>51题解</h3><ul>
<li>backtracking<ul>
<li>51 N Queens：<a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode.com/problems/n-queens/</a><ul>
<li>n皇后问题的所有解，在横竖斜方向都不会有两个皇后</li>
<li>Input: 4</li>
<li>Output: [[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</li>
</ul>
</li>
<li>思路：回溯法</li>
<li>时间复杂度：O(n^n)</li>
<li>空间复杂度：O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private boolean[] col;</span><br><span class="line">private boolean[] dia1;</span><br><span class="line">private boolean[] dia2;</span><br><span class="line">private ArrayList&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">    res = new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    col = new boolean[n];</span><br><span class="line">    dia1 = new boolean[2*n-1];</span><br><span class="line">    dia2 = new boolean[2*n-1];</span><br><span class="line"></span><br><span class="line">    putQueen(n, 0, new LinkedList&lt;Integer&gt;());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">private void putQueen(int n, int index, LinkedList&lt;Integer&gt; row)&#123;</span><br><span class="line">    if(index == n) &#123;</span><br><span class="line">        res.add(generateBoard(n, row));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        if(!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) &#123;</span><br><span class="line">            row.addLast(i);</span><br><span class="line">            col[i] = true;</span><br><span class="line">            dia1[index+i] = true;</span><br><span class="line">            dia2[index-i+n-1] = true;</span><br><span class="line">            putQueen(n, index+1, row);</span><br><span class="line">            col[i] = false;</span><br><span class="line">            dia1[index + i] = false;</span><br><span class="line">            dia2[index - i + n - 1] = false;</span><br><span class="line">            row.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">private List&lt;String&gt; generateBoard(int n, LinkedList&lt;Integer&gt; row) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; board = new ArrayList&lt;String&gt;();</span><br><span class="line">    for(int i=0; i&lt;n; i++) &#123;</span><br><span class="line">        char[] chars = new char[n];</span><br><span class="line">        Arrays.fill(chars, &apos;.&apos;);</span><br><span class="line">        chars[row.get(i)] = &apos;Q&apos;;</span><br><span class="line">        board.add(new String(chars));</span><br><span class="line">    &#125;</span><br><span class="line">    return board;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Ebbinghaus/" rel="tag"># Ebbinghaus</a>
            
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/12/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B1%BB%E7%BB%8F%E5%85%B8%E9%A2%98/" rel="next" title="算法思想-滑动窗口类经典题">
                  <i class="fa fa-chevron-left"></i> 算法思想-滑动窗口类经典题
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/01/11/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87Offer-%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/" rel="prev" title="剑指Offer-分类汇总">
                  剑指Offer-分类汇总 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stack"><span class="nav-number">1.1.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue"><span class="nav-number">1.2.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linkedlist"><span class="nav-number">1.3.</span> <span class="nav-text">linkedlist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binarytree"><span class="nav-number">1.4.</span> <span class="nav-text">binarytree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection"><span class="nav-number">1.5.</span> <span class="nav-text">collection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法思想"><span class="nav-number">2.</span> <span class="nav-text">算法思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cursor"><span class="nav-number">2.1.</span> <span class="nav-text">cursor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#partition"><span class="nav-number">2.2.</span> <span class="nav-text">partition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pointers"><span class="nav-number">2.3.</span> <span class="nav-text">pointers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#window"><span class="nav-number">2.4.</span> <span class="nav-text">window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dp"><span class="nav-number">2.5.</span> <span class="nav-text">dp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#greedy"><span class="nav-number">2.6.</span> <span class="nav-text">greedy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#backtracking"><span class="nav-number">2.7.</span> <span class="nav-text">backtracking</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题解"><span class="nav-number">3.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20题解"><span class="nav-number">3.0.1.</span> <span class="nav-text">20题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144题解"><span class="nav-number">3.0.2.</span> <span class="nav-text">144题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102题解"><span class="nav-number">3.0.3.</span> <span class="nav-text">102题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347题解"><span class="nav-number">3.0.4.</span> <span class="nav-text">347题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279题解-Queue"><span class="nav-number">3.0.5.</span> <span class="nav-text">279题解-Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206题解"><span class="nav-number">3.0.6.</span> <span class="nav-text">206题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#203题解"><span class="nav-number">3.0.7.</span> <span class="nav-text">203题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24题解"><span class="nav-number">3.0.8.</span> <span class="nav-text">24题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#237题解"><span class="nav-number">3.0.9.</span> <span class="nav-text">237题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19题解"><span class="nav-number">3.0.10.</span> <span class="nav-text">19题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234题解"><span class="nav-number">3.0.11.</span> <span class="nav-text">234题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104题解"><span class="nav-number">3.0.12.</span> <span class="nav-text">104题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111题解"><span class="nav-number">3.0.13.</span> <span class="nav-text">111题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226题解"><span class="nav-number">3.0.14.</span> <span class="nav-text">226题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100题解"><span class="nav-number">3.0.15.</span> <span class="nav-text">100题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101题解"><span class="nav-number">3.0.16.</span> <span class="nav-text">101题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222题解"><span class="nav-number">3.0.17.</span> <span class="nav-text">222题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110题解"><span class="nav-number">3.0.18.</span> <span class="nav-text">110题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112题解"><span class="nav-number">3.0.19.</span> <span class="nav-text">112题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404题解"><span class="nav-number">3.0.20.</span> <span class="nav-text">404题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257题解"><span class="nav-number">3.0.21.</span> <span class="nav-text">257题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113题解"><span class="nav-number">3.0.22.</span> <span class="nav-text">113题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129题解"><span class="nav-number">3.0.23.</span> <span class="nav-text">129题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437题解"><span class="nav-number">3.0.24.</span> <span class="nav-text">437题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235题解"><span class="nav-number">3.0.25.</span> <span class="nav-text">235题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#349题解"><span class="nav-number">3.0.26.</span> <span class="nav-text">349题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#350题解"><span class="nav-number">3.0.27.</span> <span class="nav-text">350题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#242题解"><span class="nav-number">3.0.28.</span> <span class="nav-text">242题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#202题解"><span class="nav-number">3.0.29.</span> <span class="nav-text">202题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#290题解"><span class="nav-number">3.0.30.</span> <span class="nav-text">290题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1题解"><span class="nav-number">3.0.31.</span> <span class="nav-text">1题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#454题解"><span class="nav-number">3.0.32.</span> <span class="nav-text">454题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#447题解"><span class="nav-number">3.0.33.</span> <span class="nav-text">447题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#804题解"><span class="nav-number">3.0.34.</span> <span class="nav-text">804题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#219题解"><span class="nav-number">3.0.35.</span> <span class="nav-text">219题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#220题解"><span class="nav-number">3.0.36.</span> <span class="nav-text">220题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283题解"><span class="nav-number">3.0.37.</span> <span class="nav-text">283题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27题解"><span class="nav-number">3.0.38.</span> <span class="nav-text">27题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75题解"><span class="nav-number">3.0.39.</span> <span class="nav-text">75题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215题解"><span class="nav-number">3.0.40.</span> <span class="nav-text">215题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167题解"><span class="nav-number">3.0.41.</span> <span class="nav-text">167题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11题解"><span class="nav-number">3.0.42.</span> <span class="nav-text">11题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125题解"><span class="nav-number">3.0.43.</span> <span class="nav-text">125题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#345题解"><span class="nav-number">3.0.44.</span> <span class="nav-text">345题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#209题解"><span class="nav-number">3.0.45.</span> <span class="nav-text">209题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3题解"><span class="nav-number">3.0.46.</span> <span class="nav-text">3题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#438题解"><span class="nav-number">3.0.47.</span> <span class="nav-text">438题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76题解"><span class="nav-number">3.0.48.</span> <span class="nav-text">76题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#567题解"><span class="nav-number">3.0.49.</span> <span class="nav-text">567题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#424题解"><span class="nav-number">3.0.50.</span> <span class="nav-text">424题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70题解"><span class="nav-number">3.0.51.</span> <span class="nav-text">70题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#343题解"><span class="nav-number">3.0.52.</span> <span class="nav-text">343题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198题解"><span class="nav-number">3.0.53.</span> <span class="nav-text">198题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279题解"><span class="nav-number">3.0.54.</span> <span class="nav-text">279题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91题解"><span class="nav-number">3.0.55.</span> <span class="nav-text">91题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416题解"><span class="nav-number">3.0.56.</span> <span class="nav-text">416题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300题解"><span class="nav-number">3.0.57.</span> <span class="nav-text">300题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143题解"><span class="nav-number">3.0.58.</span> <span class="nav-text">1143题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#455题解"><span class="nav-number">3.0.59.</span> <span class="nav-text">455题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435题解"><span class="nav-number">3.0.60.</span> <span class="nav-text">435题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17题解"><span class="nav-number">3.0.61.</span> <span class="nav-text">17题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46题解"><span class="nav-number">3.0.62.</span> <span class="nav-text">46题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77题解"><span class="nav-number">3.0.63.</span> <span class="nav-text">77题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79题解"><span class="nav-number">3.0.64.</span> <span class="nav-text">79题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200题解"><span class="nav-number">3.0.65.</span> <span class="nav-text">200题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51题解"><span class="nav-number">3.0.66.</span> <span class="nav-text">51题解</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Louis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Louis</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.1
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.4.1.js"></script>

<script src="/js/motion.js?v=7.4.1.js"></script>


<script src="/js/schemes/muse.js?v=7.4.1.js"></script>



<script src="/js/next-boot.js?v=7.4.1.js"></script>




  








  
<script src="/js/local-search.js?v=7.4.1.js"></script>















  

  

  

  

</body>
</html>
